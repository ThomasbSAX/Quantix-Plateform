{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes P</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes P</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>L’étude de la complexité des problèmes, en particulier ceux
appartenant à la classe P, constitue un pilier fondamental de
l’informatique théorique. Cette notion émerge dans les années 1960 et
1970, avec les travaux pionniers de Stephen Cook, Richard Karp et
d’autres chercheurs, pour répondre à une question cruciale : comment
classer les problèmes en fonction de la quantité de ressources
nécessaires pour les résoudre. La classe P, qui regroupe les problèmes
solubles en temps polynomial par une machine de Turing déterministe,
représente un cadre indispensable pour comprendre les limites et les
possibilités des algorithmes efficaces. Elle permet de distinguer les
problèmes "faciles" (au sens algorithmique) des problèmes
potentiellement intraitables, ouvrant ainsi la voie à l’étude
approfondie de la complexité computationnelle.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre ce qu’est un problème appartenant à la classe P,
commençons par nous demander ce que signifie résoudre un problème de
manière efficace. Intuitivement, un algorithme est efficace s’il peut
résoudre le problème en un temps raisonnable, c’est-à-dire polynomial
par rapport à la taille de l’entrée. La classe P formalise cette
intuition.</p>
<div class="definition">
<p>Soit <span class="math inline">\(\Sigma\)</span> un alphabet fini. Un
problème de décision <span class="math inline">\(L \subseteq
\Sigma^*\)</span> appartient à la classe P s’il existe une machine de
Turing déterministe <span class="math inline">\(M\)</span>, un polynôme
<span class="math inline">\(p(n)\)</span> et une constante <span
class="math inline">\(c &gt; 0\)</span> tels que pour tout mot <span
class="math inline">\(w \in \Sigma^*\)</span>, la machine <span
class="math inline">\(M\)</span> accepte ou rejette <span
class="math inline">\(w\)</span> en un temps au plus <span
class="math inline">\(c \cdot p(|w|)\)</span>.</p>
<p>En d’autres termes, il existe une machine de Turing déterministe
<span class="math inline">\(M\)</span> et un polynôme <span
class="math inline">\(p(n)\)</span> tels que pour tout mot <span
class="math inline">\(w \in \Sigma^*\)</span>, <span
class="math display">\[M(w) = 1 \text{ si et seulement si } w \in
L,\]</span> et le temps d’exécution de <span
class="math inline">\(M\)</span> sur l’entrée <span
class="math inline">\(w\)</span> est borné par <span
class="math inline">\(p(|w|)\)</span>.</p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<p>Un des théorèmes fondamentaux concernant la classe P est le théorème
de Savitch, qui établit une relation entre les classes P et NP. Ce
théorème montre que tout problème solvable en temps exponentiel par une
machine de Turing non déterministe peut être résolu en temps polynomial
par une machine de Turing déterministe utilisant un espace
logarithmique.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(L\)</span> un langage tel que <span
class="math inline">\(L \in \text{NSPACE}(s(n))\)</span>, où <span
class="math inline">\(s(n) \geq \log n\)</span>. Alors, <span
class="math inline">\(L \in \text{DSPACE}(s(n)^2)\)</span>.</p>
<p>En d’autres termes, pour tout langage <span
class="math inline">\(L\)</span> et toute fonction <span
class="math inline">\(s(n) \geq \log n\)</span>, si <span
class="math inline">\(L\)</span> peut être reconnu par une machine de
Turing non déterministe utilisant un espace au plus <span
class="math inline">\(s(n)\)</span>, alors il existe une machine de
Turing déterministe qui reconnaît <span class="math inline">\(L\)</span>
en utilisant un espace au plus <span
class="math inline">\(s(n)^2\)</span>.</p>
</div>
<h1 id="preuves">Preuves</h1>
<p>Pour prouver le théorème de Savitch, nous utilisons une méthode de
simulation des machines non déterministes par des machines
déterministes. L’idée est que pour chaque configuration d’une machine
non déterministe, la machine déterministe peut explorer toutes les
configurations possibles de manière systématique.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(M\)</span> une
machine de Turing non déterministe qui reconnaît le langage <span
class="math inline">\(L\)</span> en utilisant un espace au plus <span
class="math inline">\(s(n)\)</span>. Nous construisons une machine de
Turing déterministe <span class="math inline">\(M&#39;\)</span> qui
simule <span class="math inline">\(M\)</span> en utilisant un espace au
plus <span class="math inline">\(s(n)^2\)</span>.</p>
<p>Pour tout mot <span class="math inline">\(w\)</span>, la machine
<span class="math inline">\(M&#39;\)</span> simule les transitions de
<span class="math inline">\(M\)</span> en explorant toutes les
configurations possibles. Plus précisément, pour chaque configuration
<span class="math inline">\((q, u, v)\)</span>, où <span
class="math inline">\(q\)</span> est l’état de la machine et <span
class="math inline">\(u, v\)</span> sont les parties gauche et droite du
ruban, <span class="math inline">\(M&#39;\)</span> vérifie si cette
configuration est accessible depuis la configuration initiale.</p>
<p>La machine <span class="math inline">\(M&#39;\)</span> utilise un
espace au plus <span class="math inline">\(s(n)^2\)</span> pour stocker
les configurations intermédiaires et effectuer la simulation. Ainsi,
<span class="math inline">\(M&#39;\)</span> reconnaît le langage <span
class="math inline">\(L\)</span> en utilisant un espace au plus <span
class="math inline">\(s(n)^2\)</span>. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Le théorème de Savitch a plusieurs conséquences importantes pour la
théorie de la complexité. Nous en listons quelques-unes ci-dessous.</p>
<ol>
<li><p><strong>Corollaire 1:</strong> Si <span
class="math inline">\(\text{NSPACE}(s(n)) =
\text{DSPACE}(s(n)^2)\)</span>, alors <span
class="math inline">\(\text{NSPACE}(s(n)) =
\text{DSPACE}(s(n)^2)\)</span>.</p>
<p>Ce corollaire montre que les classes d’espace non déterministe et
déterministe sont égales lorsque l’espace est polynomial.</p></li>
<li><p><strong>Corollaire 2:</strong> Si <span
class="math inline">\(\text{P} = \text{NP}\)</span>, alors <span
class="math inline">\(\text{NSPACE}(s(n)) =
\text{DSPACE}(s(n)^2)\)</span>.</p>
<p>Ce corollaire est une conséquence directe du théorème de Savitch et
montre que l’égalité des classes P et NP implique l’égalité des classes
d’espace non déterministe et déterministe.</p></li>
<li><p><strong>Corollaire 3:</strong> Si <span
class="math inline">\(\text{P} = \text{BPP}\)</span>, alors <span
class="math inline">\(\text{NSPACE}(s(n)) =
\text{DSPACE}(s(n)^2)\)</span>.</p>
<p>Ce corollaire montre que l’égalité des classes P et BPP implique
également l’égalité des classes d’espace non déterministe et
déterministe.</p></li>
</ol>
<p>Chacun de ces corollaires est une conséquence directe du théorème de
Savitch et met en lumière les relations profondes entre les différentes
classes de complexité.</p>
</body>
</html>
{% include "footer.html" %}

