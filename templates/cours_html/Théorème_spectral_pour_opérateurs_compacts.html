{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Théorème spectral pour opérateurs compacts</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Théorème spectral pour opérateurs compacts</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>Le théorème spectral est un pilier fondamental de l’analyse
fonctionnelle, reliant la structure algébrique des opérateurs linéaires
à leurs propriétés analytiques. Historiquement, il émerge de la
nécessité de généraliser les concepts de diagonalisation des matrices à
des espaces de dimensions infinies. Ce théorème est indispensable dans
l’étude des opérateurs différentiels, des systèmes dynamiques et de la
mécanique quantique, où il permet de décomposer les opérateurs en
éléments plus simples et mieux compris.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Avant d’énoncer le théorème spectral, il est crucial de définir les
concepts clés qui y sont associés.</p>
<h2 class="unnumbered" id="opérateur-compact">Opérateur compact</h2>
<p>Considérons un espace de Banach <span
class="math inline">\(E\)</span> et un opérateur linéaire continu <span
class="math inline">\(T: E \rightarrow E\)</span>. Nous cherchons à
caractériser les opérateurs qui transforment des suites bornées en
suites convergentes. Un tel opérateur est dit compact si, pour toute
suite <span class="math inline">\((x_n)\)</span> bornée dans <span
class="math inline">\(E\)</span>, la suite <span
class="math inline">\((T(x_n))\)</span> admet une sous-suite
convergente.</p>
<p>Formellement, <span class="math inline">\(T\)</span> est compact si
et seulement si : <span class="math display">\[\forall (x_n) \subset E,
\exists (x_{n_k}) \subset (x_n), \exists y \in E, \lim_{k \rightarrow
\infty} T(x_{n_k}) = y.\]</span></p>
<h2 class="unnumbered" id="spectre-dun-opérateur">Spectre d’un
opérateur</h2>
<p>Le spectre <span class="math inline">\(\sigma(T)\)</span> d’un
opérateur linéaire continu <span class="math inline">\(T\)</span> sur un
espace de Banach est l’ensemble des nombres complexes <span
class="math inline">\(\lambda\)</span> pour lesquels <span
class="math inline">\(T - \lambda I\)</span> n’est pas inversible.
Autrement dit, le spectre est l’ensemble des <span
class="math inline">\(\lambda\)</span> tels que : <span
class="math display">\[\exists x \in E, x \neq 0, (T - \lambda I)(x) =
0.\]</span></p>
<h1 class="unnumbered" id="théorème-spectral">Théorème spectral</h1>
<p>Le théorème spectral pour les opérateurs compacts est une
généralisation du résultat classique de diagonalisation des matrices. Il
affirme que tout opérateur compact auto-adjoint sur un espace de Hilbert
peut être diagonalisé dans une base orthonormale.</p>
<h2 class="unnumbered" id="énoncé-du-théorème">Énoncé du théorème</h2>
<p>Soit <span class="math inline">\(H\)</span> un espace de Hilbert et
<span class="math inline">\(T: H \rightarrow H\)</span> un opérateur
compact auto-adjoint. Alors, il existe une base orthonormale <span
class="math inline">\((e_n)\)</span> de <span
class="math inline">\(H\)</span> et une suite de scalaires réels <span
class="math inline">\((\lambda_n)\)</span> telle que : <span
class="math display">\[T(x) = \sum_{n=1}^{\infty} \lambda_n \langle x,
e_n \rangle e_n, \quad \forall x \in H.\]</span></p>
<p>De manière équivalente, pour tout <span class="math inline">\(x \in
H\)</span>, on a : <span class="math display">\[T(x) =
\sum_{n=1}^{\infty} \lambda_n \langle x, e_n \rangle e_n.\]</span></p>
<h2 class="unnumbered" id="démonstration">Démonstration</h2>
<p>Pour démontrer le théorème spectral, nous suivons plusieurs étapes
clés.</p>
<h3 class="unnumbered" id="existence-des-valeurs-propres">Existence des
valeurs propres</h3>
<p>Tout d’abord, nous montrons que <span
class="math inline">\(T\)</span> admet au moins une valeur propre non
nulle. Considérons la suite <span
class="math inline">\((T(x_n))\)</span> où <span
class="math inline">\(x_n \in H\)</span> et <span
class="math inline">\(\|x_n\| = 1\)</span>. Par compacité, il existe une
sous-suite convergente <span class="math inline">\((T(x_{n_k}))\)</span>
vers un élément <span class="math inline">\(y \in H\)</span>.</p>
<p>En utilisant l’auto-adjonction de <span
class="math inline">\(T\)</span>, nous avons : <span
class="math display">\[\|T(x_{n_k}) - \lambda x_{n_k}\|^2 =
\|T(x_{n_k})\|^2 - 2\lambda \langle T(x_{n_k}), x_{n_k} \rangle +
|\lambda|^2 \|x_{n_k}\|^2.\]</span></p>
<p>En choisissant <span class="math inline">\(\lambda\)</span> tel que
<span class="math inline">\(|\lambda| = \|T\|\)</span>, nous pouvons
montrer que <span class="math inline">\(T - \lambda I\)</span> n’est pas
injectif, et donc <span class="math inline">\(\lambda\)</span> est une
valeur propre de <span class="math inline">\(T\)</span>.</p>
<h3 class="unnumbered"
id="construction-de-la-base-orthonormale">Construction de la base
orthonormale</h3>
<p>Ensuite, nous construisons une base orthonormale à partir des
vecteurs propres de <span class="math inline">\(T\)</span>. Soit <span
class="math inline">\(\lambda_1\)</span> une valeur propre non nulle de
<span class="math inline">\(T\)</span> et soit <span
class="math inline">\(E_{\lambda_1}\)</span> le sous-espace propre
associé. Nous choisissons un vecteur <span class="math inline">\(e_1 \in
E_{\lambda_1}\)</span> tel que <span class="math inline">\(\|e_1\| =
1\)</span>.</p>
<p>Nous répétons ce processus pour les sous-espaces propres associés aux
autres valeurs propres <span class="math inline">\(\lambda_2, \lambda_3,
\ldots\)</span>. Par le théorème de Gram-Schmidt, nous pouvons
orthonormaliser cette famille de vecteurs propres.</p>
<h3 class="unnumbered" id="décomposition-spectrale">Décomposition
spectrale</h3>
<p>Enfin, nous montrons que la famille <span
class="math inline">\((e_n)\)</span> ainsi construite est une base de
<span class="math inline">\(H\)</span>. Pour tout <span
class="math inline">\(x \in H\)</span>, nous avons : <span
class="math display">\[x = \sum_{n=1}^{\infty} \langle x, e_n \rangle
e_n.\]</span></p>
<p>En appliquant <span class="math inline">\(T\)</span> à cette
expression, nous obtenons : <span class="math display">\[T(x) =
\sum_{n=1}^{\infty} T(\langle x, e_n \rangle e_n) = \sum_{n=1}^{\infty}
\langle x, e_n \rangle T(e_n) = \sum_{n=1}^{\infty} \lambda_n \langle x,
e_n \rangle e_n.\]</span></p>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<p>Le théorème spectral entraîne plusieurs propriétés importantes pour
les opérateurs compacts auto-adjoints.</p>
<h2 class="unnumbered" id="propriété-i">Propriété (i)</h2>
<p>Les valeurs propres d’un opérateur compact auto-adjoint sont réelles
et forment une suite convergente vers zéro.</p>
<h2 class="unnumbered" id="preuve-de-i">Preuve de (i)</h2>
<p>Soit <span class="math inline">\(\lambda_n\)</span> une suite de
valeurs propres distinctes. Par compacité, la suite <span
class="math inline">\((T(x_n))\)</span> est convergente pour toute suite
bornée <span class="math inline">\((x_n)\)</span>. En particulier, si
<span class="math inline">\(x_n\)</span> est un vecteur propre associé à
<span class="math inline">\(\lambda_n\)</span>, alors <span
class="math inline">\(T(x_n) = \lambda_n x_n\)</span>. Comme <span
class="math inline">\(\|x_n\| = 1\)</span>, nous avons <span
class="math inline">\(|\lambda_n| \leq \|T\|\)</span>. Par extraction
d’une sous-suite, nous pouvons supposer que <span
class="math inline">\(\lambda_n\)</span> converge vers une limite <span
class="math inline">\(\lambda\)</span>. En passant à la limite dans
l’équation <span class="math inline">\(T(x_n) = \lambda_n x_n\)</span>,
nous obtenons <span class="math inline">\(T(x) = \lambda x\)</span>, où
<span class="math inline">\(x\)</span> est la limite de <span
class="math inline">\((x_n)\)</span>. Ainsi, <span
class="math inline">\(\lambda\)</span> est une valeur propre et la suite
<span class="math inline">\((\lambda_n)\)</span> converge vers zéro.</p>
<h2 class="unnumbered" id="propriété-ii">Propriété (ii)</h2>
<p>L’opérateur <span class="math inline">\(T\)</span> est positif si et
seulement si toutes ses valeurs propres sont positives.</p>
<h2 class="unnumbered" id="preuve-de-ii">Preuve de (ii)</h2>
<p>Si <span class="math inline">\(T\)</span> est positif, alors pour
tout vecteur propre <span class="math inline">\(x\)</span> associé à une
valeur propre <span class="math inline">\(\lambda\)</span>, nous avons :
<span class="math display">\[\langle T(x), x \rangle = \lambda \|x\|^2
\geq 0.\]</span></p>
<p>Ainsi, <span class="math inline">\(\lambda \geq 0\)</span>.
Réciproquement, si toutes les valeurs propres de <span
class="math inline">\(T\)</span> sont positives, alors pour tout <span
class="math inline">\(x \in H\)</span>, nous avons : <span
class="math display">\[\langle T(x), x \rangle = \sum_{n=1}^{\infty}
\lambda_n |\langle x, e_n \rangle|^2 \geq 0.\]</span></p>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>Le théorème spectral pour les opérateurs compacts est un outil
puissant qui permet de décomposer ces opérateurs en éléments plus
simples et mieux compris. Il trouve des applications dans de nombreux
domaines, notamment l’analyse fonctionnelle, la théorie des équations
différentielles et la mécanique quantique. La compréhension de ce
théorème est essentielle pour toute personne travaillant dans ces
domaines.</p>
</body>
</html>
{% include "footer.html" %}

