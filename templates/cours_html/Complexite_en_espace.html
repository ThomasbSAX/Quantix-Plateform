{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité en espace : une exploration mathématique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité en espace : une exploration
mathématique</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La complexité en espace, un concept fondamental en théorie de la
calculabilité et de la complexité computationnelle, émerge comme une
réponse aux limites des modèles classiques centrés uniquement sur le
temps de calcul. Historiquement, l’étude de la complexité en espace
trouve ses racines dans les travaux pionniers de Hartmanis et Stearns au
milieu du XXe siècle, qui ont cherché à quantifier non seulement le
temps nécessaire pour résoudre un problème, mais aussi la quantité de
mémoire requise.</p>
<p>Pourquoi cette notion est-elle indispensable ? Dans un monde où les
données explosent et où les ressources matérielles restent contraintes,
comprendre la complexité en espace permet de concevoir des algorithmes
optimaux non seulement en termes de rapidité, mais aussi d’efficacité
mémoire. Par exemple, dans le cadre des bases de données massives ou du
traitement du signal, minimiser l’espace utilisé peut faire la
différence entre un système viable et un système inutilisable.</p>
<h1 id="définitions">Définitions</h1>
<p>Avant de formaliser la notion de complexité en espace, il est
essentiel de comprendre ce que nous cherchons à mesurer. Imaginons un
algorithme qui traite une entrée de taille <span
class="math inline">\(n\)</span>. Nous voulons savoir combien d’espace
mémoire cet algorithme utilise en fonction de <span
class="math inline">\(n\)</span>, indépendamment du temps qu’il prend.
Cet espace peut être mesuré par le nombre de cellules de mémoire
utilisées, ou encore la taille des registres nécessaires.</p>
<p>Nous définissons formellement la complexité en espace comme suit
:</p>
<div class="definition">
<p>Soit <span class="math inline">\(M\)</span> une machine de Turing. La
fonction d’espace <span class="math inline">\(S_M : \mathbb{N}
\rightarrow \mathbb{N}\)</span> de <span
class="math inline">\(M\)</span> est définie par : <span
class="math display">\[S_M(n) = \max \{ i \mid \text{la cellule } i
\text{ est utilisée par } M \text{ sur une entrée de taille } n
\}\]</span></p>
<p>Pour une classe de machines <span
class="math inline">\(\mathcal{M}\)</span>, la complexité en espace est
définie comme : <span class="math display">\[S_{\mathcal{M}}(n) =
\max_{M \in \mathcal{M}} \{ S_M(n) \}\]</span></p>
<p>En termes quantifiés, cela s’écrit : <span
class="math display">\[\forall M \in \mathcal{M}, \exists n \in
\mathbb{N}, S_M(n) = \max \{ i \mid \text{la cellule } i \text{ est
utilisée par } M \text{ sur une entrée de taille } n \}\]</span></p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<p>Un des théorèmes fondamentaux en complexité en espace est le théorème
de Savitch, qui établit une relation entre la complexité en espace
déterministe et non-déterministe.</p>
<div class="theoreme">
<p>Pour toute fonction <span class="math inline">\(S(n) \geq n\)</span>,
si un problème peut être résolu par une machine de Turing
non-déterministe en espace <span class="math inline">\(S(n)\)</span>,
alors il peut être résolu par une machine de Turing déterministe en
espace <span class="math inline">\(S^2(n)\)</span>.</p>
</div>
<p>Pour comprendre ce théorème, considérons un problème qui peut être
résolu par une machine non-déterministe en utilisant <span
class="math inline">\(S(n)\)</span> cellules de mémoire. Le théorème de
Savitch affirme que ce même problème peut être résolu par une machine
déterministe, mais en utilisant <span
class="math inline">\(S^2(n)\)</span> cellules de mémoire. La
démonstration de ce théorème repose sur des techniques de simulation et
d’élimination de la non-déterminisme.</p>
<h1 id="preuves">Preuves</h1>
<p>La preuve du théorème de Savitch est un excellent exemple de la
puissance des techniques de simulation en théorie de la complexité.
Voici une esquisse de la preuve :</p>
<div class="proof">
<p><em>Proof.</em> Considérons une machine de Turing non-déterministe
<span class="math inline">\(N\)</span> qui résout un problème en espace
<span class="math inline">\(S(n)\)</span>. Nous voulons construire une
machine de Turing déterministe <span class="math inline">\(D\)</span>
qui simule <span class="math inline">\(N\)</span> en espace <span
class="math inline">\(S^2(n)\)</span>.</p>
<p>La simulation se fait de manière récursive. Pour chaque configuration
de <span class="math inline">\(N\)</span>, <span
class="math inline">\(D\)</span> explore toutes les possibilités
non-déterministes en utilisant l’espace supplémentaire pour stocker les
états intermédiaires. Plus précisément, <span
class="math inline">\(D\)</span> utilise un tableau de taille <span
class="math inline">\(S(n) \times S(n)\)</span> pour stocker les
configurations intermédiaires, ce qui explique le facteur <span
class="math inline">\(S^2(n)\)</span>.</p>
<p>Formellement, pour chaque étape de la simulation, <span
class="math inline">\(D\)</span> calcule : <span
class="math display">\[\forall i \in [1, S(n)], \exists j \in [1, S(n)],
\text{configuration}(i, j)\]</span></p>
<p>où <span class="math inline">\(\text{configuration}(i, j)\)</span>
représente l’état de la machine à l’étape <span
class="math inline">\(i\)</span> et à la position <span
class="math inline">\(j\)</span>. Cette double quantification reflète
l’exploration exhaustive des possibilités non-déterministes. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Le théorème de Savitch a plusieurs conséquences importantes, que nous
énumérons et démontrons ci-dessous :</p>
<ol>
<li><p>Pour toute fonction <span class="math inline">\(S(n) \geq
n\)</span>, si un problème est dans <span
class="math inline">\(NSPACE(S(n))\)</span>, alors il est dans <span
class="math inline">\(DSPACE(S^2(n))\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> Cette propriété est une reformulation directe du
théorème de Savitch. Elle montre que la hiérarchie des classes d’espace
non-déterministe est incluse dans celle des classes d’espace
déterministe, mais avec un facteur quadratique. ◻</p>
</div></li>
<li><p>Pour toute fonction <span class="math inline">\(S(n) \geq
n\)</span>, si un problème est dans <span
class="math inline">\(NSPACE(S(n))\)</span>, alors il est dans <span
class="math inline">\(DTIME(2^{O(S^2(n))})\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> Cette propriété découle du fait que la simulation
déterministe de l’espace <span class="math inline">\(S^2(n)\)</span>
peut être effectuée en temps exponentiel par rapport à l’espace utilisé.
En effet, chaque étape de la simulation peut être effectuée en temps
polynomial par rapport à <span class="math inline">\(S^2(n)\)</span>, et
il y a au plus <span class="math inline">\(2^{S^2(n)}\)</span>
configurations possibles. ◻</p>
</div></li>
<li><p>Pour toute fonction <span class="math inline">\(S(n) \geq
n\)</span>, si un problème est dans <span
class="math inline">\(DSPACE(S(n))\)</span>, alors il est dans <span
class="math inline">\(DTIME(2^{O(S(n))})\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> Cette propriété est une conséquence du fait que toute
machine de Turing déterministe en espace <span
class="math inline">\(S(n)\)</span> peut être simulée par une machine de
Turing à compteur en temps exponentiel. La simulation utilise l’espace
pour stocker les états intermédiaires, ce qui explique le facteur
exponentiel. ◻</p>
</div></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>La complexité en espace est un domaine riche et fascinant de la
théorie de la calculabilité. Les travaux de Hartmanis, Stearns et
Savitch ont jeté les bases d’une compréhension profonde des limites de
l’espace mémoire dans le calcul. Les théorèmes et propriétés présentés
ici ne sont qu’un aperçu des nombreuses questions ouvertes et des défis
passionnants qui restent à explorer.</p>
</body>
</html>
{% include "footer.html" %}

