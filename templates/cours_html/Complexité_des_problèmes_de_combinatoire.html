{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de combinatoire</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de combinatoire</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La combinatoire, cette branche des mathématiques qui étudie les
configurations discrètes et leurs propriétés, a toujours été un champ
fertile pour la théorie de la complexité. L’émergence des problèmes
combinatoires complexes est intimement liée à l’essor de l’informatique
théorique. Ces problèmes, souvent formulés en termes simples, cachent
une complexité algorithmique profonde qui a motivé le développement de
nouvelles classes de complexité et de techniques d’analyse.</p>
<p>Les problèmes combinatoires sont indispensables dans de nombreux
domaines, allant de l’optimisation des ressources à la cryptographie.
Leur complexité réside dans le fait qu’ils nécessitent souvent une
exploration exhaustive de configurations, ce qui les rend difficilement
tractables pour des instances de grande taille. Comprendre et classer
ces problèmes est crucial pour développer des algorithmes efficaces ou
prouver l’impossibilité de tels algorithmes.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour aborder la complexité des problèmes combinatoires, il est
essentiel de définir certains concepts fondamentaux. Commençons par le
problème de satisfaction de contraintes, ou SAT.</p>
<h2 id="définition-du-problème-sat">Définition du Problème SAT</h2>
<p>Imaginons un ensemble de variables booléennes et des contraintes
logiques qui doivent être satisfaites simultanément. Nous cherchons à
déterminer si une assignation de valeurs aux variables existe qui rende
toutes les contraintes vraies. Ce problème, connu sous le nom de SAT,
est un paradigme central en combinatoire.</p>
<div class="definition">
<p>Soit <span class="math inline">\(\Phi\)</span> une formule booléenne
en forme normale conjonctive (CNF) avec <span
class="math inline">\(n\)</span> variables <span
class="math inline">\(x_1, x_2, \ldots, x_n\)</span>. Le problème SAT
consiste à déterminer s’il existe une assignation <span
class="math inline">\(a: \{x_1, x_2, \ldots, x_n\} \rightarrow \{0,
1\}\)</span> telle que <span class="math inline">\(\Phi(a) =
1\)</span>.</p>
<p>Formellement, nous cherchons <span class="math inline">\(a\)</span>
tel que : <span class="math display">\[\exists a \in \{0, 1\}^n, \quad
\bigwedge_{i=1}^{m} C_i(a) = 1\]</span> où <span
class="math inline">\(C_i\)</span> sont les clauses de <span
class="math inline">\(\Phi\)</span>.</p>
</div>
<h2 id="définition-des-classes-de-complexité-p-et-np">Définition des
Classes de Complexité P et NP</h2>
<p>La théorie de la complexité classe les problèmes en fonction des
ressources nécessaires pour les résoudre. Les classes P et NP sont parmi
les plus importantes.</p>
<div class="definition">
<p>La classe P est l’ensemble des problèmes de décision qui peuvent être
résolus par une machine de Turing déterministe en temps polynomial.</p>
<p>Formellement, un problème <span class="math inline">\(L\)</span>
appartient à P s’il existe une machine de Turing déterministe <span
class="math inline">\(M\)</span> et un polynôme <span
class="math inline">\(p\)</span> tels que pour toute entrée <span
class="math inline">\(x\)</span>, <span class="math inline">\(M\)</span>
accepte ou rejette <span class="math inline">\(x\)</span> en un temps
inférieur à <span class="math inline">\(p(|x|)\)</span>.</p>
</div>
<div class="definition">
<p>La classe NP est l’ensemble des problèmes de décision pour lesquels
une solution proposée peut être vérifiée par une machine de Turing
déterministe en temps polynomial.</p>
<p>Formellement, un problème <span class="math inline">\(L\)</span>
appartient à NP s’il existe une machine de Turing déterministe <span
class="math inline">\(M\)</span> et un polynôme <span
class="math inline">\(p\)</span> tels que pour toute entrée <span
class="math inline">\(x\)</span>, si <span class="math inline">\(x \in
L\)</span>, alors il existe un certificat <span
class="math inline">\(c\)</span> de taille <span
class="math inline">\(|c| \leq p(|x|)\)</span> tel que <span
class="math inline">\(M\)</span> accepte <span class="math inline">\((x,
c)\)</span> en un temps inférieur à <span
class="math inline">\(p(|x|)\)</span>.</p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<h2 id="théorème-de-cook-levin">Théorème de Cook-Levin</h2>
<p>Le théorème de Cook-Levin établit que le problème SAT est NP-complet,
ce qui signifie qu’il est au moins aussi difficile que tout autre
problème dans NP.</p>
<div class="theorem">
<p>Le problème SAT est NP-complet.</p>
<p>Preuve : Nous devons montrer que SAT appartient à NP et qu’il est
NP-difficile. Pour la première partie, une solution proposée (une
assignation de variables) peut être vérifiée en temps polynomial. Pour
la seconde partie, tout problème dans NP peut être réduit à SAT en temps
polynomial.</p>
</div>
<h2 id="théorème-de-lanti-monotonie">Théorème de l’Anti-Monotonie</h2>
<p>Ce théorème est crucial pour comprendre la structure des problèmes
combinatoires.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(\mathcal{F}\)</span> une famille de
sous-ensembles d’un ensemble fini <span
class="math inline">\(E\)</span>. Si <span
class="math inline">\(\mathcal{F}\)</span> est anti-monotone, alors pour
tout <span class="math inline">\(A \in \mathcal{F}\)</span>, tout
sous-ensemble de <span class="math inline">\(A\)</span> appartient
également à <span class="math inline">\(\mathcal{F}\)</span>.</p>
<p>Preuve : Supposons que <span class="math inline">\(A \in
\mathcal{F}\)</span>. Par définition de l’anti-monotonie, tout
sous-ensemble de <span class="math inline">\(A\)</span> doit appartenir
à <span class="math inline">\(\mathcal{F}\)</span>.</p>
</div>
<h1 id="preuves">Preuves</h1>
<h2 id="preuve-de-lappartenance-de-sat-à-np">Preuve de l’Appartenance de
SAT à NP</h2>
<p>Pour montrer que SAT appartient à NP, nous devons démontrer qu’une
solution proposée peut être vérifiée en temps polynomial.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(\Phi\)</span> une
formule CNF et <span class="math inline">\(a\)</span> une assignation de
variables. Nous devons vérifier que <span class="math inline">\(\Phi(a)
= 1\)</span>. Pour chaque clause <span
class="math inline">\(C_i\)</span> de <span
class="math inline">\(\Phi\)</span>, nous vérifions qu’au moins une
littérale dans <span class="math inline">\(C_i\)</span> est vraie sous
l’assignation <span class="math inline">\(a\)</span>. Ce processus prend
un temps polynomial en la taille de <span
class="math inline">\(\Phi\)</span>. ◻</p>
</div>
<h2 id="preuve-de-lanti-monotonie">Preuve de l’Anti-Monotonie</h2>
<p>Pour prouver le théorème de l’anti-monotonie, nous utilisons la
définition même d’une famille anti-monotone.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(\mathcal{F}\)</span>
une famille anti-monotone et soit <span class="math inline">\(A \in
\mathcal{F}\)</span>. Par définition, pour tout sous-ensemble <span
class="math inline">\(B \subseteq A\)</span>, nous avons <span
class="math inline">\(B \in \mathcal{F}\)</span>. Cela montre que <span
class="math inline">\(\mathcal{F}\)</span> est bien anti-monotone. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<h2 id="propriété-de-fermeture-sous-réduction-polynomiale">Propriété de
Fermeture sous Réduction Polynomiale</h2>
<ul>
<li><p>(i) Si <span class="math inline">\(A\)</span> est NP-difficile et
<span class="math inline">\(B\)</span> est dans NP, alors <span
class="math inline">\(B\)</span> peut être réduit à <span
class="math inline">\(A\)</span> en temps polynomial.</p>
<p>Preuve : Par définition de la NP-difficulté, tout problème dans NP
peut être réduit à <span class="math inline">\(A\)</span> en temps
polynomial.</p></li>
<li><p>(ii) La classe NP est fermée sous réduction polynomiale.</p>
<p>Preuve : Si <span class="math inline">\(A\)</span> est dans NP et
<span class="math inline">\(B\)</span> peut être réduit à <span
class="math inline">\(A\)</span> en temps polynomial, alors <span
class="math inline">\(B\)</span> est dans NP.</p></li>
</ul>
<h2 id="corollaire-du-théorème-de-cook-levin">Corollaire du Théorème de
Cook-Levin</h2>
<ul>
<li><p>(i) Tout problème NP-complet est dans NP.</p>
<p>Preuve : Par définition, un problème NP-complet appartient à
NP.</p></li>
<li><p>(ii) Tout problème dans NP peut être réduit en temps polynomial à
un problème NP-complet.</p>
<p>Preuve : Par définition de la NP-complétude, tout problème dans NP
peut être réduit en temps polynomial à un problème NP-complet.</p></li>
</ul>
</body>
</html>
{% include "footer.html" %}

