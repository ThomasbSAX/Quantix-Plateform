{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes dans la classe BQP</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes dans la classe BQP</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>L’étude de la complexité des problèmes dans la classe BQP
(Bounded-Error Quantum Polynomial time) constitue une branche fascinante
de l’informatique théorique et de la physique quantique. Cette classe,
introduite par Richard J. Lipton et John G. Balasubramanian en 1995,
représente l’ensemble des problèmes qui peuvent être résolus par une
machine quantique en temps polynomial avec une probabilité d’erreur
bornée.</p>
<p>L’émergence de la classe BQP est étroitement liée au développement
des ordinateurs quantiques et à la compréhension des algorithmes
quantiques. Les problèmes dans cette classe sont particulièrement
intéressants car ils peuvent potentiellement être résolus plus
efficacement par des machines quantiques que par des ordinateurs
classiques. Cela ouvre des perspectives révolutionnaires pour des
domaines tels que la cryptographie, l’optimisation et la simulation de
systèmes quantiques.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre la complexité des problèmes dans la classe BQP, il
est essentiel de définir plusieurs concepts clés.</p>
<h2 id="problème-de-décision">Problème de Décision</h2>
<p>Un problème de décision est un problème pour lequel il existe un
ensemble fini d’entrées et un ensemble fini de sorties, généralement {0,
1}. Formellement, un problème de décision peut être défini comme suit
:</p>
<div class="definition">
<p><strong>Définition 1</strong>. <em>Un problème de décision est une
fonction <span class="math inline">\(L: \{0, 1\}^* \rightarrow \{0,
1\}\)</span>. Pour une entrée <span class="math inline">\(x \in \{0,
1\}^*\)</span>, la sortie <span class="math inline">\(L(x)\)</span> est
soit 0, soit 1.</em></p>
</div>
<h2 id="machine-quantique">Machine Quantique</h2>
<p>Une machine quantique est un modèle de calcul qui utilise les
principes de la mécanique quantique. Elle manipule des qubits, qui
peuvent être dans un état superposé de 0 et 1. Formellement, une machine
quantique peut être définie comme suit :</p>
<div class="definition">
<p><strong>Définition 2</strong>. <em>Une machine quantique <span
class="math inline">\(M\)</span> est un tuple <span
class="math inline">\((Q, q_0, H, U, m)\)</span>, où :</em></p>
<ul>
<li><p><em><span class="math inline">\(Q\)</span> est un ensemble fini
d’états,</em></p></li>
<li><p><em><span class="math inline">\(q_0 \in Q\)</span> est l’état
initial,</em></p></li>
<li><p><em><span class="math inline">\(H \subseteq Q\)</span> est
l’ensemble des états d’acceptation,</em></p></li>
<li><p><em><span class="math inline">\(U\)</span> est une matrice
unitaire qui représente les opérations quantiques,</em></p></li>
<li><p><em><span class="math inline">\(m: Q \rightarrow \{0,
1\}\)</span> est la fonction de mesure.</em></p></li>
</ul>
</div>
<h2 id="classe-bqp">Classe BQP</h2>
<p>La classe BQP est l’ensemble des problèmes de décision qui peuvent
être résolus par une machine quantique en temps polynomial avec une
probabilité d’erreur bornée. Formellement, la classe BQP peut être
définie comme suit :</p>
<div class="definition">
<p><strong>Définition 3</strong>. <em>Un problème de décision <span
class="math inline">\(L\)</span> appartient à la classe BQP si et
seulement s’il existe une machine quantique <span
class="math inline">\(M\)</span> telle que :</em></p>
<ul>
<li><p><em>Pour tout <span class="math inline">\(x \in L\)</span>, la
probabilité que <span class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> est supérieure à <span
class="math inline">\(\frac{2}{3}\)</span>,</em></p></li>
<li><p><em>Pour tout <span class="math inline">\(x \notin L\)</span>, la
probabilité que <span class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> est inférieure à <span
class="math inline">\(\frac{1}{3}\)</span>,</em></p></li>
<li><p><em>Le temps d’exécution de <span
class="math inline">\(M\)</span> est polynomial en la taille de l’entrée
<span class="math inline">\(x\)</span>.</em></p></li>
</ul>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<h2 id="théorème-de-bernstein-vazirani">Théorème de
Bernstein-Vazirani</h2>
<p>Le théorème de Bernstein-Vazirani est un résultat fondamental en
théorie des algorithmes quantiques. Il montre que certaines fonctions
booléennes peuvent être évaluées plus efficacement par une machine
quantique que par un ordinateur classique.</p>
<div class="theorem">
<p><strong>Théorème 1</strong> (Bernstein-Vazirani). <em>Soit <span
class="math inline">\(f: \{0, 1\}^n \rightarrow \{0, 1\}\)</span> une
fonction booléenne définie par <span class="math inline">\(f(x) = x
\cdot s\)</span>, où <span class="math inline">\(s \in \{0,
1\}^n\)</span> est un vecteur secret. Alors, il existe un algorithme
quantique qui évalue <span class="math inline">\(f\)</span> en temps
polynomial avec une probabilité d’erreur bornée.</em></p>
</div>
<h2 id="démonstration-du-théorème-de-bernstein-vazirani">Démonstration
du Théorème de Bernstein-Vazirani</h2>
<p>La démonstration du théorème de Bernstein-Vazirani repose sur
l’utilisation d’une transformation quantique spécifique et d’une mesure
appropriée.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(M\)</span> une
machine quantique qui évalue la fonction <span
class="math inline">\(f\)</span>. L’algorithme de Bernstein-Vazirani
peut être décrit comme suit :</p>
<p>1. Initialisation : Prépare l’état initial <span
class="math inline">\(|0\rangle^{\otimes n}\)</span>.</p>
<p>2. Transformation quantique : Applique une transformation unitaire
<span class="math inline">\(U_f\)</span> telle que : <span
class="math display">\[U_f |x\rangle |y\rangle = |x\rangle |y \oplus
f(x)\rangle\]</span></p>
<p>3. Mesure : Mesure l’état final pour obtenir le vecteur secret <span
class="math inline">\(s\)</span>.</p>
<p>La probabilité d’erreur de cet algorithme est bornée par la
différence entre les probabilités d’acceptation pour <span
class="math inline">\(x \in L\)</span> et <span class="math inline">\(x
\notin L\)</span>. En utilisant les principes de la mécanique quantique,
on peut montrer que cette probabilité est inférieure à <span
class="math inline">\(\frac{1}{3}\)</span> pour les entrées non
valides. ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<h2 id="preuve-de-lappartenance-dun-problème-à-bqp">Preuve de
l’Appartenance d’un Problème à BQP</h2>
<p>Pour montrer qu’un problème de décision <span
class="math inline">\(L\)</span> appartient à la classe BQP, il est
nécessaire de démontrer l’existence d’une machine quantique qui résout
<span class="math inline">\(L\)</span> avec une probabilité d’erreur
bornée en temps polynomial.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(M\)</span> une
machine quantique qui résout le problème <span
class="math inline">\(L\)</span>. Nous devons montrer que :</p>
<p>1. Pour tout <span class="math inline">\(x \in L\)</span>, la
probabilité que <span class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> est supérieure à <span
class="math inline">\(\frac{2}{3}\)</span>.</p>
<p>2. Pour tout <span class="math inline">\(x \notin L\)</span>, la
probabilité que <span class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> est inférieure à <span
class="math inline">\(\frac{1}{3}\)</span>.</p>
<p>3. Le temps d’exécution de <span class="math inline">\(M\)</span> est
polynomial en la taille de l’entrée <span
class="math inline">\(x\)</span>.</p>
<p>En utilisant les principes de la mécanique quantique et les
propriétés des matrices unitaires, on peut démontrer que ces conditions
sont satisfaites pour une machine quantique appropriée. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<h2 id="propriété-de-fermeture-sous-complémentation">Propriété de
Fermeture sous Complémentation</h2>
<p>La classe BQP est fermée sous complémentation, ce qui signifie que si
un problème <span class="math inline">\(L\)</span> appartient à BQP,
alors son complément <span class="math inline">\(\overline{L}\)</span>
appartient également à BQP.</p>
<div class="corollary">
<p><strong>Corollaire 1</strong>. <em>Si <span class="math inline">\(L
\in \text{BQP}\)</span>, alors <span class="math inline">\(\overline{L}
\in \text{BQP}\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(M\)</span> une
machine quantique qui résout le problème <span
class="math inline">\(L\)</span>. Nous pouvons construire une machine
quantique <span class="math inline">\(M&#39;\)</span> qui résout le
problème <span class="math inline">\(\overline{L}\)</span> en inversant
les états d’acceptation et de rejet. La probabilité d’erreur de <span
class="math inline">\(M&#39;\)</span> est bornée par la même constante
que celle de <span class="math inline">\(M\)</span>, et le temps
d’exécution reste polynomial. ◻</p>
</div>
<h2 id="propriété-de-fermeture-sous-union">Propriété de Fermeture sous
Union</h2>
<p>La classe BQP est fermée sous union, ce qui signifie que si deux
problèmes <span class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span> appartiennent à BQP, alors leur union
<span class="math inline">\(L_1 \cup L_2\)</span> appartient également à
BQP.</p>
<div class="corollary">
<p><strong>Corollaire 2</strong>. <em>Si <span
class="math inline">\(L_1, L_2 \in \text{BQP}\)</span>, alors <span
class="math inline">\(L_1 \cup L_2 \in \text{BQP}\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Soient <span class="math inline">\(M_1\)</span> et
<span class="math inline">\(M_2\)</span> des machines quantiques qui
résolvent les problèmes <span class="math inline">\(L_1\)</span> et
<span class="math inline">\(L_2\)</span>, respectivement. Nous pouvons
construire une machine quantique <span class="math inline">\(M\)</span>
qui résout le problème <span class="math inline">\(L_1 \cup L_2\)</span>
en exécutant <span class="math inline">\(M_1\)</span> et <span
class="math inline">\(M_2\)</span> en parallèle et en acceptant si au
moins l’une des machines accepte. La probabilité d’erreur de <span
class="math inline">\(M\)</span> est bornée par la somme des
probabilités d’erreur de <span class="math inline">\(M_1\)</span> et
<span class="math inline">\(M_2\)</span>, et le temps d’exécution reste
polynomial. ◻</p>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>L’étude de la complexité des problèmes dans la classe BQP offre des
perspectives fascinantes pour le développement des ordinateurs
quantiques et l’optimisation des algorithmes. Les résultats présentés
dans cet article montrent que certains problèmes peuvent être résolus
plus efficacement par des machines quantiques que par des ordinateurs
classiques, ouvrant ainsi la voie à de nouvelles avancées technologiques
et scientifiques.</p>
</body>
</html>
{% include "footer.html" %}

