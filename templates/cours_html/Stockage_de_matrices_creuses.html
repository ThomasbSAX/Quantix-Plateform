{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Stockage de matrices creuses : Optimisation et Applications</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Stockage de matrices creuses : Optimisation et
Applications</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>Les matrices creuses, c’est-à-dire celles dont une grande partie des
éléments sont nuls, apparaissent naturellement dans de nombreuses
applications scientifiques et industrielles. Que ce soit en traitement
du signal, en analyse numérique, ou en intelligence artificielle, ces
matrices sont omniprésentes. Leur traitement efficace est crucial pour
la performance des algorithmes.</p>
<p>L’idée de stocker uniquement les éléments non nuls permet
d’économiser de la mémoire et d’accélérer les calculs. Cependant, cette
approche soulève des défis algorithmiques et structurels. Dans cet
article, nous explorons les différentes méthodes de stockage des
matrices creuses, leurs avantages et inconvénients, ainsi que leurs
applications pratiques.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre le stockage des matrices creuses, commençons par
définir ce qu’est une matrice creuse. Intuitivement, une matrice est
dite creuse si elle contient beaucoup de zéros. Mais comment quantifier
cela ?</p>
<p>Une matrice <span class="math inline">\(A\)</span> de taille <span
class="math inline">\(m \times n\)</span> est dite creuse si le nombre
d’éléments non nuls est significativement inférieur au nombre total
d’éléments <span class="math inline">\(m \times n\)</span>.
Formellement, on peut dire que :</p>
<div class="definition">
<p>Une matrice <span class="math inline">\(A\)</span> de taille <span
class="math inline">\(m \times n\)</span> est creuse si et seulement si
il existe un nombre <span class="math inline">\(k\)</span> tel que :
<span class="math display">\[k &lt; m \times n \quad \text{et} \quad
\forall i, j, A_{i,j} = 0 \text{ pour } k \text{ indices } (i,
j).\]</span></p>
</div>
<p>Une autre manière de formuler cette définition est en utilisant la
notion de densité :</p>
<div class="definition">
<p>La densité <span class="math inline">\(\rho\)</span> d’une matrice
creuse est définie comme : <span class="math display">\[\rho =
\frac{\text{nombre d&#39;éléments non nuls}}{m \times n}.\]</span> Une
matrice est dite creuse si <span class="math inline">\(\rho \ll
1\)</span>.</p>
</div>
<h1 id="méthodes-de-stockage">Méthodes de Stockage</h1>
<p>Plusieurs méthodes existent pour stocker efficacement les matrices
creuses. Nous en présentons quelques-unes ici.</p>
<h2 id="format-coo-coordinate-format">Format COO (Coordinate
Format)</h2>
<p>Le format COO est l’un des plus simples pour stocker une matrice
creuse. Il consiste à stocker les indices et les valeurs des éléments
non nuls.</p>
<div class="definition">
<p>Soit <span class="math inline">\(A\)</span> une matrice creuse de
taille <span class="math inline">\(m \times n\)</span>. Le format COO
stocke trois tableaux :</p>
<ul>
<li><p><span class="math inline">\(\text{row}\)</span> : tableau de
taille <span class="math inline">\(k\)</span> contenant les indices de
ligne des éléments non nuls.</p></li>
<li><p><span class="math inline">\(\text{col}\)</span> : tableau de
taille <span class="math inline">\(k\)</span> contenant les indices de
colonne des éléments non nuls.</p></li>
<li><p><span class="math inline">\(\text{val}\)</span> : tableau de
taille <span class="math inline">\(k\)</span> contenant les valeurs des
éléments non nuls.</p></li>
</ul>
</div>
<h2 id="format-csr-compressed-sparse-row">Format CSR (Compressed Sparse
Row)</h2>
<p>Le format CSR est une variante du COO qui utilise des tableaux
compressés pour stocker les indices de ligne.</p>
<div class="definition">
<p>Soit <span class="math inline">\(A\)</span> une matrice creuse de
taille <span class="math inline">\(m \times n\)</span>. Le format CSR
stocke quatre tableaux :</p>
<ul>
<li><p><span class="math inline">\(\text{val}\)</span> : tableau de
taille <span class="math inline">\(k\)</span> contenant les valeurs des
éléments non nuls.</p></li>
<li><p><span class="math inline">\(\text{col\_index}\)</span> : tableau
de taille <span class="math inline">\(k\)</span> contenant les indices
de colonne des éléments non nuls.</p></li>
<li><p><span class="math inline">\(\text{row\_ptr}\)</span> : tableau de
taille <span class="math inline">\(m + 1\)</span> où <span
class="math inline">\(\text{row\_ptr}[i]\)</span> contient l’indice de
début des éléments non nuls de la ligne <span
class="math inline">\(i\)</span>.</p></li>
</ul>
</div>
<h1 id="théorèmes-et-propriétés">Théorèmes et Propriétés</h1>
<p>Dans cette section, nous présentons quelques théorèmes et propriétés
liés au stockage des matrices creuses.</p>
<h2 id="théorème-de-compression">Théorème de Compression</h2>
<p>Le théorème suivant montre que le stockage des matrices creuses peut
être optimisé en utilisant des techniques de compression.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(A\)</span> une matrice creuse de
taille <span class="math inline">\(m \times n\)</span> avec <span
class="math inline">\(k\)</span> éléments non nuls. Il existe une
méthode de stockage qui utilise au plus <span class="math inline">\(O(k
+ m + n)\)</span> espace mémoire.</p>
</div>
<div class="proof">
<p><em>Proof.</em> La preuve de ce théorème repose sur l’utilisation des
formats COO ou CSR. En effet, ces formats stockent uniquement les
éléments non nuls et leurs indices, ce qui permet d’économiser de la
mémoire. Le nombre total d’éléments stockés est <span
class="math inline">\(k\)</span> pour les valeurs et <span
class="math inline">\(2k\)</span> pour les indices, ce qui donne un
total de <span class="math inline">\(O(k + m + n)\)</span>. ◻</p>
</div>
<h1 id="applications">Applications</h1>
<p>Les matrices creuses sont utilisées dans de nombreuses applications,
notamment en analyse numérique et en traitement du signal. Voici
quelques exemples :</p>
<h2 id="résolution-de-systèmes-linéaires">Résolution de Systèmes
Linéaires</h2>
<p>Les systèmes linéaires creux apparaissent souvent dans les
simulations numériques. Les méthodes itératives comme la méthode de
Jacobi ou Gauss-Seidel sont particulièrement efficaces pour résoudre ces
systèmes.</p>
<h2 id="graphes-et-réseaux">Graphes et Réseaux</h2>
<p>Les matrices d’adjacence des graphes sont souvent creuses. Le
stockage efficace de ces matrices permet d’optimiser les algorithmes de
recherche de chemins ou de détection de communautés.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Dans cet article, nous avons exploré les différentes méthodes de
stockage des matrices creuses. Nous avons vu que ces méthodes permettent
d’économiser de la mémoire et d’accélérer les calculs. Les applications
des matrices creuses sont nombreuses et variées, allant de l’analyse
numérique au traitement du signal en passant par les réseaux.</p>
<p>Les défis futurs incluent le développement de nouvelles méthodes de
stockage et d’algorithmes optimisés pour les matrices creuses. Les
avancées dans ce domaine seront cruciales pour les applications
scientifiques et industrielles de demain.</p>
</body>
</html>
{% include "footer.html" %}

