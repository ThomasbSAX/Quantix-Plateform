{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes dans la classe BPP</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes dans la classe BPP</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>L’étude de la complexité des problèmes est un pilier fondamental de
l’informatique théorique. Parmi les classes de complexité, la classe BPP
(Bounded-error Probabilistic Polynomial time) occupe une place
particulière. Introduite dans les années 1980, cette classe regroupe les
problèmes qui peuvent être résolus par des algorithmes probabilistes en
temps polynomial avec une erreur bornée.</p>
<p>L’émergence de la classe BPP est motivée par le besoin de modéliser
des algorithmes qui utilisent le hasard pour résoudre des problèmes
difficiles. Ces algorithmes sont particulièrement intéressants car ils
peuvent souvent être implémentés de manière efficace et parallélisable.
La classe BPP est indispensable pour comprendre les limites des
algorithmes probabilistes et pour comparer leur puissance avec celle des
algorithmes déterministes.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre la classe BPP, il est essentiel de définir d’abord
les concepts de base.</p>
<h2 id="algorithmes-probabilistes">Algorithmes Probabilistes</h2>
<p>Un algorithme probabiliste est un algorithme qui utilise des bits
aléatoires pour prendre des décisions. Formellement, un algorithme
probabiliste <span class="math inline">\(A\)</span> peut être vu comme
une fonction <span class="math inline">\(A: \{0,1\}^* \times \{0,1\}^*
\rightarrow \{0,1\}\)</span>, où le premier argument est l’entrée du
problème et le second est une séquence de bits aléatoires.</p>
<h2 id="classe-bpp">Classe BPP</h2>
<p>Nous cherchons à définir une classe de problèmes qui peuvent être
résolus par des algorithmes probabilistes en temps polynomial avec une
erreur bornée. Pour cela, nous devons formaliser ce que signifie "en
temps polynomial" et "avec une erreur bornée".</p>
<div class="definition">
<p>Soit <span class="math inline">\(L\)</span> un langage. On dit que
<span class="math inline">\(L \in BPP\)</span> s’il existe une machine
de Turing probabiliste <span class="math inline">\(M\)</span>, des
fonctions polynomiales <span class="math inline">\(p, q: \mathbb{N}
\rightarrow \mathbb{N}\)</span>, et une constante <span
class="math inline">\(0 &lt; c &lt; \frac{1}{2}\)</span> tels que pour
tout <span class="math inline">\(x \in \{0,1\}^*\)</span>, on a: <span
class="math display">\[\begin{aligned}
&amp;\text{Si } x \in L, \text{ alors } \Pr[M(x) = 1] \geq 1 - c, \\
&amp;\text{Si } x \notin L, \text{ alors } \Pr[M(x) = 1] \leq c,
\end{aligned}\]</span> où <span class="math inline">\(M\)</span>
s’exécute en temps <span class="math inline">\(O(p(|x|))\)</span> et
utilise au plus <span class="math inline">\(q(|x|)\)</span> bits
aléatoires.</p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<h2 id="théorème-de-la-classe-bpp">Théorème de la Classe BPP</h2>
<p>Nous cherchons à établir un théorème fondamental concernant la classe
BPP. Ce théorème montre que les problèmes dans BPP peuvent être résolus
par des algorithmes probabilistes en temps polynomial avec une erreur
bornée.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(L\)</span> un langage. Si <span
class="math inline">\(L \in BPP\)</span>, alors il existe une machine de
Turing probabiliste <span class="math inline">\(M\)</span> qui résout
<span class="math inline">\(L\)</span> en temps polynomial avec une
erreur bornée.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Supposons que <span class="math inline">\(L \in
BPP\)</span>. Par définition, il existe une machine de Turing
probabiliste <span class="math inline">\(M&#39;\)</span>, des fonctions
polynomiales <span class="math inline">\(p, q: \mathbb{N} \rightarrow
\mathbb{N}\)</span>, et une constante <span class="math inline">\(0 &lt;
c &lt; \frac{1}{2}\)</span> tels que pour tout <span
class="math inline">\(x \in \{0,1\}^*\)</span>, on a: <span
class="math display">\[\begin{aligned}
&amp;\text{Si } x \in L, \text{ alors } \Pr[M&#39;(x) = 1] \geq 1 - c,
\\
&amp;\text{Si } x \notin L, \text{ alors } \Pr[M&#39;(x) = 1] \leq c.
\end{aligned}\]</span> Nous pouvons construire une nouvelle machine de
Turing probabiliste <span class="math inline">\(M\)</span> qui exécute
<span class="math inline">\(M&#39;\)</span> un nombre polynomial de fois
et prend la majorité des résultats. Plus précisément, pour une entrée
<span class="math inline">\(x\)</span>, <span
class="math inline">\(M\)</span> exécute <span
class="math inline">\(M&#39;\)</span> <span
class="math inline">\(t(|x|)\)</span> fois, où <span
class="math inline">\(t\)</span> est une fonction polynomiale. Si la
majorité des résultats est 1, alors <span
class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span>, sinon elle rejette.</p>
<p>Par le lemme de la majorité, nous savons que: <span
class="math display">\[\Pr[M(x) = 1] \geq 1 - c^t(|x|).\]</span> En
choisissant <span class="math inline">\(t(|x|)\)</span> suffisamment
grand, nous pouvons rendre <span class="math inline">\(c^t(|x|)\)</span>
aussi petit que souhaité. Ainsi, <span class="math inline">\(M\)</span>
résout <span class="math inline">\(L\)</span> en temps polynomial avec
une erreur bornée. ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<h2 id="preuve-du-théorème-de-la-classe-bpp">Preuve du Théorème de la
Classe BPP</h2>
<p>Nous avons déjà fourni une preuve du théorème de la classe BPP dans
la section précédente. Cependant, il est utile de détailler davantage
certaines étapes.</p>
<div class="proof">
<p><em>Proof.</em> Supposons que <span class="math inline">\(L \in
BPP\)</span>. Par définition, il existe une machine de Turing
probabiliste <span class="math inline">\(M&#39;\)</span>, des fonctions
polynomiales <span class="math inline">\(p, q: \mathbb{N} \rightarrow
\mathbb{N}\)</span>, et une constante <span class="math inline">\(0 &lt;
c &lt; \frac{1}{2}\)</span> tels que pour tout <span
class="math inline">\(x \in \{0,1\}^*\)</span>, on a: <span
class="math display">\[\begin{aligned}
&amp;\text{Si } x \in L, \text{ alors } \Pr[M&#39;(x) = 1] \geq 1 - c,
\\
&amp;\text{Si } x \notin L, \text{ alors } \Pr[M&#39;(x) = 1] \leq c.
\end{aligned}\]</span> Nous construisons une nouvelle machine de Turing
probabiliste <span class="math inline">\(M\)</span> qui exécute <span
class="math inline">\(M&#39;\)</span> un nombre polynomial de fois et
prend la majorité des résultats. Plus précisément, pour une entrée <span
class="math inline">\(x\)</span>, <span class="math inline">\(M\)</span>
exécute <span class="math inline">\(M&#39;\)</span> <span
class="math inline">\(t(|x|)\)</span> fois, où <span
class="math inline">\(t\)</span> est une fonction polynomiale. Si la
majorité des résultats est 1, alors <span
class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span>, sinon elle rejette.</p>
<p>Par le lemme de la majorité, nous savons que: <span
class="math display">\[\Pr[M(x) = 1] \geq 1 - c^t(|x|).\]</span> En
choisissant <span class="math inline">\(t(|x|) = \lceil \log_{1/c}
\epsilon^{-1} \rceil\)</span>, où <span
class="math inline">\(\epsilon\)</span> est une constante positive
arbitrairement petite, nous pouvons rendre <span
class="math inline">\(c^t(|x|) \leq \epsilon\)</span>. Ainsi, <span
class="math inline">\(M\)</span> résout <span
class="math inline">\(L\)</span> en temps polynomial avec une erreur
bornée. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<h2 id="propriété-1-fermeture-sous-complémentation">Propriété 1:
Fermeture sous Complémentation</h2>
<ul>
<li><p>Si <span class="math inline">\(L \in BPP\)</span>, alors <span
class="math inline">\(\overline{L} \in BPP\)</span>.</p></li>
</ul>
<div class="proof">
<p><em>Proof.</em> Supposons que <span class="math inline">\(L \in
BPP\)</span>. Par définition, il existe une machine de Turing
probabiliste <span class="math inline">\(M\)</span> qui résout <span
class="math inline">\(L\)</span> en temps polynomial avec une erreur
bornée. Nous pouvons construire une nouvelle machine de Turing
probabiliste <span class="math inline">\(M&#39;\)</span> qui exécute
<span class="math inline">\(M\)</span> et renvoie le complément du
résultat. Plus précisément, pour une entrée <span
class="math inline">\(x\)</span>, <span
class="math inline">\(M&#39;\)</span> exécute <span
class="math inline">\(M(x)\)</span> et renvoie 0 si <span
class="math inline">\(M(x) = 1\)</span>, et 1 si <span
class="math inline">\(M(x) = 0\)</span>.</p>
<p>Par la définition de BPP, nous savons que: <span
class="math display">\[\begin{aligned}
&amp;\text{Si } x \in L, \text{ alors } \Pr[M(x) = 1] \geq 1 - c, \\
&amp;\text{Si } x \notin L, \text{ alors } \Pr[M(x) = 1] \leq c.
\end{aligned}\]</span> Ainsi, pour <span
class="math inline">\(M&#39;\)</span>, nous avons: <span
class="math display">\[\begin{aligned}
&amp;\text{Si } x \in \overline{L}, \text{ alors } \Pr[M&#39;(x) = 1]
\geq 1 - c, \\
&amp;\text{Si } x \notin \overline{L}, \text{ alors } \Pr[M&#39;(x) = 1]
\leq c.
\end{aligned}\]</span> Donc, <span class="math inline">\(\overline{L}
\in BPP\)</span>. ◻</p>
</div>
<h2 id="propriété-2-fermeture-sous-union-et-intersection">Propriété 2:
Fermeture sous Union et Intersection</h2>
<ul>
<li><p>Si <span class="math inline">\(L_1, L_2 \in BPP\)</span>, alors
<span class="math inline">\(L_1 \cup L_2 \in BPP\)</span>.</p></li>
<li><p>Si <span class="math inline">\(L_1, L_2 \in BPP\)</span>, alors
<span class="math inline">\(L_1 \cap L_2 \in BPP\)</span>.</p></li>
</ul>
<div class="proof">
<p><em>Proof.</em> Supposons que <span class="math inline">\(L_1, L_2
\in BPP\)</span>. Par définition, il existe des machines de Turing
probabilistes <span class="math inline">\(M_1\)</span> et <span
class="math inline">\(M_2\)</span> qui résolvent <span
class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span> respectivement en temps polynomial
avec une erreur bornée.</p>
<p>Pour montrer que <span class="math inline">\(L_1 \cup L_2 \in
BPP\)</span>, nous construisons une nouvelle machine de Turing
probabiliste <span class="math inline">\(M\)</span> qui exécute <span
class="math inline">\(M_1\)</span> et <span
class="math inline">\(M_2\)</span> en parallèle. Si au moins l’une des
machines accepte, alors <span class="math inline">\(M\)</span> accepte;
sinon, elle rejette.</p>
<p>Par la définition de BPP, nous savons que: <span
class="math display">\[\begin{aligned}
&amp;\text{Si } x \in L_1, \text{ alors } \Pr[M_1(x) = 1] \geq 1 - c, \\
&amp;\text{Si } x \notin L_1, \text{ alors } \Pr[M_1(x) = 1] \leq c, \\
&amp;\text{Si } x \in L_2, \text{ alors } \Pr[M_2(x) = 1] \geq 1 - c, \\
&amp;\text{Si } x \notin L_2, \text{ alors } \Pr[M_2(x) = 1] \leq c.
\end{aligned}\]</span> Ainsi, pour <span
class="math inline">\(M\)</span>, nous avons: <span
class="math display">\[\begin{aligned}
&amp;\text{Si } x \in L_1 \cup L_2, \text{ alors } \Pr[M(x) = 1] \geq 1
- c^2, \\
&amp;\text{Si } x \notin L_1 \cup L_2, \text{ alors } \Pr[M(x) = 1] \leq
c^2.
\end{aligned}\]</span> Donc, <span class="math inline">\(L_1 \cup L_2
\in BPP\)</span>.</p>
<p>De manière similaire, pour montrer que <span
class="math inline">\(L_1 \cap L_2 \in BPP\)</span>, nous construisons
une nouvelle machine de Turing probabiliste <span
class="math inline">\(M&#39;\)</span> qui exécute <span
class="math inline">\(M_1\)</span> et <span
class="math inline">\(M_2\)</span> en parallèle. Si les deux machines
acceptent, alors <span class="math inline">\(M&#39;\)</span> accepte;
sinon, elle rejette.</p>
<p>Par la définition de BPP, nous savons que: <span
class="math display">\[\begin{aligned}
&amp;\text{Si } x \in L_1, \text{ alors } \Pr[M_1(x) = 1] \geq 1 - c, \\
&amp;\text{Si } x \notin L_1, \text{ alors } \Pr[M_1(x) = 1] \leq c, \\
&amp;\text{Si } x \in L_2, \text{ alors } \Pr[M_2(x) = 1] \geq 1 - c, \\
&amp;\text{Si } x \notin L_2, \text{ alors } \Pr[M_2(x) = 1] \leq c.
\end{aligned}\]</span> Ainsi, pour <span
class="math inline">\(M&#39;\)</span>, nous avons: <span
class="math display">\[\begin{aligned}
&amp;\text{Si } x \in L_1 \cap L_2, \text{ alors } \Pr[M&#39;(x) = 1]
\geq (1 - c)^2, \\
&amp;\text{Si } x \notin L_1 \cap L_2, \text{ alors } \Pr[M&#39;(x) = 1]
\leq c^2.
\end{aligned}\]</span> Donc, <span class="math inline">\(L_1 \cap L_2
\in BPP\)</span>. ◻</p>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>La classe BPP est une classe de complexité fondamentale qui modélise
les problèmes pouvant être résolus par des algorithmes probabilistes en
temps polynomial avec une erreur bornée. Nous avons exploré les
définitions, théorèmes, preuves et propriétés de cette classe. Les
résultats présentés montrent la puissance et l’utilité des algorithmes
probabilistes dans le domaine de la complexité computationnelle.</p>
</body>
</html>
{% include "footer.html" %}

