{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Thinning : Une Technique Fondamentale en Traitement d’Images et Analyse Stochastique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Thinning : Une Technique Fondamentale en Traitement
d’Images et Analyse Stochastique</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>Le thinning, ou amincissement en français, est une technique
essentielle dans le domaine du traitement d’images et de l’analyse
stochastique. Cette méthode permet de réduire la largeur des objets dans
une image binaire tout en préservant leur forme et leur connectivité.
L’origine du thinning remonte aux années 1960, où il a été introduit
pour simplifier les structures complexes dans les images médicales.
Depuis lors, cette technique a trouvé des applications dans divers
domaines tels que la reconnaissance de caractères, l’analyse de
documents, et même en biologie pour l’étude des réseaux neuronaux.</p>
<p>Le thinning est indispensable car il permet de représenter les objets
sous une forme simplifiée, facilitant ainsi leur analyse et leur
interprétation. Par exemple, dans le cas de l’analyse de documents
anciens, le thinning permet de séparer les caractères manuscrits qui se
touchent, rendant ainsi leur reconnaissance plus précise.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour comprendre le thinning, il est crucial de définir quelques
concepts préliminaires.</p>
<div class="definition">
<p>Une image binaire est une fonction <span class="math inline">\(f:
\mathbb{Z}^2 \rightarrow \{0,1\}\)</span> où chaque pixel est soit noir
(1), soit blanc (0). On peut la représenter comme un ensemble de points
<span class="math inline">\(S \subseteq \mathbb{Z}^2\)</span> où <span
class="math inline">\(f(x,y) = 1\)</span>.</p>
</div>
<div class="definition">
<p>Le voisinage de Moore d’un pixel <span class="math inline">\(p =
(x,y)\)</span> est l’ensemble des pixels adjacents, y compris les
diagonaux : <span class="math display">\[N_M(p) = \{(x+i,y+j) \mid i,j
\in \{-1,0,1\}\} \setminus \{p\}\]</span></p>
</div>
<div class="definition">
<p>Un point <span class="math inline">\(p \in S\)</span> est un point de
bord si au moins l’un de ses voisins dans <span
class="math inline">\(N_M(p)\)</span> n’appartient pas à <span
class="math inline">\(S\)</span>.</p>
</div>
<div class="definition">
<p>Le thinning est une transformation qui supprime itérativement les
points de bord d’un ensemble <span class="math inline">\(S\)</span> tout
en préservant la connectivité et la forme globale de l’objet.
Formellement, un algorithme de thinning est une suite d’opérations <span
class="math inline">\(T_1, T_2, \ldots\)</span> telles que : <span
class="math display">\[S_{n+1} = T_n(S_n)\]</span> où <span
class="math inline">\(T_n\)</span> est une opération de suppression de
points de bord.</p>
</div>
<h1 class="unnumbered" id="théorèmes-et-propriétés">Théorèmes et
Propriétés</h1>
<p>Plusieurs théorèmes fondamentaux régissent le comportement du
thinning. Nous en présentons quelques-uns ici.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(S\)</span> un ensemble connexe et
<span class="math inline">\(T\)</span> une opération de thinning. Si
<span class="math inline">\(T\)</span> est appliqué à <span
class="math inline">\(S\)</span>, alors l’ensemble résultant <span
class="math inline">\(T(S)\)</span> reste connexe.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Pour prouver ce théorème, nous devons montrer que
pour tout point <span class="math inline">\(p \in T(S)\)</span>, il
existe un chemin dans <span class="math inline">\(T(S)\)</span> reliant
<span class="math inline">\(p\)</span> à tout autre point de <span
class="math inline">\(T(S)\)</span>. Supposons par l’absurde qu’il
existe un point <span class="math inline">\(p \in T(S)\)</span> qui
n’est pas connecté à un autre point <span class="math inline">\(q \in
T(S)\)</span>. Cela impliquerait que <span
class="math inline">\(p\)</span> était un point de bord isolé, ce qui
contredit la définition du thinning qui préserve la connectivité. ◻</p>
</div>
<div class="theorem">
<p>Soit <span class="math inline">\(S\)</span> un ensemble fini de
points. Le processus de thinning se termine après un nombre fini
d’itérations.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Puisque <span class="math inline">\(S\)</span> est
fini, chaque itération de thinning supprime au moins un point. Par
conséquent, le processus doit se terminer lorsque plus aucun point ne
peut être supprimé. ◻</p>
</div>
<h1 class="unnumbered" id="algorithmes-de-thinning">Algorithmes de
Thinning</h1>
<p>Plusieurs algorithmes ont été développés pour effectuer le thinning.
Nous présentons ici l’algorithme de Zhang-Suen, qui est l’un des plus
populaires.</p>
<div class="algorithm">
<p>L’algorithme de Zhang-Suen est une méthode itérative qui supprime les
points de bord en deux sous-itérations. Les conditions pour supprimer un
point <span class="math inline">\(p\)</span> sont les suivantes :</p>
<ol>
<li><p><span class="math inline">\(2 \leq B(p) \leq 6\)</span></p></li>
<li><p><span class="math inline">\(A(p) = 1\)</span></p></li>
<li><p><span class="math inline">\(p_2 \cdot p_4 \cdot p_6 =
0\)</span></p></li>
<li><p><span class="math inline">\(p_4 \cdot p_6 \cdot p_8 =
0\)</span></p></li>
</ol>
<p>où <span class="math inline">\(B(p)\)</span> est le nombre de voisins
de <span class="math inline">\(p\)</span> dans <span
class="math inline">\(N_M(p)\)</span> qui appartiennent à <span
class="math inline">\(S\)</span>, et <span
class="math inline">\(A(p)\)</span> est le nombre de transitions 0-1
dans la séquence des voisins de <span class="math inline">\(p\)</span>
parcourue dans le sens horaire.</p>
</div>
<h1 class="unnumbered" id="applications">Applications</h1>
<p>Le thinning trouve des applications dans divers domaines :</p>
<ul>
<li><p><strong>Reconnaissance de Caractères</strong> : Le thinning
permet de séparer les caractères manuscrits qui se touchent, facilitant
ainsi leur reconnaissance.</p></li>
<li><p><strong>Analyse de Documents</strong> : En réduisant la largeur
des traits, le thinning permet une meilleure extraction des
caractéristiques des documents anciens.</p></li>
<li><p><strong>Biologie</strong> : Le thinning est utilisé pour analyser
les réseaux neuronaux et les structures biologiques complexes.</p></li>
</ul>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>Le thinning est une technique puissante et polyvalente qui joue un
rôle crucial dans le traitement d’images et l’analyse stochastique. Son
importance réside dans sa capacité à simplifier les structures complexes
tout en préservant leur forme et leur connectivité. Les algorithmes de
thinning, tels que celui de Zhang-Suen, continuent d’être améliorés et
adaptés à de nouvelles applications, faisant du thinning une méthode
indispensable dans de nombreux domaines scientifiques et
industriels.</p>
</body>
</html>
{% include "footer.html" %}

