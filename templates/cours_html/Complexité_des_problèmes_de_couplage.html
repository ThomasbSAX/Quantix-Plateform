{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de couplage</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de couplage</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>Les problèmes de couplage constituent une classe fondamentale en
théorie des graphes et en informatique théorique. Leur étude trouve ses
racines dans les travaux de König (1931) et Hall (1935), qui ont posé
les bases de la théorie des couplages. Ces problèmes émergent
naturellement dans diverses applications pratiques, telles que
l’appariement d’étudiants à des logements, la planification de tournées,
ou encore l’optimisation de réseaux. Leur importance réside dans leur
capacité à modéliser des situations où l’on cherche à établir des
correspondances optimales entre ensembles d’éléments, sous
contraintes.</p>
<p>Les problèmes de couplage sont indispensables dans le cadre de
l’optimisation combinatoire, où ils servent souvent de briques
élémentaires pour la construction d’algorithmes plus complexes. Leur
étude permet non seulement de comprendre les limites computationnelles
des algorithmes, mais aussi d’explorer des méthodes efficaces pour
résoudre des problèmes NP-difficiles.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour introduire la notion de couplage, considérons un graphe <span
class="math inline">\(G = (V, E)\)</span>. Nous cherchons à sélectionner
des arêtes de manière à ce qu’aucune paire d’arêtes ne partage un sommet
commun. Cette idée intuitive nous mène à la définition formelle suivante
:</p>
<div class="definition">
<p>Un <strong>couplage</strong> dans un graphe <span
class="math inline">\(G = (V, E)\)</span> est un ensemble d’arêtes <span
class="math inline">\(M \subseteq E\)</span> tel que : <span
class="math display">\[\forall e_1, e_2 \in M, e_1 \cap e_2 =
\emptyset.\]</span> En d’autres termes, un couplage est une famille
d’arêtes deux à deux disjointes.</p>
</div>
<p>Un couplage maximal est un couplage auquel on ne peut ajouter aucune
autre arête sans violer la condition de disjointement. Un couplage
parfait est un couplage qui couvre tous les sommets du graphe,
c’est-à-dire que chaque sommet appartient à une arête du couplage.</p>
<div class="definition">
<p>Un couplage <span class="math inline">\(M\)</span> est dit
<strong>maximal</strong> si : <span class="math display">\[\nexists e
\in E \setminus M \text{ tel que } M \cup \{e\} \text{ soit un
couplage.}\]</span></p>
</div>
<div class="definition">
<p>Un couplage <span class="math inline">\(M\)</span> est dit
<strong>parfait</strong> si : <span class="math display">\[\forall v \in
V, \exists e \in M \text{ tel que } v \in e.\]</span></p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<p>Un des théorèmes fondamentaux concernant les couplages est le
théorème de König, qui établit une relation entre les couplages et les
recouvrements de sommets dans les graphes bipartiés.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(G = (V, E)\)</span> un graphe
biparti. Alors le nombre maximal de couplages dans <span
class="math inline">\(G\)</span> est égal au nombre minimal de sommets
nécessaires pour recouvrir toutes les arêtes de <span
class="math inline">\(G\)</span>. Formellement, si <span
class="math inline">\(\nu(G)\)</span> désigne la taille du couplage
maximal et <span class="math inline">\(\tau(G)\)</span> la taille du
recouvrement minimal de sommets, alors : <span
class="math display">\[\nu(G) = \tau(G).\]</span></p>
</div>
<p>La démonstration de ce théorème repose sur des techniques
d’optimisation combinatoire et utilise le théorème du double comptage de
Hall.</p>
<h1 id="preuves">Preuves</h1>
<p>Pour démontrer le théorème de König, nous procédons par double
comptage. Considérons un graphe biparti <span class="math inline">\(G =
(V, E)\)</span> avec une partition <span class="math inline">\(V = A
\cup B\)</span>. Nous cherchons à montrer que le nombre maximal de
couplages est égal au nombre minimal de sommets nécessaires pour
recouvrir toutes les arêtes.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(M\)</span> un
couplage maximal dans <span class="math inline">\(G\)</span>. Nous
construisons un recouvrement de sommets en sélectionnant tous les
sommets non couverts par <span class="math inline">\(M\)</span> dans
<span class="math inline">\(A\)</span> et tous les sommets de <span
class="math inline">\(B\)</span>. Ce recouvrement couvre toutes les
arêtes, car toute arête non dans <span class="math inline">\(M\)</span>
doit avoir au moins un sommet non couvert par <span
class="math inline">\(M\)</span>.</p>
<p>Réciproquement, soit <span class="math inline">\(S\)</span> un
recouvrement minimal de sommets. Nous construisons un couplage en
sélectionnant les arêtes qui relient <span
class="math inline">\(A\)</span> à <span
class="math inline">\(B\)</span> sans utiliser deux fois le même sommet.
Ce couplage est maximal car tout ajout d’une arête violerait la
condition de recouvrement minimal.</p>
<p>Ainsi, nous avons : <span class="math display">\[\nu(G) =
\tau(G).\]</span> ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Nous énumérons quelques propriétés importantes des couplages :</p>
<ol>
<li><p>Tout graphe possède un couplage maximal.</p>
<div class="proof">
<p><em>Proof.</em> Nous pouvons construire un couplage maximal en
ajoutant des arêtes une par une, tant que cela ne viole pas la condition
de disjointement. Ce processus doit se terminer car le graphe est
fini. ◻</p>
</div></li>
<li><p>Un couplage parfait existe si et seulement si le graphe est de
degré pair.</p>
<div class="proof">
<p><em>Proof.</em> Si un couplage parfait existe, alors chaque sommet a
exactement une arête incidente dans le couplage, ce qui implique que
tous les sommets ont un degré pair. Réciproquement, si le graphe est de
degré pair, nous pouvons construire un couplage parfait en utilisant
l’algorithme d’Euler. ◻</p>
</div></li>
<li><p>Le problème de décision de l’existence d’un couplage parfait est
dans la classe P.</p>
<div class="proof">
<p><em>Proof.</em> Nous pouvons vérifier l’existence d’un couplage
parfait en utilisant un algorithme de recherche en largeur ou
profondeur, qui fonctionne en temps polynomial. ◻</p>
</div></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>Les problèmes de couplage occupent une place centrale en théorie des
graphes et en informatique théorique. Leur étude permet de comprendre
les limites computationnelles des algorithmes et d’explorer des méthodes
efficaces pour résoudre des problèmes complexes. Les théorèmes de König
et Hall fournissent des outils puissants pour l’analyse des couplages,
tandis que les propriétés et corollaires énumérés offrent des insights
précieux pour leur application pratique.</p>
</body>
</html>
{% include "footer.html" %}

