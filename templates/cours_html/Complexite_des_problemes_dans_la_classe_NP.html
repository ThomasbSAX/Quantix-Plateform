{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes dans la classe NP</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes dans la classe NP</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>L’étude de la complexité des problèmes dans la classe NP est un
pilier fondamental de l’informatique théorique. Cette notion émerge dans
les années 1970 avec les travaux de Stephen Cook et Leonid Levin, qui
introduisent respectivement le problème du satisfiabilité booléenne
(SAT) et les fonctions universelles. La classe NP, pour
"Non-détérministique Polynomial", regroupe les problèmes pour lesquels
une solution proposée peut être vérifiée rapidement, mais dont la
recherche de la solution optimale reste un défi.</p>
<p>Pourquoi cette notion est-elle indispensable ? Parce qu’elle permet
de classifier les problèmes en fonction de leur difficulté
algorithmique. Un problème est dit NP-complet s’il est au moins aussi
difficile que le plus dur des problèmes dans NP. La question centrale,
connue sous le nom de problème P=NP, demande si tous les problèmes dont
la solution peut être vérifiée rapidement peuvent aussi être résolus
rapidement. Cette question, non résolue à ce jour, est l’une des sept
problèmes du prix du millénaire de l’Institut de mathématiques Clay.</p>
<h1 id="définitions">Définitions</h1>
<p>Commençons par comprendre ce que nous cherchons à capturer. Imaginez
un problème où vous devez trouver une configuration spécifique parmi un
ensemble potentiellement immense de configurations. Supposons que
quelqu’un vous propose une solution et que vous puissiez vérifier
rapidement si cette solution est correcte. La classe NP capture
précisément cette idée : les problèmes pour lesquels une solution peut
être vérifiée rapidement.</p>
<p>Formellement, un problème de décision est dans la classe NP s’il
existe une machine de Turing non déterministique qui peut le résoudre en
temps polynomial. Plus précisément, un problème <span
class="math inline">\(L\)</span> est dans NP si et seulement s’il existe
une relation <span class="math inline">\(R_L\)</span> et une fonction
polynomiale <span class="math inline">\(p\)</span> telles que :</p>
<p><span class="math display">\[x \in L \iff \exists y \text{ tel que }
|y| \leq p(|x|) \text{ et } R_L(x, y)\]</span></p>
<p>où <span class="math inline">\(R_L\)</span> peut être calculée en
temps polynomial.</p>
<p>Une autre formulation équivalente est la suivante : un problème <span
class="math inline">\(L\)</span> est dans NP si et seulement s’il existe
une fonction polynomiale <span class="math inline">\(p\)</span> et un
algorithme de vérification <span class="math inline">\(V\)</span> tel
que pour tout <span class="math inline">\(x\)</span>, si <span
class="math inline">\(x \in L\)</span>, alors il existe un certificat
<span class="math inline">\(y\)</span> de taille au plus <span
class="math inline">\(p(|x|)\)</span> tel que <span
class="math inline">\(V(x, y) = 1\)</span>, et si <span
class="math inline">\(x \notin L\)</span>, alors pour tout <span
class="math inline">\(y\)</span> de taille au plus <span
class="math inline">\(p(|x|)\)</span>, <span class="math inline">\(V(x,
y) = 0\)</span>.</p>
<h1 id="théorèmes">Théorèmes</h1>
<p>Considérons maintenant le théorème de Cook-Levin, qui établit que le
problème SAT est NP-complet. Pour comprendre ce théorème, imaginons un
problème quelconque dans NP. Nous voulons montrer qu’il peut être réduit
à SAT en temps polynomial.</p>
<p>Le théorème de Cook-Levin s’énonce comme suit :</p>
<div class="theorem">
<p>Le problème SAT est NP-complet. C’est-à-dire que :</p>
<ul>
<li><p>SAT est dans NP.</p></li>
<li><p>Tout problème dans NP peut être réduit à SAT en temps
polynomial.</p></li>
</ul>
</div>
<p>Pour démontrer ce théorème, nous devons d’abord montrer que SAT est
dans NP. Cela revient à dire qu’il existe un algorithme de vérification
polynomial pour SAT. Ensuite, nous devons montrer que tout problème dans
NP peut être réduit à SAT en temps polynomial.</p>
<p>Une autre formulation du théorème de Cook-Levin est la suivante :
pour tout problème <span class="math inline">\(L\)</span> dans NP, il
existe une réduction polynomiale de <span
class="math inline">\(L\)</span> à SAT.</p>
<h1 id="preuves">Preuves</h1>
<p>Commençons par démontrer que SAT est dans NP. Considérons une
instance <span class="math inline">\(\phi\)</span> de SAT et un
certificat <span class="math inline">\(y\)</span>, qui est une
affectation des variables. Nous devons vérifier si cette affectation
satisfait <span class="math inline">\(\phi\)</span>.</p>
<p>L’algorithme de vérification fonctionne comme suit :</p>
<ol>
<li><p>Pour chaque clause <span class="math inline">\(C\)</span> dans
<span class="math inline">\(\phi\)</span>, vérifier si au moins une des
littéraux dans <span class="math inline">\(C\)</span> est vraie sous
l’affectation <span class="math inline">\(y\)</span>.</p></li>
<li><p>Si toutes les clauses sont satisfaites, retourner 1
(acceptation). Sinon, retourner 0 (rejet).</p></li>
</ol>
<p>Cet algorithme est polynomial en la taille de <span
class="math inline">\(\phi\)</span>, car il vérifie chaque clause une
fois et chaque littéral dans la clause.</p>
<p>Maintenant, montrons que tout problème <span
class="math inline">\(L\)</span> dans NP peut être réduit à SAT en temps
polynomial. Soit <span class="math inline">\(L\)</span> un problème dans
NP, et soit <span class="math inline">\(R_L\)</span> la relation
associée. Nous devons construire une formule booléenne <span
class="math inline">\(\phi_x\)</span> pour chaque instance <span
class="math inline">\(x\)</span> de <span
class="math inline">\(L\)</span> telle que <span
class="math inline">\(\phi_x\)</span> est satisfiable si et seulement si
<span class="math inline">\(x \in L\)</span>.</p>
<p>La construction de <span class="math inline">\(\phi_x\)</span> se
fait en plusieurs étapes :</p>
<ol>
<li><p>Pour chaque <span class="math inline">\(y\)</span> tel que <span
class="math inline">\(|y| \leq p(|x|)\)</span>, nous devons vérifier si
<span class="math inline">\(R_L(x, y)\)</span>.</p></li>
<li><p>Nous construisons une formule qui encode la relation <span
class="math inline">\(R_L\)</span> en utilisant des variables booléennes
pour représenter les états de la machine de Turing et les
transitions.</p></li>
<li><p>La formule résultante <span class="math inline">\(\phi_x\)</span>
est satisfiable si et seulement si il existe un <span
class="math inline">\(y\)</span> tel que <span
class="math inline">\(R_L(x, y)\)</span>.</p></li>
</ol>
<p>Cette réduction est polynomiale car la taille de <span
class="math inline">\(\phi_x\)</span> est polynomiale en la taille de
<span class="math inline">\(x\)</span>.</p>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Nous listons maintenant quelques propriétés importantes des problèmes
NP-complets.</p>
<ol>
<li><p>Tout problème dans NP peut être réduit en temps polynomial à un
problème NP-complet. Cela signifie que les problèmes NP-complets sont
les plus difficiles dans la classe NP.</p>
<p>Preuve : Soit <span class="math inline">\(L\)</span> un problème dans
NP et soit <span class="math inline">\(K\)</span> un problème
NP-complet. Par définition, il existe une réduction polynomiale de <span
class="math inline">\(L\)</span> à <span
class="math inline">\(K\)</span>. Cela montre que tout problème dans NP
peut être réduit en temps polynomial à un problème NP-complet.</p></li>
<li><p>Si un problème NP-complet peut être résolu en temps polynomial,
alors P = NP.</p>
<p>Preuve : Supposons qu’il existe un algorithme polynomial pour
résoudre un problème NP-complet <span class="math inline">\(K\)</span>.
Alors, tout problème dans NP peut être réduit à <span
class="math inline">\(K\)</span> en temps polynomial, et donc résolu en
temps polynomial. Cela implique que P = NP.</p></li>
<li><p>Le problème du chemin hamiltonien est NP-complet.</p>
<p>Preuve : Nous devons montrer que le chemin hamiltonien est dans NP et
qu’il est NP-difficile. Le chemin hamiltonien est dans NP car un
certificat (un chemin) peut être vérifié en temps polynomial. Pour
montrer qu’il est NP-difficile, nous réduisons SAT au chemin hamiltonien
en temps polynomial.</p></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>L’étude de la complexité des problèmes dans la classe NP est un
domaine riche et fascinant de l’informatique théorique. Les résultats
présentés ici, notamment le théorème de Cook-Levin et les propriétés des
problèmes NP-complets, montrent l’importance fondamentale de cette
classe dans la compréhension des limites algorithmiques. La question
P=NP reste ouverte, et sa résolution aurait des implications profondes
non seulement en théorie de la complexité, mais aussi dans de nombreux
domaines appliqués.</p>
</body>
</html>
{% include "footer.html" %}

