{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes dans la classe #P</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes dans la classe #P</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La théorie de la complexité computationnelle est un domaine
fondamental en informatique théorique, cherchant à classer les problèmes
selon leur difficulté algorithmique. Parmi les classes de complexité les
plus étudiées, la classe #P occupe une place particulière. Introduite
par Alan Baker et Michael Sipser en 1994, #P est définie comme
l’ensemble des fonctions qui comptent le nombre de solutions à des
problèmes de décision dans la classe NP.</p>
<p>L’étude de #P est motivée par plusieurs raisons. Tout d’abord, elle
permet de mieux comprendre la nature des problèmes de comptage, qui sont
omniprésents en algorithmique. Ensuite, elle fournit des outils pour
analyser la complexité de problèmes combinatoires et probabilistes.
Enfin, #P joue un rôle clé dans la hiérarchie des classes de complexité,
reliant les problèmes de décision (NP) aux problèmes de fonctions (FP et
#P).</p>
<h1 id="définitions">Définitions</h1>
<p>Pour définir la classe #P, nous commençons par rappeler quelques
notions fondamentales. Considérons un problème de décision <span
class="math inline">\(L\)</span> dans NP. Cela signifie qu’il existe une
relation <span class="math inline">\(R_L\)</span> et un polynôme <span
class="math inline">\(p\)</span> tels que pour toute instance <span
class="math inline">\(x\)</span>, <span class="math inline">\(x \in
L\)</span> si et seulement s’il existe un certificat <span
class="math inline">\(y\)</span> de taille au plus <span
class="math inline">\(p(|x|)\)</span> tel que <span
class="math inline">\(R_L(x, y)\)</span> soit vrai.</p>
<p>Nous cherchons maintenant à compter le nombre de solutions pour un
problème dans NP. Formellement, nous définissons la classe #P comme suit
:</p>
<div class="definition">
<p>La classe #P est l’ensemble des fonctions <span
class="math inline">\(f : \{0,1\}^* \rightarrow \mathbb{N}\)</span> pour
lesquelles il existe un polynôme <span class="math inline">\(p\)</span>
et une relation <span class="math inline">\(R_f \subseteq \{0,1\}^*
\times \{0,1\}^*\)</span> telles que pour tout <span
class="math inline">\(x \in \{0,1\}^*\)</span>, <span
class="math display">\[f(x) = \#\{ y \mid |y| \leq p(|x|) \text{ et }
R_f(x, y)\}.\]</span></p>
</div>
<p>Cette définition peut être reformulée en utilisant des
quantificateurs. Pour tout <span class="math inline">\(x \in
\{0,1\}^*\)</span>, il existe un polynôme <span
class="math inline">\(p\)</span> et une relation <span
class="math inline">\(R_f\)</span> tels que <span
class="math display">\[f(x) = \sum_{y \in \{0,1\}^{p(|x|)}} [R_f(x,
y)],\]</span> où <span class="math inline">\([R_f(x, y)]\)</span> est la
fonction indicatrice de la relation <span
class="math inline">\(R_f\)</span>.</p>
<h1 id="théorèmes">Théorèmes</h1>
<p>Un résultat fondamental concernant la classe #P est le théorème de
Todd, qui établit une relation entre les problèmes dans #P et les
problèmes de décision dans NP.</p>
<div class="theoreme">
<p>Soit <span class="math inline">\(f\)</span> une fonction dans #P.
Alors il existe un problème de décision <span
class="math inline">\(L\)</span> dans NP tel que <span
class="math inline">\(f\)</span> peut être exprimé comme une fonction de
comptage pour <span class="math inline">\(L\)</span>.</p>
</div>
<p>Pour démontrer ce théorème, nous procédons comme suit. Soit <span
class="math inline">\(f\)</span> dans #P. Par définition, il existe un
polynôme <span class="math inline">\(p\)</span> et une relation <span
class="math inline">\(R_f\)</span> tels que pour tout <span
class="math inline">\(x\)</span>, <span class="math display">\[f(x) =
\#\{ y \mid |y| \leq p(|x|) \text{ et } R_f(x, y)\}.\]</span></p>
<p>Nous définissons alors le problème de décision <span
class="math inline">\(L\)</span> comme suit : <span
class="math display">\[L = \{ (x, y) \mid R_f(x, y) \}.\]</span></p>
<p>Il est clair que <span class="math inline">\(L\)</span> est dans NP
car la relation <span class="math inline">\(R_f\)</span> peut être
vérifiée en temps polynomial. De plus, le nombre de solutions pour <span
class="math inline">\(L\)</span> est exactement <span
class="math inline">\(f(x)\)</span>, ce qui achève la démonstration.</p>
<h1 id="preuves">Preuves</h1>
<p>Pour illustrer les techniques de preuve dans le contexte de #P,
considérons un exemple simple. Nous allons montrer que le problème de
comptage des chemins hamiltoniens dans un graphe est dans #P.</p>
<div class="preuve">
<p>Soit <span class="math inline">\(G = (V, E)\)</span> un graphe et
<span class="math inline">\(s, t \in V\)</span>. Nous voulons compter le
nombre de chemins hamiltoniens de <span class="math inline">\(s\)</span>
à <span class="math inline">\(t\)</span>.</p>
<p>Par définition, un chemin hamiltonien est une séquence de sommets
distincts commençant par <span class="math inline">\(s\)</span> et se
terminant par <span class="math inline">\(t\)</span>, telle que chaque
sommet est adjacent au suivant dans la séquence.</p>
<p>Nous définissons une relation <span class="math inline">\(R\)</span>
comme suit : <span class="math display">\[R(G, s, t, \pi) \text{ si et
seulement si } \pi \text{ est un chemin hamiltonien de } s \text{ à } t
\text{ dans } G.\]</span></p>
<p>Il est clair que pour tout graphe <span
class="math inline">\(G\)</span> et sommets <span
class="math inline">\(s, t\)</span>, le nombre de chemins hamiltoniens
de <span class="math inline">\(s\)</span> à <span
class="math inline">\(t\)</span> est donné par <span
class="math display">\[\#\{ \pi \mid R(G, s, t, \pi) \}.\]</span></p>
<p>Puisque la vérification de <span class="math inline">\(R(G, s, t,
\pi)\)</span> peut être effectuée en temps polynomial, le problème de
comptage des chemins hamiltoniens est dans #P.</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Nous listons maintenant quelques propriétés importantes de la classe
#P.</p>
<ol>
<li><p>Si <span class="math inline">\(f\)</span> est dans #P et <span
class="math inline">\(g\)</span> est une fonction polynomiale, alors
<span class="math inline">\(f \circ g\)</span> est dans #P.</p>
<div class="preuve">
<p>Soit <span class="math inline">\(f\)</span> dans #P et <span
class="math inline">\(g\)</span> une fonction polynomiale. Par
définition, il existe un polynôme <span class="math inline">\(p\)</span>
et une relation <span class="math inline">\(R_f\)</span> tels que pour
tout <span class="math inline">\(x\)</span>, <span
class="math display">\[f(x) = \#\{ y \mid |y| \leq p(|x|) \text{ et }
R_f(x, y)\}.\]</span></p>
<p>Nous définissons alors <span class="math inline">\(f \circ g\)</span>
comme suit : <span class="math display">\[(f \circ g)(x) =
f(g(x)).\]</span></p>
<p>Il est clair que <span class="math inline">\(f \circ g\)</span> peut
être exprimé comme une fonction de comptage pour une relation
appropriée, ce qui montre que <span class="math inline">\(f \circ
g\)</span> est dans #P.</p>
</div></li>
<li><p>La classe #P est fermée sous l’opération de somme.</p>
<div class="preuve">
<p>Soient <span class="math inline">\(f, g\)</span> dans #P. Par
définition, il existe des polynômes <span class="math inline">\(p,
q\)</span> et des relations <span class="math inline">\(R_f,
R_g\)</span> tels que pour tout <span class="math inline">\(x\)</span>,
<span class="math display">\[f(x) = \#\{ y \mid |y| \leq p(|x|) \text{
et } R_f(x, y)\},\]</span> <span class="math display">\[g(x) = \#\{ z
\mid |z| \leq q(|x|) \text{ et } R_g(x, z)\}.\]</span></p>
<p>Nous définissons alors <span class="math inline">\(f + g\)</span>
comme suit : <span class="math display">\[(f + g)(x) = f(x) +
g(x).\]</span></p>
<p>Il est clair que <span class="math inline">\(f + g\)</span> peut être
exprimé comme une fonction de comptage pour une relation appropriée, ce
qui montre que <span class="math inline">\(f + g\)</span> est dans
#P.</p>
</div></li>
<li><p>Si <span class="math inline">\(f\)</span> est dans #P et <span
class="math inline">\(g\)</span> est une fonction polynomiale injective,
alors <span class="math inline">\(f \circ g\)</span> est dans #P.</p>
<div class="preuve">
<p>Soit <span class="math inline">\(f\)</span> dans #P et <span
class="math inline">\(g\)</span> une fonction polynomiale injective. Par
définition, il existe un polynôme <span class="math inline">\(p\)</span>
et une relation <span class="math inline">\(R_f\)</span> tels que pour
tout <span class="math inline">\(x\)</span>, <span
class="math display">\[f(x) = \#\{ y \mid |y| \leq p(|x|) \text{ et }
R_f(x, y)\}.\]</span></p>
<p>Nous définissons alors <span class="math inline">\(f \circ g\)</span>
comme suit : <span class="math display">\[(f \circ g)(x) =
f(g(x)).\]</span></p>
<p>Puisque <span class="math inline">\(g\)</span> est injective, l’image
de <span class="math inline">\(g\)</span> est en bijection avec son
domaine. Il est clair que <span class="math inline">\(f \circ g\)</span>
peut être exprimé comme une fonction de comptage pour une relation
appropriée, ce qui montre que <span class="math inline">\(f \circ
g\)</span> est dans #P.</p>
</div></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>La classe #P joue un rôle central dans la théorie de la complexité
computationnelle, fournissant des outils puissants pour l’analyse des
problèmes de comptage. Les résultats présentés dans cet article
illustrent la richesse et la profondeur de cette classe, ainsi que ses
liens étroits avec d’autres classes de complexité. Les propriétés et
théorèmes discutés ouvrent la voie à de nombreuses questions de
recherche, notamment sur les relations entre #P et d’autres classes
telles que FP et #P-complète.</p>
</body>
</html>
{% include "footer.html" %}

