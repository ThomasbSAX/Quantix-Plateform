{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de logique mathématique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de logique mathématique</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La logique mathématique, née au début du XXe siècle des travaux de
Frege, Russell et Whitehead, s’est imposée comme un pilier fondamental
des mathématiques. Elle offre un cadre rigoureux pour l’étude de la
validité des raisonnements, de la structure des théories mathématiques
et de la nature même des preuves. Cependant, l’émergence de la théorie
de la complexité computationnelle dans les années 1970 a ouvert une
nouvelle voie d’exploration : celle de la complexité des problèmes
logiques.</p>
<p>Pourquoi étudier la complexité des problèmes de logique mathématique
? Tout d’abord, parce que ces problèmes sont souvent non triviaux et
peuvent nécessiter des ressources computationnelles importantes.
Ensuite, parce que la compréhension de leur complexité permet de mieux
appréhender les limites des méthodes de preuve automatisée et des
systèmes de déduction. Enfin, parce que ces problèmes sont souvent au
cœur de questions fondamentales en informatique théorique, comme la
hiérarchie polynomiale ou l’hypothèse P vs NP.</p>
<p>Dans ce chapitre, nous explorerons les notions clés de la complexité
des problèmes logiques, en mettant l’accent sur leur formalisation
mathématique et leurs propriétés fondamentales.</p>
<h1 id="définitions">Définitions</h1>
<p>Nous commençons par définir les concepts de base nécessaires à notre
étude. Un problème logique est un ensemble de formules logiques pour
lesquelles nous cherchons à déterminer une certaine propriété. Par
exemple, le problème de la satisfiabilité consiste à déterminer si une
formule logique est satisfiable, c’est-à-dire s’il existe une
interprétation qui la rend vraie.</p>
<div class="definition">
<p>Soit <span class="math inline">\(\mathcal{L}\)</span> un langage
logique. Un problème de décision pour <span
class="math inline">\(\mathcal{L}\)</span> est une fonction <span
class="math inline">\(P: \mathcal{L} \rightarrow \{0,1\}\)</span> qui
associe à chaque formule <span class="math inline">\(\phi\)</span> de
<span class="math inline">\(\mathcal{L}\)</span> un booléen indiquant si
la propriété associée au problème est vérifiée par <span
class="math inline">\(\phi\)</span>.</p>
</div>
<p>Formellement, un problème de décision peut être défini comme suit
:</p>
<ul>
<li><p>Un ensemble <span class="math inline">\(\Sigma\)</span>
d’alphabet.</p></li>
<li><p>Un langage <span class="math inline">\(L \subseteq
\Sigma^*\)</span> représentant l’ensemble des instances du
problème.</p></li>
<li><p>Une fonction de décision <span class="math inline">\(f: \Sigma^*
\rightarrow \{0,1\}\)</span> telle que pour toute instance <span
class="math inline">\(x \in \Sigma^*\)</span>, <span
class="math inline">\(f(x) = 1\)</span> si et seulement si <span
class="math inline">\(x \in L\)</span>.</p></li>
</ul>
<p>Un problème logique est dit décidable s’il existe une machine de
Turing qui, pour toute formule <span class="math inline">\(\phi\)</span>
en entrée, s’arrête et retourne 1 si <span
class="math inline">\(\phi\)</span> vérifie la propriété associée au
problème, et 0 sinon.</p>
<div class="definition">
<p>Soit <span class="math inline">\(P\)</span> un problème de décision
et <span class="math inline">\(\mathcal{C}\)</span> une classe de
complexité. On dit que <span class="math inline">\(P\)</span> est dans
<span class="math inline">\(\mathcal{C}\)</span> si et seulement s’il
existe une machine de Turing déterministe (ou non déterministe, selon
<span class="math inline">\(\mathcal{C}\)</span>) qui décide <span
class="math inline">\(P\)</span> en temps polynomial (ou exponentiel,
etc.) selon la définition de <span
class="math inline">\(\mathcal{C}\)</span>.</p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<p>Nous présentons maintenant quelques théorèmes fondamentaux concernant
la complexité des problèmes logiques. Le premier théorème que nous
abordons est le théorème de Cook-Levin, qui établit la NP-complétude du
problème de la satisfiabilité.</p>
<div class="theorem">
<p>Le problème de la satisfiabilité (SAT) est NP-complet. C’est-à-dire
que :</p>
<ul>
<li><p>SAT <span class="math inline">\(\in\)</span> NP.</p></li>
<li><p>Pour tout problème <span class="math inline">\(P \in\)</span> NP,
il existe une réduction polynomiale de <span
class="math inline">\(P\)</span> à SAT.</p></li>
</ul>
</div>
<div class="proof">
<p><em>Proof.</em> La preuve du théorème de Cook-Levin se déroule en
deux parties. Tout d’abord, nous montrons que SAT <span
class="math inline">\(\in\)</span> NP. Ensuite, nous prouvons que tout
problème dans NP peut être réduit polynomialement à SAT.</p>
<ol>
<li><p>Montrons que SAT <span class="math inline">\(\in\)</span> NP.
Pour cela, nous devons exhiber un certificat pour les instances
satisfiables de SAT et un algorithme polynomial qui vérifie ce
certificat. Le certificat est une interprétation des variables de la
formule <span class="math inline">\(\phi\)</span> qui rend <span
class="math inline">\(\phi\)</span> vraie. L’algorithme de vérification
consiste simplement à substituer les valeurs du certificat dans <span
class="math inline">\(\phi\)</span> et à vérifier que la formule
résultante est vraie. Cette vérification peut être effectuée en temps
polynomial.</p></li>
<li><p>Montrons maintenant que tout problème <span
class="math inline">\(P \in\)</span> NP peut être réduit polynomialement
à SAT. Soit <span class="math inline">\(P\)</span> un problème dans NP
et soit <span class="math inline">\(\mathcal{M}\)</span> une machine de
Turing non déterministe qui décide <span
class="math inline">\(P\)</span> en temps polynomial. Nous construisons
une formule <span class="math inline">\(\phi_P(x)\)</span> telle que
pour toute instance <span class="math inline">\(x\)</span> de <span
class="math inline">\(P\)</span>, <span
class="math inline">\(\phi_P(x)\)</span> est satisfiable si et seulement
si <span class="math inline">\(\mathcal{M}\)</span> accepte <span
class="math inline">\(x\)</span>. La construction de <span
class="math inline">\(\phi_P(x)\)</span> est basée sur une simulation de
la machine <span class="math inline">\(\mathcal{M}\)</span> et peut être
effectuée en temps polynomial.</p></li>
</ol>
<p> ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<p>Nous détaillons maintenant les preuves des théorèmes présentés dans
la section précédente. Nous commençons par la preuve que SAT <span
class="math inline">\(\in\)</span> NP.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(\phi\)</span> une
formule propositionnelle en forme normale conjonctive (CNF). Nous devons
montrer qu’il existe un certificat et un algorithme polynomial qui
vérifie ce certificat. Le certificat est une interprétation des
variables de <span class="math inline">\(\phi\)</span> qui rend <span
class="math inline">\(\phi\)</span> vraie.</p>
<p>L’algorithme de vérification est le suivant :</p>
<ol>
<li><p>Pour chaque clause <span class="math inline">\(C_i\)</span> de
<span class="math inline">\(\phi\)</span>, vérifier qu’il existe au
moins une variable littérale <span class="math inline">\(l_j\)</span>
dans <span class="math inline">\(C_i\)</span> telle que l’interprétation
du littéral <span class="math inline">\(l_j\)</span> est vraie.</p></li>
<li><p>Si pour toutes les clauses <span
class="math inline">\(C_i\)</span>, il existe un tel littéral, alors
<span class="math inline">\(\phi\)</span> est satisfiable et
l’algorithme retourne 1. Sinon, il retourne 0.</p></li>
</ol>
<p>Cet algorithme peut être implémenté en temps polynomial car il
nécessite de parcourir chaque clause et chaque littéral de <span
class="math inline">\(\phi\)</span> une fois. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Nous présentons maintenant quelques propriétés et corollaires
importants concernant la complexité des problèmes logiques.</p>
<div class="proposition">
<p>Soit <span class="math inline">\(P\)</span> un problème de décision.
Si <span class="math inline">\(P\)</span> est NP-complet, alors <span
class="math inline">\(P \in\)</span> NP.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Par définition, un problème <span
class="math inline">\(P\)</span> est NP-complet si et seulement si <span
class="math inline">\(P \in\)</span> NP et pour tout problème <span
class="math inline">\(Q \in\)</span> NP, il existe une réduction
polynomiale de <span class="math inline">\(Q\)</span> à <span
class="math inline">\(P\)</span>. Par conséquent, si <span
class="math inline">\(P\)</span> est NP-complet, alors <span
class="math inline">\(P \in\)</span> NP. ◻</p>
</div>
<div class="corollary">
<p>Si P = NP, alors tout problème NP-complet est dans P.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Supposons que P = NP. Soit <span
class="math inline">\(P\)</span> un problème NP-complet. Par définition,
<span class="math inline">\(P \in\)</span> NP. Puisque P = NP, il
s’ensuit que <span class="math inline">\(P \in\)</span> P. ◻</p>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>Dans ce chapitre, nous avons exploré les notions fondamentales de la
complexité des problèmes de logique mathématique. Nous avons défini les
concepts clés, présenté des théorèmes importants et détaillé leurs
preuves. Nous avons également discuté de certaines propriétés et
corollaires qui découlent de ces résultats.</p>
<p>L’étude de la complexité des problèmes logiques est un domaine riche
et actif de recherche, avec de nombreuses questions ouvertes et défis à
relever. Les résultats présentés dans ce chapitre ne représentent qu’une
infime partie de ce domaine, mais ils fournissent une base solide pour
une exploration plus approfondie.</p>
</body>
</html>
{% include "footer.html" %}

