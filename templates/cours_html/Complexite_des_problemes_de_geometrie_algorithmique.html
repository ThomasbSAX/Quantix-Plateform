{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="(Quantix)" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de géométrie algorithmique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title"><strong>Complexité des problèmes de géométrie
algorithmique</strong></h1>
<p class="author">(Quantix)</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La géométrie algorithmique est une branche des mathématiques et de
l’informatique qui étudie les algorithmes permettant de résoudre des
problèmes géométriques. Son origine remonte aux années 1970, avec les
travaux de Michael Shamos et Dan Hooley sur le calcul des distances
minimales entre points. Cette discipline émerge de la nécessité de
traiter efficacement des problèmes géométriques complexes, tels que le
tri de points, la recherche de plus proches voisins ou encore
l’intersection de segments.</p>
<p>La notion de complexité en géométrie algorithmique est indispensable
pour évaluer l’efficacité des algorithmes proposés. Elle permet de
comparer différentes approches et de choisir la plus adaptée en fonction
des contraintes données. Les problèmes de géométrie algorithmique sont
souvent motivés par des applications pratiques, telles que la
cartographie, la robotique ou encore la modélisation 3D.</p>
<h1 id="définitions">Définitions</h1>
<p>Dans cette section, nous allons définir les notions fondamentales de
la géométrie algorithmique. Nous commencerons par expliquer
pédagogiquement ce que nous cherchons à avoir, puis nous annoncerons
formellement les définitions avec toutes les notations nécessaires.</p>
<h2 id="problème-de-décision">Problème de décision</h2>
<p>Nous cherchons à déterminer si un certain prédicat est vrai ou faux
pour une instance donnée. Par exemple, nous pouvons vouloir savoir si un
point appartient à un polygone ou si deux segments se croisent.</p>
<div class="definition">
<p>Soit <span class="math inline">\(P\)</span> un problème de décision.
Nous disons que <span class="math inline">\(P\)</span> est dans la
classe <span class="math inline">\(\mathcal{P}\)</span> s’il existe un
algorithme qui décide de <span class="math inline">\(P\)</span> en temps
polynomial.</p>
</div>
<p>Formellement, cela signifie qu’il existe une fonction <span
class="math inline">\(f : \mathbb{N} \rightarrow \mathbb{N}\)</span> et
un algorithme <span class="math inline">\(\mathcal{A}\)</span> tels que
pour toute instance <span class="math inline">\(x\)</span> de taille
<span class="math inline">\(n\)</span>, <span
class="math inline">\(\mathcal{A}\)</span> décide de <span
class="math inline">\(P(x)\)</span> en un temps borné par <span
class="math inline">\(f(n)\)</span>.</p>
<h2 id="problème-doptimisation">Problème d’optimisation</h2>
<p>Nous cherchons à trouver une solution optimale parmi un ensemble de
solutions possibles. Par exemple, nous pouvons vouloir trouver le plus
court chemin entre deux points ou le plus grand ensemble de points non
croisés.</p>
<div class="definition">
<p>Soit <span class="math inline">\(P\)</span> un problème
d’optimisation. Nous disons que <span class="math inline">\(P\)</span>
est dans la classe <span class="math inline">\(\mathcal{NP}\)</span>
s’il existe un algorithme qui vérifie une solution de <span
class="math inline">\(P\)</span> en temps polynomial.</p>
</div>
<p>Formellement, cela signifie qu’il existe une fonction <span
class="math inline">\(f : \mathbb{N} \rightarrow \mathbb{N}\)</span> et
un algorithme <span class="math inline">\(\mathcal{V}\)</span> tels que
pour toute instance <span class="math inline">\(x\)</span> de taille
<span class="math inline">\(n\)</span> et toute solution candidate <span
class="math inline">\(y\)</span>, <span
class="math inline">\(\mathcal{V}\)</span> vérifie si <span
class="math inline">\(y\)</span> est une solution de <span
class="math inline">\(P(x)\)</span> en un temps borné par <span
class="math inline">\(f(n)\)</span>.</p>
<h1 id="théorèmes">Théorèmes</h1>
<p>Dans cette section, nous allons présenter les théorèmes importants de
la géométrie algorithmique. Nous commencerons par expliquer
pédagogiquement ce que nous cherchons à avoir, puis nous annoncerons
formellement les théorèmes avec toutes les notations nécessaires.</p>
<h2 id="théorème-du-triangle-de-delaunay">Théorème du triangle de
Delaunay</h2>
<p>Nous cherchons à construire un triangulation de Delaunay d’un
ensemble de points. Une triangulation de Delaunay est une triangulation
d’un ensemble de points telle que le cercle circonscrit de chaque
triangle ne contient aucun autre point.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(S\)</span> un ensemble de points
dans le plan. Il existe une triangulation de Delaunay de <span
class="math inline">\(S\)</span> en temps <span
class="math inline">\(O(n \log n)\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Nous allons prouver ce théorème en utilisant
l’algorithme de construction de la triangulation de Delaunay basé sur le
plan de Voronoï. L’idée est de construire d’abord le plan de Voronoï,
puis de dualiser ce plan pour obtenir la triangulation de Delaunay.</p>
<p>1. Construction du plan de Voronoï: Nous utilisons l’algorithme de
Fortune pour construire le plan de Voronoï en temps <span
class="math inline">\(O(n \log n)\)</span>.</p>
<p>2. Dualisation du plan de Voronoï: Nous dualisons le plan de Voronoï
pour obtenir la triangulation de Delaunay. Cette étape se fait en temps
linéaire.</p>
<p>Donc, la construction de la triangulation de Delaunay se fait en
temps <span class="math inline">\(O(n \log n)\)</span>. ◻</p>
</div>
<h2 id="théorème-du-plus-proche-voisin">Théorème du plus proche
voisin</h2>
<p>Nous cherchons à trouver le plus proche voisin d’un point donné dans
un ensemble de points. Le plus proche voisin d’un point <span
class="math inline">\(p\)</span> est le point de l’ensemble qui est le
plus proche de <span class="math inline">\(p\)</span>.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(S\)</span> un ensemble de points
dans le plan et <span class="math inline">\(p\)</span> un point. Il
existe un algorithme qui trouve le plus proche voisin de <span
class="math inline">\(p\)</span> dans <span
class="math inline">\(S\)</span> en temps <span
class="math inline">\(O(n \log n)\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Nous allons prouver ce théorème en utilisant
l’algorithme de recherche du plus proche voisin basé sur l’arbre KD.
L’idée est de construire un arbre KD à partir de l’ensemble <span
class="math inline">\(S\)</span>, puis de rechercher le plus proche
voisin de <span class="math inline">\(p\)</span> dans cet arbre.</p>
<p>1. Construction de l’arbre KD: Nous utilisons l’algorithme de
construction de l’arbre KD en temps <span class="math inline">\(O(n \log
n)\)</span>.</p>
<p>2. Recherche du plus proche voisin: Nous recherchons le plus proche
voisin de <span class="math inline">\(p\)</span> dans l’arbre KD. Cette
étape se fait en temps <span class="math inline">\(O(\log
n)\)</span>.</p>
<p>Donc, la recherche du plus proche voisin se fait en temps <span
class="math inline">\(O(n \log n)\)</span>. ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<p>Dans cette section, nous allons justifier explicitement chaque étape
des preuves présentées dans la section précédente. Nous mentionnerons
les propriétés et théorèmes utilisés et développerons systématiquement
sur plusieurs lignes.</p>
<h2 id="preuve-du-théorème-du-triangle-de-delaunay">Preuve du théorème
du triangle de Delaunay</h2>
<p>Nous allons justifier chaque étape de la preuve du théorème du
triangle de Delaunay.</p>
<p>1. Construction du plan de Voronoï: Nous utilisons l’algorithme de
Fortune pour construire le plan de Voronoï en temps <span
class="math inline">\(O(n \log n)\)</span>. Cet algorithme est basé sur
le balayage de l’ensemble des points par une ligne de balayage. À chaque
étape, la ligne de balayage rencontre un événement, qui peut être soit
l’ajout d’un nouveau point, soit la fin d’une arête de Voronoï.
L’algorithme traite ces événements en temps <span
class="math inline">\(O(\log n)\)</span> grâce à une structure de
données adaptée.</p>
<p>2. Dualisation du plan de Voronoï: Nous dualisons le plan de Voronoï
pour obtenir la triangulation de Delaunay. Cette étape se fait en temps
linéaire, car chaque arête de Voronoï est dualisée en une arête de la
triangulation de Delaunay.</p>
<p>Donc, la construction de la triangulation de Delaunay se fait en
temps <span class="math inline">\(O(n \log n)\)</span>.</p>
<h2 id="preuve-du-théorème-du-plus-proche-voisin">Preuve du théorème du
plus proche voisin</h2>
<p>Nous allons justifier chaque étape de la preuve du théorème du plus
proche voisin.</p>
<p>1. Construction de l’arbre KD: Nous utilisons l’algorithme de
construction de l’arbre KD en temps <span class="math inline">\(O(n \log
n)\)</span>. Cet algorithme est basé sur le partitionnement récursif de
l’ensemble des points en sous-ensembles de taille égale ou presque
égale. À chaque étape, nous choisissons un axe de partitionnement et un
point médian selon cet axe. Nous répétons ce processus jusqu’à ce que
chaque sous-ensemble contienne un seul point.</p>
<p>2. Recherche du plus proche voisin: Nous recherchons le plus proche
voisin de <span class="math inline">\(p\)</span> dans l’arbre KD. Cette
étape se fait en temps <span class="math inline">\(O(\log n)\)</span>,
car nous explorons l’arbre KD de manière récursive en éliminant à chaque
étape une moitié des points.</p>
<p>Donc, la recherche du plus proche voisin se fait en temps <span
class="math inline">\(O(n \log n)\)</span>.</p>
<h1 id="propriétés-et-corollaires">Propriétés et corollaires</h1>
<p>Dans cette section, nous allons lister les propriétés et corollaires
importants de la géométrie algorithmique. Nous les développerons une par
une, avec des preuves détaillées.</p>
<h2 id="propriété-de-la-triangulation-de-delaunay">Propriété de la
triangulation de Delaunay</h2>
<p>Nous allons lister les propriétés importantes de la triangulation de
Delaunay.</p>
<ol>
<li><p>La triangulation de Delaunay maximise l’angle minimal des
triangles. Cela signifie que pour toute autre triangulation de
l’ensemble de points, l’angle minimal des triangles est plus petit ou
égal à celui de la triangulation de Delaunay.</p>
<div class="proof">
<p><em>Proof.</em> Nous allons prouver cette propriété en utilisant le
fait que la triangulation de Delaunay est duale du plan de Voronoï. Le
plan de Voronoï est la partition du plan en régions telles que chaque
région contient tous les points plus proches d’un point de l’ensemble
que des autres points. La dualisation du plan de Voronoï consiste à
connecter les centres des cercles circonscrits des triangles de la
triangulation. Comme les cercles circonscrits ne contiennent aucun autre
point, les triangles de la triangulation ont des angles minimaux
maximisés. ◻</p>
</div></li>
<li><p>La triangulation de Delaunay est unique si aucun sous-ensemble de
quatre points n’est cocyclique. Cela signifie que si aucun ensemble de
quatre points ne se trouve sur le même cercle, alors il n’existe qu’une
seule triangulation de Delaunay pour cet ensemble de points.</p>
<div class="proof">
<p><em>Proof.</em> Nous allons prouver cette propriété en utilisant le
fait que la triangulation de Delaunay est déterminée par les cercles
circonscrits des triangles. Si aucun sous-ensemble de quatre points
n’est cocyclique, alors les cercles circonscrits des triangles sont
uniques et déterminent donc une triangulation unique. ◻</p>
</div></li>
</ol>
<h2 id="corollaire-du-plus-proche-voisin">Corollaire du plus proche
voisin</h2>
<p>Nous allons lister les corollaires importants du théorème du plus
proche voisin.</p>
<ol>
<li><p>Le problème de la recherche du plus proche voisin peut être
résolu en temps <span class="math inline">\(O(n \log n)\)</span> dans le
plan.</p>
<div class="proof">
<p><em>Proof.</em> Nous allons prouver ce corollaire en utilisant le
théorème du plus proche voisin. Le théorème nous dit que la recherche du
plus proche voisin peut être faite en temps <span
class="math inline">\(O(n \log n)\)</span>. Comme le plan est un espace
métrique, nous pouvons appliquer ce théorème directement. ◻</p>
</div></li>
<li><p>Le problème de la recherche du plus proche voisin peut être
résolu en temps <span class="math inline">\(O(n)\)</span> dans le plan
si l’ensemble de points est statique.</p>
<div class="proof">
<p><em>Proof.</em> Nous allons prouver ce corollaire en utilisant le
fait que l’arbre KD peut être construit en temps <span
class="math inline">\(O(n)\)</span> si l’ensemble de points est
statique. Une fois l’arbre KD construit, la recherche du plus proche
voisin peut être faite en temps <span class="math inline">\(O(\log
n)\)</span>. Donc, le problème de la recherche du plus proche voisin
peut être résolu en temps <span class="math inline">\(O(n)\)</span> dans
le plan si l’ensemble de points est statique. ◻</p>
</div></li>
</ol>
</body>
</html>
{% include "footer.html" %}

