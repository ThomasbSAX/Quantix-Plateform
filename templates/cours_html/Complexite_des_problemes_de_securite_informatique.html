{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de sécurité informatique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de sécurité informatique</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>La sécurité informatique, discipline à la croisée de l’informatique
théorique et pratique, émerge comme un champ essentiel face à la
prolifération des systèmes interconnectés. Historiquement, les premiers
travaux sur la cryptographie remontent à l’Antiquité, mais c’est avec
l’avènement des ordinateurs que la discipline a pris une dimension
scientifique rigoureuse. Les problèmes de sécurité informatique, tels
que l’authentification, la confidentialité et l’intégrité des données,
soulèvent des défis complexes qui nécessitent une compréhension
approfondie des limites computationnelles.</p>
<p>Pourquoi cette notion est-elle indispensable ? Parce que les attaques
informatiques deviennent de plus en plus sophistiquées, exploitant des
vulnérabilités dans les protocoles et les implémentations. Comprendre la
complexité de ces problèmes permet de concevoir des systèmes robustes,
capables de résister aux menaces actuelles et futures. Dans ce cadre, la
théorie de la complexité algorithmique fournit des outils puissants pour
analyser et classer ces problèmes, offrant ainsi une base théorique
solide pour l’ingénierie de la sécurité.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour aborder la complexité des problèmes de sécurité informatique, il
est crucial de définir certains concepts fondamentaux. Commençons par la
notion de problème décidable.</p>
<div class="definition">
<p>Un <strong>problème</strong> est un ensemble de questions pour
lesquelles une réponse binaire (oui ou non) est attendue. Par exemple,
le problème de l’authentification peut être formulé comme suit : étant
donné un message et une signature, le message a-t-il été signé par
l’entité prétendue ?</p>
</div>
<p>Formellement, un problème peut être représenté comme une fonction
booléenne <span class="math inline">\(f : \{0,1\}^* \rightarrow
\{0,1\}\)</span>, où <span class="math inline">\(\{0,1\}^*\)</span>
désigne l’ensemble de toutes les chaînes binaires finies.</p>
<div class="definition">
<p>Un problème est <strong>décidable</strong> s’il existe une machine de
Turing qui, pour toute entrée <span class="math inline">\(x\)</span>,
s’arrête et retourne la réponse correcte <span
class="math inline">\(f(x)\)</span>. Autrement dit, un problème est
décidable s’il existe un algorithme qui peut résoudre le problème en
temps fini.</p>
</div>
<p>Mathématiquement, cela se traduit par : <span
class="math display">\[\forall x \in \{0,1\}^*, \exists M \text{
(machine de Turing)}, M(x) \text{ s&#39;arrête et retourne }
f(x).\]</span></p>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<p>Un des théorèmes fondamentaux en théorie de la complexité est le
théorème de Cook-Levin, qui établit que le problème de satisfaction
booléenne (SAT) est NP-complet.</p>
<div class="theorem">
<p>Le problème de satisfaction booléenne (SAT) est NP-complet. Cela
signifie que tout problème dans la classe NP peut être réduit en temps
polynomial à SAT.</p>
</div>
<p>Formellement, cela s’exprime comme suit : <span
class="math display">\[\forall L \in NP, \exists \text{ réduction
polynomial } R \text{ telle que } x \in L \Leftrightarrow R(x) \in
SAT.\]</span></p>
<p>La preuve de ce théorème repose sur la construction d’une machine de
Turing non déterministique qui peut résoudre SAT en temps polynomial. En
utilisant cette machine, on peut montrer que tout problème dans NP peut
être réduit à SAT.</p>
<h1 class="unnumbered" id="preuves">Preuves</h1>
<p>Pour prouver le théorème de Cook-Levin, nous devons montrer que SAT
est dans NP et que tout problème dans NP peut être réduit à SAT.</p>
<div class="proof">
<p><em>Proof.</em> 1. **SAT est dans NP** : Pour une formule booléenne
<span class="math inline">\(\phi\)</span> et une affectation <span
class="math inline">\(\alpha\)</span>, nous pouvons vérifier en temps
polynomial si <span class="math inline">\(\alpha\)</span> satisfait
<span class="math inline">\(\phi\)</span>. Il suffit de substituer les
valeurs de <span class="math inline">\(\alpha\)</span> dans <span
class="math inline">\(\phi\)</span> et d’évaluer le résultat.</p>
<p>2. **Réduction de tout problème dans NP à SAT** : Soit <span
class="math inline">\(L\)</span> un problème dans NP. Par définition, il
existe une machine de Turing non déterministique <span
class="math inline">\(M\)</span> qui décide <span
class="math inline">\(L\)</span> en temps polynomial. Nous pouvons
construire une formule booléenne <span
class="math inline">\(\phi_{M,x}\)</span> qui est satisfiable si et
seulement si <span class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span>. Cette construction repose sur
l’encodage des configurations de la machine et des transitions entre ces
configurations. ◻</p>
</div>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<p>Le théorème de Cook-Levin a plusieurs propriétés importantes et
corollaires.</p>
<ol>
<li><p>**NP est fermé sous réduction polynomial** : Si un problème <span
class="math inline">\(A\)</span> peut être réduit en temps polynomial à
un problème <span class="math inline">\(B\)</span> dans NP, alors <span
class="math inline">\(A\)</span> est aussi dans NP.</p>
<div class="proof">
<p><em>Proof.</em> Supposons que <span class="math inline">\(A \leq_p
B\)</span> et que <span class="math inline">\(B \in NP\)</span>. Alors,
il existe une réduction polynomial <span
class="math inline">\(R\)</span> telle que <span class="math inline">\(x
\in A \Leftrightarrow R(x) \in B\)</span>. Comme <span
class="math inline">\(B\)</span> est dans NP, il existe une machine de
Turing non déterministique <span class="math inline">\(M\)</span> qui
décide <span class="math inline">\(B\)</span> en temps polynomial. Nous
pouvons construire une machine de Turing non déterministique <span
class="math inline">\(M&#39;\)</span> qui, pour toute entrée <span
class="math inline">\(x\)</span>, applique <span
class="math inline">\(R\)</span> à <span
class="math inline">\(x\)</span> et exécute <span
class="math inline">\(M\)</span> sur <span
class="math inline">\(R(x)\)</span>. Comme <span
class="math inline">\(R\)</span> et <span
class="math inline">\(M\)</span> sont en temps polynomial, <span
class="math inline">\(M&#39;\)</span> est aussi en temps polynomial.
Donc, <span class="math inline">\(A \in NP\)</span>. ◻</p>
</div></li>
<li><p>**SAT est NP-difficile** : Tout problème dans NP peut être réduit
en temps polynomial à SAT.</p>
<div class="proof">
<p><em>Proof.</em> Cela découle directement du théorème de Cook-Levin.
Si <span class="math inline">\(L\)</span> est un problème dans NP, alors
il existe une réduction polynomial <span
class="math inline">\(R\)</span> telle que <span class="math inline">\(x
\in L \Leftrightarrow R(x) \in SAT\)</span>. ◻</p>
</div></li>
<li><p>**Si P = NP, alors SAT peut être résolu en temps polynomial** :
Si la classe P est égale à la classe NP, alors il existe un algorithme
en temps polynomial pour résoudre SAT.</p>
<div class="proof">
<p><em>Proof.</em> Si <span class="math inline">\(P = NP\)</span>, alors
SAT est dans P, car SAT est dans NP. Donc, il existe un algorithme en
temps polynomial pour résoudre SAT. ◻</p>
</div></li>
</ol>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>La complexité des problèmes de sécurité informatique est un domaine
riche et fascinant, qui combine des techniques de la théorie de la
complexité algorithmique et de la cryptographie. Les théorèmes
fondamentaux, tels que le théorème de Cook-Levin, fournissent une base
théorique solide pour comprendre les limites computationnelles des
problèmes de sécurité. En explorant ces concepts, nous pouvons concevoir
des systèmes de sécurité plus robustes et résister aux menaces
évolutives du monde numérique.</p>
</body>
</html>
{% include "footer.html" %}

