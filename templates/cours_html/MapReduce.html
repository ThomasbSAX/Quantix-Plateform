{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>MapReduce: Une Révolution dans le Traitement Distribué des Données</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">MapReduce: Une Révolution dans le Traitement Distribué
des Données</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>L’ère du Big Data a imposé de nouveaux défis en matière de traitement
et d’analyse des données. Face à l’explosion exponentielle des volumes
de données, les architectures traditionnelles de traitement centralisé
se sont révélées inadaptées. C’est dans ce contexte que MapReduce, un
modèle de programmation parallèle et distribué, a émergé comme une
solution révolutionnaire.</p>
<p>Introduit par Google en 2004 et popularisé par Apache Hadoop,
MapReduce permet de traiter des petaoctets de données en divisant les
tâches en deux phases principales : la phase Map et la phase Reduce.
Cette approche non seulement simplifie le développement d’applications
distribuées, mais garantit également une tolérance aux pannes et une
scalabilité exceptionnelle.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour comprendre MapReduce, il est essentiel de définir ses composants
fondamentaux. Supposons que nous ayons une fonction <span
class="math inline">\(f\)</span> qui transforme un ensemble de paires
clé-valeur <span class="math inline">\((k_1, v_1), \ldots, (k_n,
v_n)\)</span>. Notre objectif est de calculer une nouvelle paire
clé-valeur <span class="math inline">\((k&#39;, v&#39;)\)</span> en
utilisant ces données.</p>
<div class="definition">
<p>La fonction Map, notée <span
class="math inline">\(\text{map}\)</span>, prend une paire clé-valeur
<span class="math inline">\((k, v)\)</span> et produit un ensemble de
paires intermédiaire <span class="math inline">\(\{ (k_i, v_i)
\}_{i=1}^m\)</span>. Formellement, <span
class="math display">\[\text{map}: (k, v) \mapsto \{ (k_i, v_i)
\}_{i=1}^m\]</span></p>
</div>
<div class="definition">
<p>La fonction Reduce, notée <span
class="math inline">\(\text{reduce}\)</span>, prend une clé
intermédiaire <span class="math inline">\(k_i\)</span> et un ensemble de
valeurs associées <span class="math inline">\(\{ v_{i1}, \ldots, v_{im}
\}\)</span> et produit une paire clé-valeur <span
class="math inline">\((k&#39;, v&#39;)\)</span>. Formellement, <span
class="math display">\[\text{reduce}: (k_i, \{ v_{i1}, \ldots, v_{im}
\}) \mapsto (k&#39;, v&#39;)\]</span></p>
</div>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<p>Le modèle MapReduce repose sur plusieurs théorèmes fondamentaux qui
garantissent son efficacité et sa robustesse.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(N\)</span> le nombre de nœuds dans
un cluster MapReduce. Pour une tâche donnée, si <span
class="math inline">\(T(N)\)</span> est le temps d’exécution sur <span
class="math inline">\(N\)</span> nœuds, alors <span
class="math display">\[T(N) = O\left( \frac{T(1)}{N} \right)\]</span> où
<span class="math inline">\(T(1)\)</span> est le temps d’exécution sur
un seul nœud. Ce théorème montre que MapReduce peut théoriquement
diviser le temps d’exécution par un facteur linéaire en augmentant le
nombre de nœuds.</p>
</div>
<div class="proof">
<p><em>Proof.</em> La preuve repose sur l’hypothèse que les tâches
peuvent être parfaitement parallélisées et que la communication entre
les nœuds est négligeable. En divisant le travail en <span
class="math inline">\(N\)</span> parties égales, chaque nœud traite une
partie du problème, réduisant ainsi le temps total de <span
class="math inline">\(\frac{1}{N}\)</span>. ◻</p>
</div>
<h1 class="unnumbered" id="preuves">Preuves</h1>
<p>Pour illustrer l’efficacité de MapReduce, considérons un exemple
simple : le comptage des mots dans un grand corpus de texte.</p>
<div class="example">
<p>Supposons que nous avons un ensemble de documents <span
class="math inline">\(D = \{ d_1, \ldots, d_n \}\)</span>. Notre
objectif est de compter le nombre d’occurrences de chaque mot <span
class="math inline">\(w\)</span> dans <span
class="math inline">\(D\)</span>.</p>
<ol>
<li><p>Pour chaque document <span class="math inline">\(d_i\)</span>,
nous appliquons la fonction Map qui émet une paire <span
class="math inline">\((w, 1)\)</span> pour chaque mot <span
class="math inline">\(w\)</span> dans le document. <span
class="math display">\[\text{map}(d_i) = \{ (w, 1) \mid w \in d_i
\}\]</span></p></li>
<li><p>Les paires intermédiaires sont regroupées par clé <span
class="math inline">\(w\)</span>. <span class="math display">\[\{ (w,
1), (w, 1), \ldots, (w, 1) \}\]</span></p></li>
<li><p>Pour chaque mot <span class="math inline">\(w\)</span>, nous
appliquons la fonction Reduce qui somme toutes les valeurs associées à
<span class="math inline">\(w\)</span>. <span
class="math display">\[\text{reduce}(w, \{ 1, \ldots, 1 \}) = (w,
n)\]</span> où <span class="math inline">\(n\)</span> est le nombre
d’occurrences de <span class="math inline">\(w\)</span>.</p></li>
</ol>
</div>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<p>MapReduce possède plusieurs propriétés intéressantes qui en font un
outil puissant pour le traitement distribué des données.</p>
<div class="proposition">
<p>Les propriétés suivantes sont satisfaites par MapReduce :</p>
<ol>
<li><p><em>Tolérance aux Pannes</em> : MapReduce est conçu pour gérer
les pannes de nœuds individuels sans interrompre le traitement
global.</p></li>
<li><p><em>Scalabilité</em> : MapReduce peut traiter des quantités
massives de données en augmentant simplement le nombre de nœuds dans le
cluster.</p></li>
<li><p><em>Simplicité de Programmation</em> : MapReduce simplifie le
développement d’applications distribuées en masquant les complexités de
la parallélisation et de la communication.</p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em></p>
<ul>
<li><p>La tolérance aux pannes est assurée par la réplication des
données et le suivi de l’état des tâches par le maître
MapReduce.</p></li>
<li><p>La scalabilité est une conséquence directe du modèle de
programmation parallèle et distribué.</p></li>
<li><p>La simplicité de programmation résulte de l’abstraction des
fonctions Map et Reduce, qui permettent aux développeurs de se
concentrer sur la logique métier plutôt que sur les détails de
l’implémentation distribuée.</p></li>
</ul>
<p> ◻</p>
</div>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>MapReduce a révolutionné le traitement distribué des données en
offrant un modèle de programmation simple, scalable et tolérant aux
pannes. Son adoption massive dans l’industrie témoigne de son efficacité
et de sa pertinence dans l’ère du Big Data. À mesure que les volumes de
données continuent de croître, MapReduce et ses dérivés resteront des
outils indispensables pour les analystes et les ingénieurs en
données.</p>
</body>
</html>
{% include "footer.html" %}

