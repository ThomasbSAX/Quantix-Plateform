{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes dans la classe NEXP</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes dans la classe NEXP</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La théorie de la complexité computationnelle est un domaine fascinant
qui cherche à classer les problèmes en fonction des ressources
nécessaires pour les résoudre. Parmi les classes de complexité les plus
étudiées, on trouve la classe NEXP, qui généralise la classe NP en
autorisant des machines de Turing non déterministes à utiliser un espace
exponentiel. L’étude de NEXP est motivée par la quête de comprendre les
limites fondamentales des algorithmes et des machines de calcul. Cette
classe est indispensable pour appréhender les problèmes qui nécessitent
une quantité exponentielle d’espace, comme certains problèmes de logique
et de théorie des modèles.</p>
<h1 id="définitions">Définitions</h1>
<p>Nous commençons par expliquer ce que nous cherchons à capturer.
Imaginons une machine de Turing non déterministe qui peut explorer un
nombre exponentiel de configurations en parallèle. Nous voulons
formaliser la notion de problème qui peut être résolu par une telle
machine en utilisant un espace exponentiel. La classe NEXP capture
précisément cette idée.</p>
<div class="definition">
<p>Soit <span class="math inline">\(\Sigma\)</span> un alphabet fini. Un
problème de décision <span class="math inline">\(L \subseteq
\Sigma^*\)</span> appartient à la classe NEXP s’il existe une machine de
Turing non déterministe <span class="math inline">\(M\)</span>, un
polynôme <span class="math inline">\(p\)</span> et une constante <span
class="math inline">\(c &gt; 0\)</span> tels que pour tout mot <span
class="math inline">\(x \in \Sigma^*\)</span>:</p>
<p><span class="math display">\[x \in L \iff \exists y \in
\Sigma^{p(|x|)} \text{ tel que } M(x, y) \text{ s&#39;arrête en
acceptation et utilise au plus } 2^{c|x|} \text{ cellules de
bande.}\]</span></p>
<p>En d’autres termes, <span class="math inline">\(L \in
\text{NEXP}\)</span> si et seulement si:</p>
<p><span class="math display">\[L = \{ x \in \Sigma^* \mid \exists y \in
\Sigma^{p(|x|)} \text{ tel que } M(x, y) \text{ accepte et utilise au
plus } 2^{c|x|} \text{ cellules de bande} \}.\]</span></p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<p>Nous allons maintenant explorer un théorème fondamental concernant la
classe NEXP. Ce théorème établit une relation entre NEXP et d’autres
classes de complexité bien connues.</p>
<div class="theorem">
<p>Pour tout problème <span class="math inline">\(L \in
\text{NEXP}\)</span>, il existe une machine de Turing déterministe qui
résout <span class="math inline">\(L\)</span> en utilisant un espace
exponentiel. Plus formellement:</p>
<p><span class="math display">\[\text{NEXP} \subseteq
\text{EXPSPACE}.\]</span></p>
</div>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(L \in
\text{NEXP}\)</span>. Par définition, il existe une machine de Turing
non déterministe <span class="math inline">\(M\)</span>, un polynôme
<span class="math inline">\(p\)</span> et une constante <span
class="math inline">\(c &gt; 0\)</span> tels que pour tout mot <span
class="math inline">\(x \in \Sigma^*\)</span>:</p>
<p><span class="math display">\[x \in L \iff \exists y \in
\Sigma^{p(|x|)} \text{ tel que } M(x, y) \text{ s&#39;arrête en
acceptation et utilise au plus } 2^{c|x|} \text{ cellules de
bande.}\]</span></p>
<p>Nous allons construire une machine de Turing déterministe <span
class="math inline">\(M&#39;\)</span> qui simule <span
class="math inline">\(M\)</span> en utilisant un espace exponentiel. La
machine <span class="math inline">\(M&#39;\)</span> explore toutes les
configurations possibles de <span class="math inline">\(M\)</span> en
utilisant un espace de taille <span
class="math inline">\(2^{c|x|}\)</span>. Pour chaque configuration,
<span class="math inline">\(M&#39;\)</span> vérifie si elle mène à une
acceptation. Si une telle configuration est trouvée, <span
class="math inline">\(M&#39;\)</span> accepte; sinon, elle rejette.</p>
<p>Plus formellement, pour tout <span class="math inline">\(x \in
\Sigma^*\)</span>, la machine <span
class="math inline">\(M&#39;\)</span> effectue les étapes suivantes:</p>
<p>1. Pour chaque <span class="math inline">\(y \in
\Sigma^{p(|x|)}\)</span>: - Simule <span class="math inline">\(M(x,
y)\)</span> en utilisant un espace de taille <span
class="math inline">\(2^{c|x|}\)</span>. - Si <span
class="math inline">\(M(x, y)\)</span> accepte, alors <span
class="math inline">\(M&#39;\)</span> accepte. - Sinon, continue avec le
prochain <span class="math inline">\(y\)</span>.</p>
<p>2. Si aucune configuration n’accepte, <span
class="math inline">\(M&#39;\)</span> rejette.</p>
<p>Puisque <span class="math inline">\(M&#39;\)</span> explore toutes
les configurations possibles, elle utilise un espace de taille <span
class="math inline">\(2^{c|x|}\)</span>, ce qui est exponentiel en la
taille de l’entrée. Par conséquent, <span class="math inline">\(L \in
\text{EXPSPACE}\)</span>. ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<p>Nous allons maintenant fournir une preuve détaillée du théorème de
l’inclusion de NEXP dans EXPSPACE. Cette preuve repose sur la simulation
d’une machine non déterministe par une machine déterministe en utilisant
un espace exponentiel.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(L \in
\text{NEXP}\)</span>. Par définition, il existe une machine de Turing
non déterministe <span class="math inline">\(M\)</span>, un polynôme
<span class="math inline">\(p\)</span> et une constante <span
class="math inline">\(c &gt; 0\)</span> tels que pour tout mot <span
class="math inline">\(x \in \Sigma^*\)</span>:</p>
<p><span class="math display">\[x \in L \iff \exists y \in
\Sigma^{p(|x|)} \text{ tel que } M(x, y) \text{ s&#39;arrête en
acceptation et utilise au plus } 2^{c|x|} \text{ cellules de
bande.}\]</span></p>
<p>Nous allons construire une machine de Turing déterministe <span
class="math inline">\(M&#39;\)</span> qui simule <span
class="math inline">\(M\)</span> en utilisant un espace exponentiel. La
machine <span class="math inline">\(M&#39;\)</span> explore toutes les
configurations possibles de <span class="math inline">\(M\)</span> en
utilisant un espace de taille <span
class="math inline">\(2^{c|x|}\)</span>. Pour chaque configuration,
<span class="math inline">\(M&#39;\)</span> vérifie si elle mène à une
acceptation. Si une telle configuration est trouvée, <span
class="math inline">\(M&#39;\)</span> accepte; sinon, elle rejette.</p>
<p>Plus formellement, pour tout <span class="math inline">\(x \in
\Sigma^*\)</span>, la machine <span
class="math inline">\(M&#39;\)</span> effectue les étapes suivantes:</p>
<p>1. Pour chaque <span class="math inline">\(y \in
\Sigma^{p(|x|)}\)</span>: - Simule <span class="math inline">\(M(x,
y)\)</span> en utilisant un espace de taille <span
class="math inline">\(2^{c|x|}\)</span>. - Si <span
class="math inline">\(M(x, y)\)</span> accepte, alors <span
class="math inline">\(M&#39;\)</span> accepte. - Sinon, continue avec le
prochain <span class="math inline">\(y\)</span>.</p>
<p>2. Si aucune configuration n’accepte, <span
class="math inline">\(M&#39;\)</span> rejette.</p>
<p>Puisque <span class="math inline">\(M&#39;\)</span> explore toutes
les configurations possibles, elle utilise un espace de taille <span
class="math inline">\(2^{c|x|}\)</span>, ce qui est exponentiel en la
taille de l’entrée. Par conséquent, <span class="math inline">\(L \in
\text{EXPSPACE}\)</span>. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Nous allons maintenant énumérer quelques propriétés et corollaires
importants concernant la classe NEXP.</p>
<ol>
<li><p><strong>Propriété de fermeture sous complémentaire:</strong> La
classe NEXP est fermée sous complémentaire. Cela signifie que si un
problème <span class="math inline">\(L\)</span> appartient à NEXP, alors
son complémentaire <span class="math inline">\(\overline{L}\)</span>
appartient également à NEXP.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(L \in
\text{NEXP}\)</span>. Par définition, il existe une machine de Turing
non déterministe <span class="math inline">\(M\)</span>, un polynôme
<span class="math inline">\(p\)</span> et une constante <span
class="math inline">\(c &gt; 0\)</span> tels que pour tout mot <span
class="math inline">\(x \in \Sigma^*\)</span>:</p>
<p><span class="math display">\[x \in L \iff \exists y \in
\Sigma^{p(|x|)} \text{ tel que } M(x, y) \text{ s&#39;arrête en
acceptation et utilise au plus } 2^{c|x|} \text{ cellules de
bande.}\]</span></p>
<p>Nous allons construire une machine de Turing non déterministe <span
class="math inline">\(M&#39;\)</span> qui reconnaît le complémentaire de
<span class="math inline">\(L\)</span>. La machine <span
class="math inline">\(M&#39;\)</span> fonctionne comme suit:</p>
<p>1. Pour chaque <span class="math inline">\(y \in
\Sigma^{p(|x|)}\)</span>: - Simule <span class="math inline">\(M(x,
y)\)</span> en utilisant un espace de taille <span
class="math inline">\(2^{c|x|}\)</span>. - Si <span
class="math inline">\(M(x, y)\)</span> rejette, alors <span
class="math inline">\(M&#39;\)</span> accepte. - Sinon, continue avec le
prochain <span class="math inline">\(y\)</span>.</p>
<p>2. Si aucune configuration ne rejette, <span
class="math inline">\(M&#39;\)</span> rejette.</p>
<p>Puisque <span class="math inline">\(M&#39;\)</span> explore toutes
les configurations possibles, elle utilise un espace de taille <span
class="math inline">\(2^{c|x|}\)</span>, ce qui est exponentiel en la
taille de l’entrée. Par conséquent, <span
class="math inline">\(\overline{L} \in \text{NEXP}\)</span>. ◻</p>
</div></li>
<li><p><strong>Propriété de fermeture sous union:</strong> La classe
NEXP est fermée sous union. Cela signifie que si deux problèmes <span
class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span> appartiennent à NEXP, alors leur
union <span class="math inline">\(L_1 \cup L_2\)</span> appartient
également à NEXP.</p>
<div class="proof">
<p><em>Proof.</em> Soient <span class="math inline">\(L_1, L_2 \in
\text{NEXP}\)</span>. Par définition, il existe des machines de Turing
non déterministes <span class="math inline">\(M_1\)</span> et <span
class="math inline">\(M_2\)</span>, des polynômes <span
class="math inline">\(p_1\)</span> et <span
class="math inline">\(p_2\)</span> et des constantes <span
class="math inline">\(c_1, c_2 &gt; 0\)</span> tels que pour tout mot
<span class="math inline">\(x \in \Sigma^*\)</span>:</p>
<p><span class="math display">\[x \in L_1 \iff \exists y_1 \in
\Sigma^{p_1(|x|)} \text{ tel que } M_1(x, y_1) \text{ s&#39;arrête en
acceptation et utilise au plus } 2^{c_1|x|} \text{ cellules de
bande.}\]</span></p>
<p><span class="math display">\[x \in L_2 \iff \exists y_2 \in
\Sigma^{p_2(|x|)} \text{ tel que } M_2(x, y_2) \text{ s&#39;arrête en
acceptation et utilise au plus } 2^{c_2|x|} \text{ cellules de
bande.}\]</span></p>
<p>Nous allons construire une machine de Turing non déterministe <span
class="math inline">\(M\)</span> qui reconnaît l’union <span
class="math inline">\(L_1 \cup L_2\)</span>. La machine <span
class="math inline">\(M\)</span> fonctionne comme suit:</p>
<p>1. Pour chaque <span class="math inline">\(y_1 \in
\Sigma^{p_1(|x|)}\)</span>: - Simule <span class="math inline">\(M_1(x,
y_1)\)</span> en utilisant un espace de taille <span
class="math inline">\(2^{c_1|x|}\)</span>. - Si <span
class="math inline">\(M_1(x, y_1)\)</span> accepte, alors <span
class="math inline">\(M\)</span> accepte.</p>
<p>2. Pour chaque <span class="math inline">\(y_2 \in
\Sigma^{p_2(|x|)}\)</span>: - Simule <span class="math inline">\(M_2(x,
y_2)\)</span> en utilisant un espace de taille <span
class="math inline">\(2^{c_2|x|}\)</span>. - Si <span
class="math inline">\(M_2(x, y_2)\)</span> accepte, alors <span
class="math inline">\(M\)</span> accepte.</p>
<p>3. Si aucune des simulations n’accepte, <span
class="math inline">\(M\)</span> rejette.</p>
<p>Puisque <span class="math inline">\(M\)</span> explore toutes les
configurations possibles des deux machines, elle utilise un espace de
taille <span class="math inline">\(2^{\max(c_1, c_2)|x|}\)</span>, ce
qui est exponentiel en la taille de l’entrée. Par conséquent, <span
class="math inline">\(L_1 \cup L_2 \in \text{NEXP}\)</span>. ◻</p>
</div></li>
<li><p><strong>Propriété de fermeture sous intersection:</strong> La
classe NEXP est fermée sous intersection. Cela signifie que si deux
problèmes <span class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span> appartiennent à NEXP, alors leur
intersection <span class="math inline">\(L_1 \cap L_2\)</span>
appartient également à NEXP.</p>
<div class="proof">
<p><em>Proof.</em> Soient <span class="math inline">\(L_1, L_2 \in
\text{NEXP}\)</span>. Par définition, il existe des machines de Turing
non déterministes <span class="math inline">\(M_1\)</span> et <span
class="math inline">\(M_2\)</span>, des polynômes <span
class="math inline">\(p_1\)</span> et <span
class="math inline">\(p_2\)</span> et des constantes <span
class="math inline">\(c_1, c_2 &gt; 0\)</span> tels que pour tout mot
<span class="math inline">\(x \in \Sigma^*\)</span>:</p>
<p><span class="math display">\[x \in L_1 \iff \exists y_1 \in
\Sigma^{p_1(|x|)} \text{ tel que } M_1(x, y_1) \text{ s&#39;arrête en
acceptation et utilise au plus } 2^{c_1|x|} \text{ cellules de
bande.}\]</span></p>
<p><span class="math display">\[x \in L_2 \iff \exists y_2 \in
\Sigma^{p_2(|x|)} \text{ tel que } M_2(x, y_2) \text{ s&#39;arrête en
acceptation et utilise au plus } 2^{c_2|x|} \text{ cellules de
bande.}\]</span></p>
<p>Nous allons construire une machine de Turing non déterministe <span
class="math inline">\(M\)</span> qui reconnaît l’intersection <span
class="math inline">\(L_1 \cap L_2\)</span>. La machine <span
class="math inline">\(M\)</span> fonctionne comme suit:</p>
<p>1. Pour chaque <span class="math inline">\(y_1 \in
\Sigma^{p_1(|x|)}\)</span> et chaque <span class="math inline">\(y_2 \in
\Sigma^{p_2(|x|)}\)</span>: - Simule <span class="math inline">\(M_1(x,
y_1)\)</span> en utilisant un espace de taille <span
class="math inline">\(2^{c_1|x|}\)</span>. - Simule <span
class="math inline">\(M_2(x, y_2)\)</span> en utilisant un espace de
taille <span class="math inline">\(2^{c_2|x|}\)</span>. - Si <span
class="math inline">\(M_1(x, y_1)\)</span> et <span
class="math inline">\(M_2(x, y_2)\)</span> acceptent tous les deux,
alors <span class="math inline">\(M\)</span> accepte.</p>
<p>2. Si aucune des paires de configurations n’accepte, <span
class="math inline">\(M\)</span> rejette.</p>
<p>Puisque <span class="math inline">\(M\)</span> explore toutes les
paires de configurations possibles des deux machines, elle utilise un
espace de taille <span class="math inline">\(2^{\max(c_1,
c_2)|x|}\)</span>, ce qui est exponentiel en la taille de l’entrée. Par
conséquent, <span class="math inline">\(L_1 \cap L_2 \in
\text{NEXP}\)</span>. ◻</p>
</div></li>
</ol>
</body>
</html>
{% include "footer.html" %}

