{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes dans la classe co-NP</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title"><strong>Complexité des problèmes dans la classe
co-NP</strong></h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>La théorie de la complexité computationnelle est une branche
fondamentale des mathématiques et de l’informatique théorique. Elle
cherche à classer les problèmes en fonction de la difficulté des
ressources nécessaires pour les résoudre. Parmi les classes de
complexité les plus étudiées, on trouve NP et co-NP.</p>
<p>La classe NP est définie comme l’ensemble des problèmes pour lesquels
une solution proposée peut être vérifiée rapidement par une machine de
Turing non-déterministe. La classe co-NP, d’autre part, est définie
comme l’ensemble des problèmes dont les négations appartiennent à NP. En
d’autres termes, co-NP est la classe des problèmes pour lesquels une
non-solution peut être vérifiée rapidement.</p>
<p>L’étude de ces classes est cruciale car elle permet de mieux
comprendre les limites des algorithmes et la nature des problèmes
difficiles. De plus, la question de savoir si NP = co-NP est une
question ouverte majeure en théorie de la complexité, avec des
implications profondes pour l’informatique et les mathématiques.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour comprendre la complexité des problèmes dans la classe co-NP, il
est essentiel de définir d’abord les concepts fondamentaux.</p>
<h2 class="unnumbered" id="problème-de-décision">Problème de
décision</h2>
<p>Un problème de décision est un problème qui peut être posé sous la
forme d’une question à laquelle on répond par oui ou non. Par exemple,
le problème de la satisfiabilité booléenne (SAT) consiste à déterminer
si une formule booléenne donnée est satisfiable.</p>
<h2 class="unnumbered" id="machine-de-turing-non-déterministe">Machine
de Turing non-déterministe</h2>
<p>Une machine de Turing non-déterministe est une variante d’une machine
de Turing qui, à chaque étape, peut choisir parmi plusieurs actions
possibles. Elle est définie par un ensemble d’états, un alphabet de
bande, une fonction de transition et un état initial.</p>
<h2 class="unnumbered" id="classe-np">Classe NP</h2>
<p>La classe NP est définie comme l’ensemble des problèmes de décision
pour lesquels une solution proposée peut être vérifiée rapidement par
une machine de Turing non-déterministe. Formellement, un problème <span
class="math inline">\(L\)</span> appartient à NP si et seulement s’il
existe une machine de Turing non-déterministe <span
class="math inline">\(M\)</span> qui, pour toute entrée <span
class="math inline">\(x\)</span>, accepte <span
class="math inline">\(x\)</span> en temps polynomial si et seulement si
<span class="math inline">\(x \in L\)</span>.</p>
<p><span class="math display">\[L \in \text{NP} \iff \exists M, \forall
x \in L, M(x) \text{ accepte en temps polynomial}\]</span></p>
<h2 class="unnumbered" id="classe-co-np">Classe co-NP</h2>
<p>La classe co-NP est définie comme l’ensemble des problèmes de
décision dont les négations appartiennent à NP. Formellement, un
problème <span class="math inline">\(L\)</span> appartient à co-NP si et
seulement si sa négation <span
class="math inline">\(\overline{L}\)</span> appartient à NP.</p>
<p><span class="math display">\[L \in \text{co-NP} \iff \overline{L} \in
\text{NP}\]</span></p>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<h2 class="unnumbered" id="théorème-de-savitch">Théorème de Savitch</h2>
<p>Le théorème de Savitch est un résultat fondamental en théorie de la
complexité qui relie les classes de complexité non-déterministe et
déterministe. Il stipule que l’espace non-déterministe est fermé sous
complémentation.</p>
<h3 class="unnumbered" id="énoncé-du-théorème">Énoncé du théorème</h3>
<p>Soit <span class="math inline">\(L\)</span> un langage qui peut être
reconnu par une machine de Turing non-déterministe en utilisant <span
class="math inline">\(s(n)\)</span> espace. Alors, il existe une machine
de Turing déterministe qui reconnaît le complément <span
class="math inline">\(\overline{L}\)</span> en utilisant <span
class="math inline">\(s(n)^2\)</span> espace.</p>
<p><span class="math display">\[\text{Si } L \in \text{NSPACE}(s(n)),
\text{ alors } \overline{L} \in \text{DSPACE}(s(n)^2)\]</span></p>
<h3 class="unnumbered" id="preuve-du-théorème">Preuve du théorème</h3>
<p>La preuve du théorème de Savitch repose sur la simulation d’une
machine de Turing non-déterministe par une machine déterministe. L’idée
est de construire un arbre de recherche pour explorer toutes les
possibilités non-déterministes.</p>
<h1 class="unnumbered" id="preuves">Preuves</h1>
<h2 class="unnumbered" id="preuve-de-lappartenance-de-sat-à-np">Preuve
de l’appartenance de SAT à NP</h2>
<p>Pour montrer que le problème de la satisfiabilité booléenne (SAT)
appartient à NP, nous devons démontrer qu’une solution proposée peut
être vérifiée rapidement par une machine de Turing non-déterministe.</p>
<h3 class="unnumbered" id="preuve">Preuve</h3>
<p>Soit <span class="math inline">\(\phi\)</span> une formule booléenne
et <span class="math inline">\(s\)</span> un ensemble d’affectations de
variables. Nous devons vérifier si <span
class="math inline">\(s\)</span> satisfait <span
class="math inline">\(\phi\)</span>.</p>
<p>1. Pour chaque variable <span class="math inline">\(x_i\)</span> dans
<span class="math inline">\(\phi\)</span>, vérifiez si l’affectation de
<span class="math inline">\(s\)</span> est cohérente. 2. Pour chaque
clause dans <span class="math inline">\(\phi\)</span>, vérifiez si au
moins une des littéraux est vraie sous l’affectation <span
class="math inline">\(s\)</span>.</p>
<p>Si toutes les clauses sont satisfaites, alors <span
class="math inline">\(s\)</span> est une solution valide pour SAT.</p>
<p><span class="math display">\[\forall x_i \in \phi, s(x_i) \text{ est
cohérent}\]</span> <span class="math display">\[\forall c_j \in \phi,
\exists l_k \in c_j \text{ tel que } s(l_k) = 1\]</span></p>
<h2 class="unnumbered"
id="preuve-de-lappartenance-de-co-sat-à-np">Preuve de l’appartenance de
co-SAT à NP</h2>
<p>Pour montrer que le problème de la non-satisfiabilité booléenne
(co-SAT) appartient à NP, nous devons démontrer que la négation de SAT
appartient à NP.</p>
<h3 class="unnumbered" id="preuve-1">Preuve</h3>
<p>Soit <span class="math inline">\(\phi\)</span> une formule booléenne
et <span class="math inline">\(s\)</span> un ensemble d’affectations de
variables. Nous devons vérifier si <span
class="math inline">\(s\)</span> ne satisfait pas <span
class="math inline">\(\phi\)</span>.</p>
<p>1. Pour chaque variable <span class="math inline">\(x_i\)</span> dans
<span class="math inline">\(\phi\)</span>, vérifiez si l’affectation de
<span class="math inline">\(s\)</span> est cohérente. 2. Pour chaque
clause dans <span class="math inline">\(\phi\)</span>, vérifiez si tous
les littéraux sont faux sous l’affectation <span
class="math inline">\(s\)</span>.</p>
<p>Si toutes les clauses sont non-satisfaites, alors <span
class="math inline">\(s\)</span> est une solution valide pour
co-SAT.</p>
<p><span class="math display">\[\forall x_i \in \phi, s(x_i) \text{ est
cohérent}\]</span> <span class="math display">\[\forall c_j \in \phi,
\forall l_k \in c_j \text{ tel que } s(l_k) = 0\]</span></p>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<h2 class="unnumbered"
id="propriété-i-fermeture-sous-complémentation">Propriété (i) :
Fermeture sous complémentation</h2>
<p>La classe co-NP est fermée sous complémentation. Cela signifie que si
un problème <span class="math inline">\(L\)</span> appartient à co-NP,
alors son complément <span class="math inline">\(\overline{L}\)</span>
appartient également à co-NP.</p>
<h3 class="unnumbered" id="preuve-2">Preuve</h3>
<p>Soit <span class="math inline">\(L \in \text{co-NP}\)</span>. Par
définition, <span class="math inline">\(\overline{L} \in
\text{NP}\)</span>. Puisque NP est fermé sous complémentation, <span
class="math inline">\(L = \overline{\overline{L}} \in
\text{NP}\)</span>. Cependant, cela ne montre pas directement que co-NP
est fermé sous complémentation.</p>
<p>Pour montrer la fermeture de co-NP sous complémentation, nous devons
démontrer que si <span class="math inline">\(L \in
\text{co-NP}\)</span>, alors <span class="math inline">\(\overline{L}
\in \text{NP}\)</span>. Cela découle directement de la définition de
co-NP.</p>
<p><span class="math display">\[L \in \text{co-NP} \iff \overline{L} \in
\text{NP}\]</span></p>
<h2 class="unnumbered" id="propriété-ii-relation-avec-np">Propriété (ii)
: Relation avec NP</h2>
<p>La classe co-NP est en relation étroite avec la classe NP. En
particulier, si NP = co-NP, alors le problème P vs NP serait résolu.</p>
<h3 class="unnumbered" id="preuve-3">Preuve</h3>
<p>Supposons que NP = co-NP. Alors, pour tout problème <span
class="math inline">\(L \in \text{NP}\)</span>, sa négation <span
class="math inline">\(\overline{L}\)</span> appartient également à NP.
Cela implique que les problèmes dans NP peuvent être résolus en temps
polynomial si et seulement si leur négation peut être vérifiée
rapidement.</p>
<p>Cependant, il est important de noter que l’égalité NP = co-NP
n’implique pas nécessairement que P = NP. Il reste une question ouverte
majeure en théorie de la complexité.</p>
<h2 class="unnumbered"
id="propriété-iii-exemples-de-problèmes-dans-co-np">Propriété (iii) :
Exemples de problèmes dans co-NP</h2>
<p>Plusieurs problèmes importants appartiennent à la classe co-NP. Par
exemple, le problème de l’indépendance (IND) et le problème du chemin
hamiltonien (HAM) sont des exemples de problèmes dans co-NP.</p>
<h3 class="unnumbered" id="preuve-4">Preuve</h3>
<p>Pour le problème de l’indépendance (IND), nous devons vérifier si un
graphe donné ne contient pas d’ensemble indépendant de taille donnée.
Cela peut être fait en vérifiant que pour tout ensemble de sommets, il
existe au moins une arête entre eux.</p>
<p>Pour le problème du chemin hamiltonien (HAM), nous devons vérifier si
un graphe donné ne contient pas de chemin hamiltonien. Cela peut être
fait en vérifiant que pour tout ordre des sommets, il existe au moins
une arête manquante.</p>
<p><span class="math display">\[\forall S \subseteq V, |S| = k, \exists
(u, v) \in E \text{ tel que } u, v \in S\]</span> <span
class="math display">\[\forall \pi \text{ permutation de } V, \exists
(u, v) \notin E \text{ tel que } u = \pi(i), v = \pi(i+1)\]</span></p>
</body>
</html>
{% include "footer.html" %}

