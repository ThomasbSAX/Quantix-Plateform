{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>L’Encodage Médian : Un Outil Puissant en Informatique Théorique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">L’Encodage Médian : Un Outil Puissant en Informatique
Théorique</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>L’encodage médian est une technique fondamentale en informatique
théorique, particulièrement dans les domaines de la compression de
données et de l’analyse des séquences. Cette méthode trouve ses racines
dans les travaux sur les codes à longueur variable et les arbres
binaires de recherche. L’émergence de l’encodage médian est motivée par
le besoin de représenter efficacement des données ordonnées, tout en
minimisant l’espace de stockage et en optimisant les temps d’accès. Dans
ce contexte, l’encodage médian se révèle indispensable pour traiter des
séquences de données où les valeurs sont triées ou partiellement triées,
comme dans les bases de données ou les systèmes de fichiers.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour comprendre l’encodage médian, commençons par définir ce que nous
cherchons à obtenir. Supposons que nous ayons une séquence de nombres
triés <span class="math inline">\(S = (s_1, s_2, \ldots, s_n)\)</span>.
Notre objectif est de représenter cette séquence de manière compacte en
utilisant un code qui exploite l’ordre des éléments. L’idée est
d’utiliser une valeur médiane pour diviser la séquence en deux
sous-séquences, puis de répéter le processus récursivement.</p>
<p>Formellement, l’encodage médian peut être défini comme suit :</p>
<div class="definition">
<p>Soit <span class="math inline">\(S = (s_1, s_2, \ldots, s_n)\)</span>
une séquence de nombres triés. L’encodage médian de <span
class="math inline">\(S\)</span> est défini récursivement par :</p>
<ul>
<li><p>Si <span class="math inline">\(n = 1\)</span>, alors l’encodage
est simplement la valeur <span
class="math inline">\(s_1\)</span>.</p></li>
<li><p>Sinon, choisissons un élément médian <span
class="math inline">\(m\)</span> de la séquence <span
class="math inline">\(S\)</span>. L’encodage est alors donné par : <span
class="math display">\[E(S) = (m, E(L), E(R))\]</span> où <span
class="math inline">\(L\)</span> est la sous-séquence des éléments
inférieurs à <span class="math inline">\(m\)</span>, et <span
class="math inline">\(R\)</span> est la sous-séquence des éléments
supérieurs à <span class="math inline">\(m\)</span>.</p></li>
</ul>
</div>
<p>Une autre manière de formuler cette définition est la suivante :</p>
<div class="definition">
<p>Pour une séquence triée <span class="math inline">\(S = (s_1, s_2,
\ldots, s_n)\)</span>, l’encodage médian <span
class="math inline">\(E(S)\)</span> est défini par : <span
class="math display">\[E(S) =
\begin{cases}
s_1 &amp; \text{si } n = 1, \\
(m, E(L), E(R)) &amp; \text{sinon},
\end{cases}\]</span> où <span class="math inline">\(m\)</span> est le
médian de <span class="math inline">\(S\)</span>, <span
class="math inline">\(L = \{ s_i \mid s_i &lt; m \}\)</span>, et <span
class="math inline">\(R = \{ s_i \mid s_i &gt; m \}\)</span>.</p>
</div>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<p>Un théorème fondamental lié à l’encodage médian est le suivant :</p>
<div class="theorem">
<p>Soit <span class="math inline">\(S\)</span> une séquence de nombres
triés. L’encodage médian <span class="math inline">\(E(S)\)</span> est
unique et minimal en termes de nombre de bits nécessaires pour
représenter la séquence.</p>
</div>
<p>Pour comprendre ce théorème, commençons par expliquer ce que nous
cherchons à obtenir. Nous voulons montrer que l’encodage médian est
unique et minimal. L’unicité découle du fait que le choix du médian est
bien défini, et la minimalité vient de l’efficacité de la division
récursive de la séquence.</p>
<p>Formellement, le théorème peut être démontré comme suit :</p>
<div class="proof">
<p><em>Proof.</em> Nous procédons par induction sur la longueur de la
séquence <span class="math inline">\(S\)</span>.</p>
<p><strong>Cas de base :</strong> Si <span class="math inline">\(n =
1\)</span>, alors <span class="math inline">\(E(S) = s_1\)</span>, qui
est clairement unique et minimal.</p>
<p><strong>Étape d’induction :</strong> Supposons que le théorème soit
vrai pour toutes les séquences de longueur inférieure à <span
class="math inline">\(n\)</span>. Considérons une séquence <span
class="math inline">\(S\)</span> de longueur <span
class="math inline">\(n\)</span>. Choisissons un médian <span
class="math inline">\(m\)</span> de <span
class="math inline">\(S\)</span>. Par définition, <span
class="math inline">\(E(S) = (m, E(L), E(R))\)</span>.</p>
<p>Par l’hypothèse d’induction, <span
class="math inline">\(E(L)\)</span> et <span
class="math inline">\(E(R)\)</span> sont uniques et minimaux. Par
conséquent, <span class="math inline">\(E(S)\)</span> est également
unique et minimal. ◻</p>
</div>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<p>Nous listons maintenant quelques propriétés importantes de l’encodage
médian :</p>
<ol>
<li><p><strong>Propriété de Minimalité :</strong> L’encodage médian est
minimal en termes de nombre de bits nécessaires pour représenter une
séquence triée.</p>
<div class="proof">
<p><em>Proof.</em> Cette propriété découle directement du théorème de
l’encodage médian. En effet, le théorème garantit que l’encodage est
minimal. ◻</p>
</div></li>
<li><p><strong>Propriété de Réversibilité :</strong> L’encodage médian
est réversible, c’est-à-dire qu’il est possible de reconstruire la
séquence originale à partir de son encodage.</p>
<div class="proof">
<p><em>Proof.</em> La réversibilité peut être démontrée par récurrence.
Pour une séquence de longueur 1, la reconstruction est triviale. Pour
une séquence de longueur <span class="math inline">\(n\)</span>, nous
pouvons reconstruire les sous-séquences <span
class="math inline">\(L\)</span> et <span
class="math inline">\(R\)</span> à partir de leur encodage, puis
combiner ces sous-séquences avec le médian <span
class="math inline">\(m\)</span> pour obtenir la séquence
originale. ◻</p>
</div></li>
<li><p><strong>Propriété de Complexité :</strong> Le temps nécessaire
pour encoder une séquence à l’aide de l’encodage médian est <span
class="math inline">\(O(n \log n)\)</span>, où <span
class="math inline">\(n\)</span> est la longueur de la séquence.</p>
<div class="proof">
<p><em>Proof.</em> Cette propriété découle du fait que le tri d’une
séquence prend <span class="math inline">\(O(n \log n)\)</span> temps,
et que chaque étape de l’encodage médian nécessite un tri partiel des
sous-séquences. ◻</p>
</div></li>
</ol>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>L’encodage médian est un outil puissant et élégant pour la
compression de données ordonnées. Ses propriétés de minimalité, de
réversibilité et de complexité en font une technique indispensable dans
de nombreux domaines de l’informatique théorique. En comprenant les
définitions, les théorèmes et les propriétés associées à l’encodage
médian, nous pouvons mieux apprécier son importance et ses applications
pratiques.</p>
</body>
</html>
{% include "footer.html" %}

