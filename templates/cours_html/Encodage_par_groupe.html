{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>L’Encodage par Groupe : Une Approche Algébrique de la Théorie de l’Information</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">L’Encodage par Groupe : Une Approche Algébrique de la
Théorie de l’Information</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>L’encodage par groupe, une notion fondamentale en théorie de
l’information et en algèbre, émerge comme une réponse élégante aux défis
posés par la transmission et le stockage de l’information.
Historiquement, cette approche trouve ses racines dans les travaux
pionniers de Claude Shannon sur la théorie de l’information et dans le
développement des structures algébriques par les mathématiciens du XXe
siècle. L’encodage par groupe est indispensable dans le cadre des
systèmes de communication modernes, où la fiabilité et l’efficacité sont
primordiales. Il permet non seulement de détecter mais aussi de corriger
les erreurs introduites lors de la transmission, en exploitant les
propriétés riches des structures algébriques.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour comprendre l’encodage par groupe, commençons par explorer les
concepts clés. Supposons que nous souhaitons transmettre un message à
travers un canal bruité. Notre objectif est de représenter ce message
sous une forme qui permette de détecter et de corriger les erreurs
éventuelles. Pour cela, nous cherchons une structure mathématique
capable de capturer les relations entre les messages et leurs
représentations codées.</p>
<div class="definition">
<p>Un groupe <span class="math inline">\((G, *)\)</span> est un ensemble
<span class="math inline">\(G\)</span> muni d’une opération binaire
<span class="math inline">\(*\)</span> qui satisfait les propriétés
suivantes :</p>
<ul>
<li><p><strong>Associativité</strong> : Pour tous <span
class="math inline">\(a, b, c \in G\)</span>, <span
class="math inline">\((a * b) * c = a * (b * c)\)</span>.</p></li>
<li><p><strong>Élement neutre</strong> : Il existe un élément <span
class="math inline">\(e \in G\)</span> tel que pour tout <span
class="math inline">\(a \in G\)</span>, <span class="math inline">\(e *
a = a * e = a\)</span>.</p></li>
<li><p><strong>Inverse</strong> : Pour tout <span
class="math inline">\(a \in G\)</span>, il existe un élément <span
class="math inline">\(b \in G\)</span> tel que <span
class="math inline">\(a * b = b * a = e\)</span>.</p></li>
</ul>
</div>
<div class="definition">
<p>Un code linéaire <span class="math inline">\(C\)</span> de longueur
<span class="math inline">\(n\)</span> sur un corps fini <span
class="math inline">\(\mathbb{F}_q\)</span> est un sous-espace vectoriel
de <span class="math inline">\(\mathbb{F}_q^n\)</span>. Les éléments de
<span class="math inline">\(C\)</span> sont appelés mots de code.</p>
</div>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<p>Un des théorèmes fondamentaux en théorie de l’encodage par groupe est
le théorème de Hamming, qui établit une limite sur la capacité des codes
à détecter et corriger les erreurs.</p>
<div class="theoreme">
<p>Soit <span class="math inline">\(C\)</span> un code linéaire de
longueur <span class="math inline">\(n\)</span> sur <span
class="math inline">\(\mathbb{F}_q\)</span> avec <span
class="math inline">\(k\)</span> mots de code. Le nombre maximum
d’erreurs détectables est donné par : <span
class="math display">\[d_{\text{min}} - 1 \geq t\]</span> où <span
class="math inline">\(d_{\text{min}}\)</span> est la distance minimale
de Hamming du code et <span class="math inline">\(t\)</span> est le
nombre d’erreurs détectables.</p>
</div>
<h1 class="unnumbered" id="preuves">Preuves</h1>
<p>Pour démontrer le théorème de Hamming, nous devons d’abord comprendre
la notion de distance de Hamming. La distance de Hamming entre deux mots
de code <span class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span> est le nombre de positions où les
symboles diffèrent.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(C\)</span> un code
linéaire avec une distance minimale de Hamming <span
class="math inline">\(d_{\text{min}}\)</span>. Supposons que le code
puisse détecter jusqu’à <span class="math inline">\(t\)</span> erreurs.
Cela signifie que pour tout mot de code <span class="math inline">\(x
\in C\)</span>, tout mot reçu <span class="math inline">\(y\)</span> qui
diffère de <span class="math inline">\(x\)</span> par au plus <span
class="math inline">\(t\)</span> erreurs doit être détecté comme
tel.</p>
<p>Considérons deux mots de code distincts <span
class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span>. La distance de Hamming entre <span
class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span> est donnée par : <span
class="math display">\[d_H(x, y) = |\{i \mid x_i \neq
y_i\}|.\]</span></p>
<p>Si <span class="math inline">\(d_H(x, y) \leq t\)</span>, alors il
existe un mot reçu <span class="math inline">\(z\)</span> qui diffère de
<span class="math inline">\(x\)</span> par au plus <span
class="math inline">\(t\)</span> erreurs et qui est également à distance
<span class="math inline">\(\leq t\)</span> de <span
class="math inline">\(y\)</span>. Cela signifie que le code ne peut pas
distinguer entre <span class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span>, ce qui contredit l’hypothèse que le
code peut détecter jusqu’à <span class="math inline">\(t\)</span>
erreurs. Par conséquent, nous devons avoir : <span
class="math display">\[d_{\text{min}} - 1 \geq t.\]</span> ◻</p>
</div>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<p>L’encodage par groupe possède plusieurs propriétés intéressantes qui
en font un outil puissant pour la théorie de l’information.</p>
<div class="corollaire">
<p>Un code est dit parfait s’il atteint la borne de Hamming. Cela
signifie que le nombre de mots de code est exactement égal au nombre de
sphères d’erreurs disjointes dans l’espace des mots reçus.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(C\)</span> un code
linéaire avec une distance minimale de Hamming <span
class="math inline">\(d_{\text{min}}\)</span>. Le nombre de sphères
d’erreurs disjointes est donné par : <span
class="math display">\[\frac{q^n}{\sum_{i=0}^t \binom{n}{i}
(q-1)^i}.\]</span> Si le code est parfait, alors le nombre de mots de
code est égal à ce nombre. Par conséquent, nous avons : <span
class="math display">\[|C| = \frac{q^n}{\sum_{i=0}^t \binom{n}{i}
(q-1)^i}.\]</span> ◻</p>
</div>
<div class="corollaire">
<p>Un code cyclique est un code linéaire où chaque décalage circulaire
d’un mot de code donne un autre mot de code. Les codes cycliques sont
particulièrement efficaces pour la détection et la correction
d’erreurs.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(C\)</span> un code
cyclique de longueur <span class="math inline">\(n\)</span> sur <span
class="math inline">\(\mathbb{F}_q\)</span>. Pour tout mot de code <span
class="math inline">\(x \in C\)</span>, le décalage circulaire de <span
class="math inline">\(x\)</span> est également dans <span
class="math inline">\(C\)</span>. Cela signifie que pour tout vecteur de
décalage <span class="math inline">\(s\)</span>, le mot de code <span
class="math inline">\(x_s\)</span> est dans <span
class="math inline">\(C\)</span>, où <span
class="math inline">\(x_s\)</span> est défini par : <span
class="math display">\[(x_s)_i = x_{(i+s) \mod n}.\]</span> ◻</p>
</div>
<p>En conclusion, l’encodage par groupe est une approche puissante et
élégante pour la théorie de l’information. En exploitant les propriétés
riches des structures algébriques, il permet de détecter et corriger
efficacement les erreurs dans les systèmes de communication
modernes.</p>
</body>
</html>
{% include "footer.html" %}

