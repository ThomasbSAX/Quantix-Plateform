{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Norme trace : Une exploration mathématique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Norme trace : Une exploration mathématique</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>La norme trace, une notion fondamentale en analyse fonctionnelle et
en théorie des opérateurs, émerge naturellement dans l’étude des espaces
de Hilbert et des opérateurs compacts. Son importance réside dans sa
capacité à quantifier la complexité d’un opérateur linéaire en termes de
ses valeurs propres. Historiquement, cette norme a été introduite pour
généraliser les concepts classiques de normes vectorielles aux
opérateurs linéaires, permettant ainsi une analyse plus fine des
propriétés spectrales.</p>
<p>Dans ce chapitre, nous explorerons la norme trace à travers ses
définitions, ses théorèmes clés et ses applications. Nous verrons
comment cette norme permet de mesurer la taille d’un opérateur en
fonction de ses valeurs propres, et comment elle joue un rôle crucial
dans l’étude des opérateurs compacts et des espaces de Hilbert.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour comprendre la norme trace, commençons par rappeler quelques
concepts préliminaires. Considérons un espace de Hilbert <span
class="math inline">\(\mathcal{H}\)</span> et un opérateur compact <span
class="math inline">\(T\)</span> sur cet espace. Un opérateur compact
est un opérateur linéaire continu qui envoie les boules fermées de <span
class="math inline">\(\mathcal{H}\)</span> sur des ensembles
relativement compacts.</p>
<p>Supposons que <span class="math inline">\(T\)</span> ait un spectre
discret, c’est-à-dire que ses valeurs propres sont isolées et de
multiplicité finie. Nous pouvons alors lister les valeurs propres de
<span class="math inline">\(T\)</span> en tenant compte de leur
multiplicité algébrique : <span class="math inline">\(\lambda_1,
\lambda_2, \ldots\)</span>.</p>
<p>La norme trace de <span class="math inline">\(T\)</span>, notée <span
class="math inline">\(\|T\|_1\)</span>, est définie comme la somme des
valeurs absolues de ses valeurs propres. Formellement, nous avons :</p>
<p><span class="math display">\[\|T\|_1 = \sum_{k=1}^{\infty}
|\lambda_k|\]</span></p>
<p>où <span class="math inline">\(\lambda_k\)</span> sont les valeurs
propres de <span class="math inline">\(T\)</span>, ordonnées par ordre
décroissant de leur module.</p>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<p>Un théorème fondamental concernant la norme trace est le suivant
:</p>
<div class="theorem">
<p>Soit <span class="math inline">\(T\)</span> un opérateur compact sur
un espace de Hilbert <span class="math inline">\(\mathcal{H}\)</span>.
Alors, pour tout opérateur borné <span class="math inline">\(S\)</span>
sur <span class="math inline">\(\mathcal{H}\)</span>, nous avons
l’inégalité :</p>
<p><span class="math display">\[\|ST\|_1 \leq \|S\| \|T\|_1\]</span></p>
<p>où <span class="math inline">\(\|S\|\)</span> désigne la norme
d’opérateur de <span class="math inline">\(S\)</span>.</p>
</div>
<p>La démonstration de ce théorème repose sur les propriétés des valeurs
propres et des inégalités classiques. Nous allons maintenant détailler
cette démonstration.</p>
<h1 class="unnumbered" id="preuves">Preuves</h1>
<p>Pour démontrer l’inégalité de Hölder pour les opérateurs, nous
procédons comme suit :</p>
<p>1. **Décomposition spectrale** : Considérons la décomposition
spectrale de <span class="math inline">\(T\)</span>. Nous pouvons écrire
<span class="math inline">\(T\)</span> sous la forme :</p>
<p><span class="math display">\[T = \sum_{k=1}^{\infty} \lambda_k
P_k\]</span></p>
<p>où <span class="math inline">\(P_k\)</span> sont les projecteurs sur
les sous-espaces propres associés aux valeurs propres <span
class="math inline">\(\lambda_k\)</span>.</p>
<p>2. **Application de l’opérateur <span
class="math inline">\(S\)</span>** : Appliquons maintenant l’opérateur
<span class="math inline">\(S\)</span> à <span
class="math inline">\(T\)</span>. Nous obtenons :</p>
<p><span class="math display">\[ST = \sum_{k=1}^{\infty} \lambda_k S
P_k\]</span></p>
<p>3. **Norme trace de <span class="math inline">\(ST\)</span>** : La
norme trace de <span class="math inline">\(ST\)</span> est donnée par
:</p>
<p><span class="math display">\[\|ST\|_1 = \sum_{k=1}^{\infty}
|\lambda_k| \|S P_k\|\]</span></p>
<p>4. **Inégalité de Hölder** : En utilisant l’inégalité de Hölder, nous
avons :</p>
<p><span class="math display">\[\sum_{k=1}^{\infty} |\lambda_k| \|S
P_k\| \leq \left( \sum_{k=1}^{\infty} |\lambda_k|^p \right)^{1/p} \left(
\sum_{k=1}^{\infty} \|S P_k\|^q \right)^{1/q}\]</span></p>
<p>où <span class="math inline">\(p\)</span> et <span
class="math inline">\(q\)</span> sont des conjugués de Hölder,
c’est-à-dire <span class="math inline">\(\frac{1}{p} + \frac{1}{q} =
1\)</span>.</p>
<p>5. **Simplification** : En choisissant <span class="math inline">\(p
= 1\)</span> et <span class="math inline">\(q = \infty\)</span>, nous
obtenons :</p>
<p><span class="math display">\[\|ST\|_1 \leq \|S\|_{\infty}
\sum_{k=1}^{\infty} |\lambda_k| = \|S\| \|T\|_1\]</span></p>
<p>où <span class="math inline">\(\|S\|_{\infty}\)</span> désigne la
norme essentielle supérieure de <span class="math inline">\(S\)</span>,
qui est égale à sa norme d’opérateur.</p>
<p>Ainsi, nous avons démontré l’inégalité de Hölder pour les
opérateurs.</p>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<p>La norme trace possède plusieurs propriétés intéressantes, que nous
allons maintenant énumérer et démontrer.</p>
<ol>
<li><p>**Subadditivité** : La norme trace est subadditive. Cela signifie
que pour tout opérateur compact <span class="math inline">\(T\)</span>
et <span class="math inline">\(S\)</span>, nous avons :</p>
<p><span class="math display">\[\|T + S\|_1 \leq \|T\|_1 +
\|S\|_1\]</span></p>
<p>La démonstration de cette propriété repose sur l’inégalité
triangulaire pour les valeurs propres.</p></li>
<li><p>**Homogénéité** : La norme trace est homogène. Pour tout
opérateur compact <span class="math inline">\(T\)</span> et tout
scalaire <span class="math inline">\(\alpha\)</span>, nous avons :</p>
<p><span class="math display">\[\|\alpha T\|_1 = |\alpha|
\|T\|_1\]</span></p>
<p>Cette propriété découle directement de la définition de la norme
trace.</p></li>
<li><p>**Invariance par isométrie** : La norme trace est invariante par
isométrie. Cela signifie que pour tout opérateur unitaire <span
class="math inline">\(U\)</span> et tout opérateur compact <span
class="math inline">\(T\)</span>, nous avons :</p>
<p><span class="math display">\[\|UT\|_1 = \|TU\|_1 =
\|T\|_1\]</span></p>
<p>La démonstration de cette propriété repose sur le fait que les
valeurs propres d’un opérateur sont invariantes par conjugaison
unitaire.</p></li>
</ol>
<p>En conclusion, la norme trace est une notion puissante et élégante
qui joue un rôle central dans l’étude des opérateurs compacts et des
espaces de Hilbert. Ses propriétés et ses applications en font un outil
indispensable pour les mathématiciens travaillant dans ces domaines.</p>
</body>
</html>
{% include "footer.html" %}

