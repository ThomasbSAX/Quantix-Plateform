{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes dans la classe RP</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title"><strong>Complexité des problèmes dans la classe
RP</strong></h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>La théorie de la complexité computationnelle est un pilier
fondamental de l’informatique théorique. Elle permet de classer les
problèmes en fonction des ressources nécessaires pour les résoudre,
telles que le temps et l’espace. Parmi les classes de complexité les
plus étudiées, on trouve la classe RP (Randomized Polynomial-time), qui
représente l’ensemble des problèmes pour lesquels une solution peut être
trouvée rapidement avec une certaine probabilité d’erreur.</p>
<p>L’émergence de la classe RP est motivée par le besoin de modéliser
des algorithmes probabilistes qui peuvent résoudre certains problèmes
plus efficacement que les algorithmes déterministes. Ces algorithmes
utilisent des mécanismes de hasard pour accélérer le processus de
résolution, tout en garantissant une faible probabilité d’erreur. La
classe RP est indispensable pour comprendre les limites et les
possibilités des algorithmes probabilistes, ainsi que leur relation avec
d’autres classes de complexité comme P et NP.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour définir la classe RP, commençons par comprendre ce que nous
cherchons à modéliser. Imaginons un algorithme qui, grâce à une certaine
dose de hasard, peut résoudre un problème rapidement. Cependant, il
existe une petite probabilité que l’algorithme donne une réponse
erronée. Nous voulons capturer cette idée formellement.</p>
<div class="definition">
<p>Soit <span class="math inline">\(L\)</span> un langage. On dit que
<span class="math inline">\(L \in \text{RP}\)</span> s’il existe une
machine de Turing probabiliste <span class="math inline">\(M\)</span> et
un polynôme <span class="math inline">\(p\)</span> tels que pour toute
entrée <span class="math inline">\(x \in L\)</span>, la probabilité que
<span class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> est au moins <span
class="math inline">\(\frac{1}{2}\)</span>, et pour toute entrée <span
class="math inline">\(x \notin L\)</span>, la probabilité que <span
class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> est strictement inférieure à <span
class="math inline">\(\frac{1}{2}\)</span>. En d’autres termes, il
existe <span class="math inline">\(M\)</span> et <span
class="math inline">\(p\)</span> tels que : <span
class="math display">\[\forall x \in L, \quad P[M(x) = 1] \geq
\frac{1}{2}\]</span> <span class="math display">\[\forall x \notin L,
\quad P[M(x) = 1] &lt; \frac{1}{2}\]</span></p>
</div>
<p>Une autre formulation équivalente est la suivante : un langage <span
class="math inline">\(L\)</span> appartient à RP si et seulement s’il
existe une machine de Turing probabiliste <span
class="math inline">\(M\)</span> et un polynôme <span
class="math inline">\(p\)</span> tels que pour toute entrée <span
class="math inline">\(x \in L\)</span>, la probabilité que <span
class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> est au moins <span
class="math inline">\(\frac{2}{3}\)</span>, et pour toute entrée <span
class="math inline">\(x \notin L\)</span>, la probabilité que <span
class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> est strictement inférieure à <span
class="math inline">\(\frac{1}{3}\)</span>. En d’autres termes : <span
class="math display">\[\forall x \in L, \quad P[M(x) = 1] \geq
\frac{2}{3}\]</span> <span class="math display">\[\forall x \notin L,
\quad P[M(x) = 1] &lt; \frac{1}{3}\]</span></p>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<p>Un théorème fondamental concernant la classe RP est le suivant :</p>
<div class="theorem">
<p>La classe RP est incluse dans la classe BPP (Bounded-error
Probabilistic Polynomial-time). En d’autres termes, tout problème dans
RP peut être résolu par un algorithme probabiliste en temps polynomial
avec une erreur bornée.</p>
</div>
<p>Pour comprendre ce théorème, commençons par rappeler que la classe
BPP est définie comme l’ensemble des problèmes pour lesquels une machine
de Turing probabiliste peut résoudre le problème en temps polynomial
avec une erreur bornée. Formellement, un langage <span
class="math inline">\(L\)</span> appartient à BPP s’il existe une
machine de Turing probabiliste <span class="math inline">\(M\)</span> et
un polynôme <span class="math inline">\(p\)</span> tels que pour toute
entrée <span class="math inline">\(x\)</span>, la probabilité que <span
class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> si <span class="math inline">\(x \in
L\)</span> est au moins <span
class="math inline">\(\frac{2}{3}\)</span>, et la probabilité que <span
class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> si <span class="math inline">\(x \notin
L\)</span> est au plus <span class="math inline">\(\frac{1}{3}\)</span>.
En d’autres termes : <span class="math display">\[\forall x \in L, \quad
P[M(x) = 1] \geq \frac{2}{3}\]</span> <span
class="math display">\[\forall x \notin L, \quad P[M(x) = 1] \leq
\frac{1}{3}\]</span></p>
<p>La preuve de ce théorème repose sur le fait que tout algorithme
probabiliste dans RP peut être amplifié pour réduire la probabilité
d’erreur, ce qui permet de l’inclure dans BPP.</p>
<h1 class="unnumbered" id="preuves">Preuves</h1>
<p>Pour prouver le théorème de l’inclusion de RP dans BPP, nous allons
utiliser une technique appelée <em>amplification de la probabilité</em>.
L’idée est de répéter l’algorithme plusieurs fois pour réduire la
probabilité d’erreur.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(L \in
\text{RP}\)</span> et soit <span class="math inline">\(M\)</span> une
machine de Turing probabiliste qui décide <span
class="math inline">\(L\)</span> en temps polynomial avec les propriétés
suivantes : <span class="math display">\[\forall x \in L, \quad P[M(x) =
1] \geq \frac{2}{3}\]</span> <span class="math display">\[\forall x
\notin L, \quad P[M(x) = 1] &lt; \frac{1}{3}\]</span></p>
<p>Nous allons construire une nouvelle machine de Turing probabiliste
<span class="math inline">\(M&#39;\)</span> qui décide <span
class="math inline">\(L\)</span> en temps polynomial avec une erreur
bornée. La machine <span class="math inline">\(M&#39;\)</span> exécute
<span class="math inline">\(M\)</span> un nombre polynomial de fois et
prend la majorité des résultats. Formellement, pour une entrée <span
class="math inline">\(x\)</span>, <span
class="math inline">\(M&#39;\)</span> exécute <span
class="math inline">\(M(x)\)</span> <span
class="math inline">\(k\)</span> fois et accepte <span
class="math inline">\(x\)</span> si au moins <span
class="math inline">\(\frac{k}{2}\)</span> des exécutions acceptent
<span class="math inline">\(x\)</span>.</p>
<p>Pour un nombre suffisant de répétitions <span
class="math inline">\(k\)</span>, la probabilité que <span
class="math inline">\(M&#39;\)</span> commette une erreur peut être
rendue arbitrairement petite. Par exemple, en utilisant le théorème de
Chernoff, on peut montrer que pour <span class="math inline">\(k =
O(\log n)\)</span>, la probabilité d’erreur de <span
class="math inline">\(M&#39;\)</span> est inférieure à <span
class="math inline">\(\frac{1}{3}\)</span> pour toute entrée <span
class="math inline">\(x\)</span>.</p>
<p>Ainsi, <span class="math inline">\(M&#39;\)</span> décide <span
class="math inline">\(L\)</span> en temps polynomial avec une erreur
bornée, ce qui prouve que <span class="math inline">\(L \in
\text{BPP}\)</span>. ◻</p>
</div>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<p>Nous listons maintenant quelques propriétés importantes de la classe
RP.</p>
<ol>
<li><p>La classe RP est fermée sous complémentation. C’est-à-dire que si
<span class="math inline">\(L \in \text{RP}\)</span>, alors <span
class="math inline">\(\overline{L} \in \text{RP}\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(L \in
\text{RP}\)</span> et soit <span class="math inline">\(M\)</span> une
machine de Turing probabiliste qui décide <span
class="math inline">\(L\)</span> en temps polynomial avec les propriétés
suivantes : <span class="math display">\[\forall x \in L, \quad P[M(x) =
1] \geq \frac{2}{3}\]</span> <span class="math display">\[\forall x
\notin L, \quad P[M(x) = 1] &lt; \frac{1}{3}\]</span></p>
<p>Nous pouvons construire une machine de Turing probabiliste <span
class="math inline">\(M&#39;\)</span> qui décide <span
class="math inline">\(\overline{L}\)</span> en temps polynomial avec les
propriétés suivantes : <span class="math display">\[\forall x \in
\overline{L}, \quad P[M&#39;(x) = 1] \geq \frac{2}{3}\]</span> <span
class="math display">\[\forall x \notin \overline{L}, \quad P[M&#39;(x)
= 1] &lt; \frac{1}{3}\]</span></p>
<p>La machine <span class="math inline">\(M&#39;\)</span> exécute
simplement <span class="math inline">\(M\)</span> et renvoie le résultat
complémentaire. Formellement, pour une entrée <span
class="math inline">\(x\)</span>, <span
class="math inline">\(M&#39;\)</span> exécute <span
class="math inline">\(M(x)\)</span> et accepte <span
class="math inline">\(x\)</span> si <span
class="math inline">\(M(x)\)</span> rejette <span
class="math inline">\(x\)</span>.</p>
<p>Ainsi, <span class="math inline">\(\overline{L} \in
\text{RP}\)</span>. ◻</p>
</div></li>
<li><p>La classe RP est fermée sous union. C’est-à-dire que si <span
class="math inline">\(L_1, L_2 \in \text{RP}\)</span>, alors <span
class="math inline">\(L_1 \cup L_2 \in \text{RP}\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> Soient <span class="math inline">\(L_1, L_2 \in
\text{RP}\)</span> et soient <span class="math inline">\(M_1,
M_2\)</span> des machines de Turing probabilistes qui décident <span
class="math inline">\(L_1, L_2\)</span> en temps polynomial avec les
propriétés suivantes : <span class="math display">\[\forall x \in L_1,
\quad P[M_1(x) = 1] \geq \frac{2}{3}\]</span> <span
class="math display">\[\forall x \notin L_1, \quad P[M_1(x) = 1] &lt;
\frac{1}{3}\]</span> <span class="math display">\[\forall x \in L_2,
\quad P[M_2(x) = 1] \geq \frac{2}{3}\]</span> <span
class="math display">\[\forall x \notin L_2, \quad P[M_2(x) = 1] &lt;
\frac{1}{3}\]</span></p>
<p>Nous pouvons construire une machine de Turing probabiliste <span
class="math inline">\(M\)</span> qui décide <span
class="math inline">\(L_1 \cup L_2\)</span> en temps polynomial avec les
propriétés suivantes : <span class="math display">\[\forall x \in L_1
\cup L_2, \quad P[M(x) = 1] \geq \frac{2}{3}\]</span> <span
class="math display">\[\forall x \notin L_1 \cup L_2, \quad P[M(x) = 1]
&lt; \frac{1}{3}\]</span></p>
<p>La machine <span class="math inline">\(M\)</span> exécute simplement
<span class="math inline">\(M_1\)</span> et <span
class="math inline">\(M_2\)</span> en parallèle et accepte <span
class="math inline">\(x\)</span> si au moins l’une des machines accepte
<span class="math inline">\(x\)</span>. Formellement, pour une entrée
<span class="math inline">\(x\)</span>, <span
class="math inline">\(M\)</span> exécute <span
class="math inline">\(M_1(x)\)</span> et <span
class="math inline">\(M_2(x)\)</span> et accepte <span
class="math inline">\(x\)</span> si <span class="math inline">\(M_1(x) =
1\)</span> ou <span class="math inline">\(M_2(x) = 1\)</span>.</p>
<p>Ainsi, <span class="math inline">\(L_1 \cup L_2 \in
\text{RP}\)</span>. ◻</p>
</div></li>
</ol>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>La classe RP est une classe de complexité fondamentale qui modélise
les problèmes pouvant être résolus rapidement avec une certaine
probabilité d’erreur. Elle est étroitement liée à d’autres classes de
complexité comme P, NP et BPP. Les propriétés et théorèmes associés à RP
offrent des insights précieux sur les limites et les possibilités des
algorithmes probabilistes. La compréhension approfondie de RP est
essentielle pour avancer dans la théorie de la complexité
computationnelle et pour développer des algorithmes efficaces pour
résoudre des problèmes complexes.</p>
</body>
</html>
{% include "footer.html" %}

