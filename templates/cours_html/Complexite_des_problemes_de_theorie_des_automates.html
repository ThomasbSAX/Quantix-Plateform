{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de théorie des automates</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de théorie des automates</h1>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La théorie des automates, née au milieu du XXe siècle, a profondément
transformé notre compréhension des systèmes computationnels. À l’origine
conçue pour modéliser les comportements de machines abstraites, cette
théorie a rapidement trouvé des applications dans des domaines aussi
variés que la compilation, la vérification de protocoles et
l’intelligence artificielle. L’étude de la complexité des problèmes liés
aux automates émerge comme une nécessité pour comprendre les limites et
les capacités de ces modèles. En effet, déterminer la complexité d’un
problème revient à évaluer le coût en temps et en espace nécessaire pour
résoudre ce problème, ce qui est indispensable pour concevoir des
algorithmes efficaces et optimiser les ressources.</p>
<p>Dans un cadre où les systèmes informatiques deviennent de plus en
plus complexes, la théorie des automates offre un langage formel pour
décrire et analyser ces systèmes. Les problèmes de complexité dans ce
contexte permettent de classer les problèmes en fonction de leur
difficulté, et de déterminer quels problèmes peuvent être résolus
efficacement. Cette classification est cruciale pour le développement de
nouvelles technologies et pour l’amélioration des performances des
systèmes existants.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour aborder la complexité des problèmes de théorie des automates, il
est essentiel de définir certains concepts fondamentaux. Commençons par
la notion d’automate fini.</p>
<h2 id="automates-finis">Automates finis</h2>
<p>Un automate fini est une machine abstraite qui reconnaît des langages
formels. Pour comprendre ce qu’est un automate fini, imaginons une
machine qui lit une séquence de symboles et décide si cette séquence
appartient à un certain ensemble prédéfini. L’automate finit est une
telle machine, mais avec des ressources limitées : il ne peut pas
utiliser de mémoire infinie.</p>
<p>Formellement, un automate fini déterministe (AFD) est un quintuplet
<span class="math inline">\((Q, \Sigma, \delta, q_0, F)\)</span> où
:</p>
<ul>
<li><p><span class="math inline">\(Q\)</span> est un ensemble fini
d’états,</p></li>
<li><p><span class="math inline">\(\Sigma\)</span> est un alphabet
fini,</p></li>
<li><p><span class="math inline">\(\delta : Q \times \Sigma \rightarrow
Q\)</span> est une fonction de transition,</p></li>
<li><p><span class="math inline">\(q_0 \in Q\)</span> est l’état
initial,</p></li>
<li><p><span class="math inline">\(F \subseteq Q\)</span> est l’ensemble
des états finaux.</p></li>
</ul>
<p>Un automate fini non déterministe (AFND) est un quintuplet <span
class="math inline">\((Q, \Sigma, \delta, q_0, F)\)</span> où la
fonction de transition <span class="math inline">\(\delta\)</span> est
définie comme <span class="math inline">\(\delta : Q \times \Sigma
\rightarrow \mathcal{P}(Q)\)</span>, où <span
class="math inline">\(\mathcal{P}(Q)\)</span> est l’ensemble des parties
de <span class="math inline">\(Q\)</span>.</p>
<h2 id="complexité">Complexité</h2>
<p>La complexité d’un problème est une mesure du coût nécessaire pour
résoudre ce problème. En théorie des automates, nous pouvons considérer
la complexité en termes de temps et d’espace.</p>
<p>Formellement, soit <span class="math inline">\(P\)</span> un
problème. La complexité temporelle de <span
class="math inline">\(P\)</span> est la fonction <span
class="math inline">\(T(n)\)</span> qui donne le nombre maximum
d’opérations nécessaires pour résoudre <span
class="math inline">\(P\)</span> en fonction de la taille <span
class="math inline">\(n\)</span> des données d’entrée. La complexité
spatiale de <span class="math inline">\(P\)</span> est la fonction <span
class="math inline">\(S(n)\)</span> qui donne l’espace mémoire
nécessaire pour résoudre <span class="math inline">\(P\)</span> en
fonction de la taille <span class="math inline">\(n\)</span> des données
d’entrée.</p>
<h1 id="théorèmes">Théorèmes</h1>
<h2 id="théorème-de-myhill-nerode">Théorème de Myhill-Nerode</h2>
<p>Le théorème de Myhill-Nerode est un résultat fondamental en théorie
des automates. Il établit une condition nécessaire et suffisante pour
qu’un langage soit reconnu par un automate fini.</p>
<p>Pour comprendre ce théorème, imaginons que nous voulons déterminer si
un langage est reconnaissable par un automate fini. Le théorème de
Myhill-Nerode nous donne une condition basée sur la relation
d’équivalence induite par le langage.</p>
<p>Formellement, soit <span class="math inline">\(L\)</span> un langage
sur un alphabet <span class="math inline">\(\Sigma\)</span>. Le théorème
de Myhill-Nerode s’énonce comme suit :</p>
<div class="theorem">
<p>Un langage <span class="math inline">\(L \subseteq \Sigma^*\)</span>
est reconnaissable par un automate fini si et seulement si la relation
d’équivalence <span class="math inline">\(R_L\)</span> définie par :
<span class="math display">\[u R_L v \Leftrightarrow (\forall w \in
\Sigma^*, uw \in L \Leftrightarrow vw \in L)\]</span> a un nombre fini
d’équivalences.</p>
</div>
<h2 id="démonstration-du-théorème-de-myhill-nerode">Démonstration du
théorème de Myhill-Nerode</h2>
<p>Pour démontrer le théorème de Myhill-Nerode, nous devons montrer deux
implications : si <span class="math inline">\(L\)</span> est
reconnaissable par un automate fini, alors <span
class="math inline">\(R_L\)</span> a un nombre fini d’équivalences, et
réciproquement.</p>
<div class="proof">
<p><em>Proof.</em></p>
<h2 id="implication-directe">Implication directe</h2>
<p>Supposons que <span class="math inline">\(L\)</span> soit
reconnaissable par un automate fini <span
class="math inline">\(\mathcal{A} = (Q, \Sigma, \delta, q_0,
F)\)</span>. Pour chaque état <span class="math inline">\(q \in
Q\)</span>, définissons l’ensemble des mots qui mènent à <span
class="math inline">\(q\)</span> : <span class="math display">\[L_q =
\{w \in \Sigma^* \mid \delta(q_0, w) = q\}.\]</span></p>
<p>Nous pouvons montrer que pour tout <span class="math inline">\(u, v
\in \Sigma^*\)</span>, si <span class="math inline">\(\delta(q_0, u) =
\delta(q_0, v)\)</span>, alors <span class="math inline">\(u R_L
v\)</span>. En effet, pour tout <span class="math inline">\(w \in
\Sigma^*\)</span>, nous avons : <span class="math display">\[uw \in L
\Leftrightarrow \delta(q_0, uw) \in F \Leftrightarrow \delta(\delta(q_0,
u), w) \in F.\]</span> De même, <span class="math display">\[vw \in L
\Leftrightarrow \delta(q_0, vw) \in F \Leftrightarrow \delta(\delta(q_0,
v), w) \in F.\]</span> Puisque <span class="math inline">\(\delta(q_0,
u) = \delta(q_0, v)\)</span>, nous avons <span class="math inline">\(uw
\in L \Leftrightarrow vw \in L\)</span>, ce qui montre que <span
class="math inline">\(u R_L v\)</span>.</p>
<p>Comme il y a un nombre fini d’états dans <span
class="math inline">\(\mathcal{A}\)</span>, le nombre d’équivalences de
<span class="math inline">\(R_L\)</span> est également fini.</p>
<h2 id="implication-réciproque">Implication réciproque</h2>
<p>Supposons que <span class="math inline">\(R_L\)</span> ait un nombre
fini d’équivalences. Nous devons construire un automate fini <span
class="math inline">\(\mathcal{A}\)</span> qui reconnaît <span
class="math inline">\(L\)</span>.</p>
<p>Soit <span class="math inline">\([u]\)</span> la classe d’équivalence
de <span class="math inline">\(u\)</span> sous <span
class="math inline">\(R_L\)</span>. Nous définissons l’automate <span
class="math inline">\(\mathcal{A} = (Q, \Sigma, \delta, q_0, F)\)</span>
où : <span class="math display">\[Q = \{[u] \mid u \in
\Sigma^*\},\]</span> <span class="math display">\[q_0 =
[\epsilon],\]</span> <span class="math display">\[F = \{[u] \mid u \in
L\},\]</span> et <span class="math inline">\(\delta\)</span> est définie
par : <span class="math display">\[\delta([u], a) = [ua] \quad
\text{pour tout } u \in \Sigma^* \text{ et } a \in \Sigma.\]</span></p>
<p>Nous devons montrer que <span
class="math inline">\(\mathcal{A}\)</span> reconnaît <span
class="math inline">\(L\)</span>. Pour tout <span
class="math inline">\(w \in \Sigma^*\)</span>, nous avons : <span
class="math display">\[\delta(q_0, w) = [w].\]</span> Donc, <span
class="math inline">\(w \in L\)</span> si et seulement si <span
class="math inline">\([w] \in F\)</span>, ce qui est vrai par définition
de <span class="math inline">\(F\)</span>.</p>
<p>Comme le nombre d’équivalences de <span
class="math inline">\(R_L\)</span> est fini, <span
class="math inline">\(\mathcal{A}\)</span> est un automate fini. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et corollaires</h1>
<h2 id="propriété-de-clôture">Propriété de clôture</h2>
<p>Les langages reconnaissables par des automates finis ont plusieurs
propriétés de clôture intéressantes. Nous en énumérons quelques-unes
:</p>
<ol>
<li><p><strong>Clôture sous union</strong> : Si <span
class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span> sont reconnaissables par des
automates finis, alors <span class="math inline">\(L_1 \cup L_2\)</span>
est également reconnaissable par un automate fini.</p>
<div class="proof">
<p><em>Proof.</em> Soient <span class="math inline">\(\mathcal{A}_1 =
(Q_1, \Sigma, \delta_1, q_{0,1}, F_1)\)</span> et <span
class="math inline">\(\mathcal{A}_2 = (Q_2, \Sigma, \delta_2, q_{0,2},
F_2)\)</span> deux automates finis reconnaissant <span
class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span> respectivement. Nous pouvons
construire un automate fini <span class="math inline">\(\mathcal{A} =
(Q, \Sigma, \delta, q_0, F)\)</span> reconnaissant <span
class="math inline">\(L_1 \cup L_2\)</span> en définissant : <span
class="math display">\[Q = Q_1 \times Q_2,\]</span> <span
class="math display">\[q_0 = (q_{0,1}, q_{0,2}),\]</span> <span
class="math display">\[F = (F_1 \times Q_2) \cup (Q_1 \times
F_2),\]</span> et <span class="math inline">\(\delta\)</span> par :
<span class="math display">\[\delta((q_1, q_2), a) = (\delta_1(q_1, a),
\delta_2(q_2, a)) \quad \text{pour tout } q_1 \in Q_1, q_2 \in Q_2, a
\in \Sigma.\]</span> Il est facile de vérifier que <span
class="math inline">\(\mathcal{A}\)</span> reconnaît <span
class="math inline">\(L_1 \cup L_2\)</span>. ◻</p>
</div></li>
<li><p><strong>Clôture sous concaténation</strong> : Si <span
class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span> sont reconnaissables par des
automates finis, alors <span class="math inline">\(L_1 \cdot
L_2\)</span> est également reconnaissable par un automate fini.</p>
<div class="proof">
<p><em>Proof.</em> Soient <span class="math inline">\(\mathcal{A}_1 =
(Q_1, \Sigma, \delta_1, q_{0,1}, F_1)\)</span> et <span
class="math inline">\(\mathcal{A}_2 = (Q_2, \Sigma, \delta_2, q_{0,2},
F_2)\)</span> deux automates finis reconnaissant <span
class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span> respectivement. Nous pouvons
construire un automate fini <span class="math inline">\(\mathcal{A} =
(Q, \Sigma, \delta, q_0, F)\)</span> reconnaissant <span
class="math inline">\(L_1 \cdot L_2\)</span> en définissant : <span
class="math display">\[Q = Q_1 \times Q_2,\]</span> <span
class="math display">\[q_0 = (q_{0,1}, q_{0,2}),\]</span> <span
class="math display">\[F = (F_1 \times F_2),\]</span> et <span
class="math inline">\(\delta\)</span> par : <span
class="math display">\[\delta((q_1, q_2), a) = (\delta_1(q_1, a),
\delta_2(q_2, a)) \quad \text{pour tout } q_1 \in Q_1, q_2 \in Q_2, a
\in \Sigma.\]</span> Il est facile de vérifier que <span
class="math inline">\(\mathcal{A}\)</span> reconnaît <span
class="math inline">\(L_1 \cdot L_2\)</span>. ◻</p>
</div></li>
<li><p><strong>Clôture sous étoile</strong> : Si <span
class="math inline">\(L\)</span> est reconnaissable par un automate
fini, alors <span class="math inline">\(L^*\)</span> est également
reconnaissable par un automate fini.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(\mathcal{A} = (Q,
\Sigma, \delta, q_0, F)\)</span> un automate fini reconnaissant <span
class="math inline">\(L\)</span>. Nous pouvons construire un automate
fini <span class="math inline">\(\mathcal{A}&#39; = (Q&#39;, \Sigma,
\delta&#39;, q_0&#39;, F&#39;)\)</span> reconnaissant <span
class="math inline">\(L^*\)</span> en définissant : <span
class="math display">\[Q&#39; = Q \cup \{q_\epsilon\},\]</span> où <span
class="math inline">\(q_\epsilon\)</span> est un nouvel état, <span
class="math display">\[q_0&#39; = q_\epsilon,\]</span> <span
class="math display">\[F&#39; = F \cup \{q_\epsilon\},\]</span> et <span
class="math inline">\(\delta&#39;\)</span> par : <span
class="math display">\[\delta&#39;(q, a) = \delta(q, a) \quad \text{pour
tout } q \in Q, a \in \Sigma,\]</span> <span
class="math display">\[\delta&#39;(q_\epsilon, a) = q_0 \quad \text{pour
tout } a \in \Sigma,\]</span> et <span
class="math inline">\(\delta&#39;(q, \epsilon) = q_\epsilon\)</span>
pour tout <span class="math inline">\(q \in F\)</span>.</p>
<p>Il est facile de vérifier que <span
class="math inline">\(\mathcal{A}&#39;\)</span> reconnaît <span
class="math inline">\(L^*\)</span>. ◻</p>
</div></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>La théorie des automates et l’étude de la complexité des problèmes
associés offrent un cadre rigoureux pour comprendre les limites et les
capacités des systèmes computationnels. Les résultats présentés dans cet
article, tels que le théorème de Myhill-Nerode et les propriétés de
clôture des langages reconnaissables par des automates finis, sont
fondamentaux pour le développement de nouvelles technologies et
l’optimisation des systèmes existants. En continuant à explorer ces
concepts, nous pouvons espérer découvrir de nouvelles méthodes pour
résoudre des problèmes complexes et améliorer les performances des
systèmes informatiques.</p>
</body>
</html>
{% include "footer.html" %}

