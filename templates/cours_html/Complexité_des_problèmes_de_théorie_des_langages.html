{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de théorie des langages</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de théorie des langages</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La théorie des langages, branche fondamentale de l’informatique
théorique, trouve ses racines dans les travaux pionniers de Noam Chomsky
dans les années 1950. L’objectif initial était de modéliser la structure
syntaxique des langues naturelles, mais cette théorie s’est rapidement
étendue à l’analyse des langages de programmation et des automates.</p>
<p>L’émergence de la notion de complexité dans ce domaine est motivée
par le besoin croissant d’évaluer l’efficacité des algorithmes de
traitement des langages. En effet, la complexité permet de quantifier
les ressources nécessaires (temps et espace) pour résoudre des problèmes
liés aux langages formels. Cette évaluation est indispensable dans un
contexte où les données et les systèmes deviennent de plus en plus
complexes, nécessitant des solutions optimales en termes de
performance.</p>
<h1 id="définitions">Définitions</h1>
<h2 id="problème-de-décision">Problème de décision</h2>
<p>Considérons un langage <span class="math inline">\(L\)</span> sur un
alphabet <span class="math inline">\(\Sigma\)</span>. Nous cherchons à
déterminer si une chaîne donnée <span class="math inline">\(w \in
\Sigma^*\)</span> appartient à <span class="math inline">\(L\)</span>.
Pour ce faire, nous devons définir un problème de décision qui capture
cette question.</p>
<div class="definition">
<p>Soit <span class="math inline">\(L \subseteq \Sigma^*\)</span> un
langage. Le problème de décision associé à <span
class="math inline">\(L\)</span>, noté <span
class="math inline">\(D_L\)</span>, est défini comme suit : <span
class="math display">\[D_L = \{ (w) \mid w \in L \}\]</span> En d’autres
termes, <span class="math inline">\(D_L\)</span> est l’ensemble des
chaînes <span class="math inline">\(w\)</span> pour lesquelles la
réponse à la question "<span class="math inline">\(w \in L\)</span>" est
affirmative.</p>
</div>
<h2 id="complexité-temporelle">Complexité temporelle</h2>
<p>La complexité temporelle d’un algorithme mesure le nombre
d’opérations élémentaires nécessaires pour résoudre un problème. Dans le
contexte des langages, nous cherchons à évaluer la complexité temporelle
des algorithmes de reconnaissance.</p>
<div class="definition">
<p>Soit <span class="math inline">\(A\)</span> un algorithme qui
reconnaît le langage <span class="math inline">\(L\)</span>. La
complexité temporelle de <span class="math inline">\(A\)</span>, notée
<span class="math inline">\(T_A(n)\)</span>, est définie comme la
fonction qui, à toute entrée de longueur <span
class="math inline">\(n\)</span>, associe le nombre maximal d’opérations
élémentaires effectuées par <span class="math inline">\(A\)</span> sur
cette entrée. <span class="math display">\[T_A(n) = \max_{w \in
\Sigma^n} \text{temps}(A(w))\]</span></p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<h2 id="théorème-de-hiérarchie-des-complexités">Théorème de hiérarchie
des complexités</h2>
<p>Le théorème de hiérarchie des complexités est un résultat fondamental
en théorie de la complexité. Il établit une distinction entre les
classes de complexité en fonction des ressources nécessaires pour
résoudre un problème.</p>
<div class="theorem">
<p>Soient <span class="math inline">\(t_1\)</span> et <span
class="math inline">\(t_2\)</span> deux fonctions telles que <span
class="math inline">\(t_1(n) = o(t_2(n))\)</span>. Alors, il existe un
langage <span class="math inline">\(L\)</span> tel que : <span
class="math display">\[L \in \text{DTIME}(t_2(n)) -
\text{DTIME}(t_1(n))\]</span> Cela signifie qu’il existe des problèmes
qui peuvent être résolus en temps <span
class="math inline">\(t_2(n)\)</span>, mais pas en temps <span
class="math inline">\(t_1(n)\)</span>.</p>
</div>
<h2
id="démonstration-du-théorème-de-hiérarchie-des-complexités">Démonstration
du théorème de hiérarchie des complexités</h2>
<p>Pour démontrer ce théorème, nous utilisons la méthode de
diagonalisation. Supposons par l’absurde que <span
class="math inline">\(\text{DTIME}(t_2(n)) =
\text{DTIME}(t_1(n))\)</span>. Alors, pour tout langage <span
class="math inline">\(L\)</span> dans <span
class="math inline">\(\text{DTIME}(t_2(n))\)</span>, il existe un
algorithme <span class="math inline">\(A\)</span> qui reconnaît <span
class="math inline">\(L\)</span> en temps <span
class="math inline">\(t_1(n)\)</span>.</p>
<p>Considérons l’ensemble des algorithmes <span
class="math inline">\(A_i\)</span> qui reconnaissent des langages en
temps <span class="math inline">\(t_1(n)\)</span>. Nous pouvons
construire un langage <span class="math inline">\(L\)</span> tel que :
<span class="math display">\[L = \{ w \mid A_i(w) \text{ accepte en
temps } t_1(|w|) \}\]</span> Par construction, <span
class="math inline">\(L\)</span> ne peut pas être reconnu par un
algorithme en temps <span class="math inline">\(t_1(n)\)</span>, ce qui
contredit notre hypothèse initiale. Donc, <span
class="math inline">\(\text{DTIME}(t_2(n)) \neq
\text{DTIME}(t_1(n))\)</span>.</p>
<h1 id="preuves">Preuves</h1>
<h2 id="preuve-de-la-complexité-temporelle-dun-algorithme">Preuve de la
complexité temporelle d’un algorithme</h2>
<p>Considérons un algorithme <span class="math inline">\(A\)</span> qui
reconnaît le langage <span class="math inline">\(L\)</span>. Nous
voulons prouver que la complexité temporelle de <span
class="math inline">\(A\)</span> est <span
class="math inline">\(O(n^k)\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> Nous analysons l’algorithme <span
class="math inline">\(A\)</span> étape par étape. Pour chaque boucle ou
opération, nous évaluons le nombre d’opérations élémentaires
nécessaires.</p>
<p>Supposons que <span class="math inline">\(A\)</span> effectue <span
class="math inline">\(k\)</span> boucles imbriquées, chacune itérant sur
<span class="math inline">\(n\)</span> éléments. Le nombre total
d’opérations élémentaires est alors : <span
class="math display">\[\sum_{i=1}^{k} n^i = O(n^k)\]</span> Ainsi, la
complexité temporelle de <span class="math inline">\(A\)</span> est
<span class="math inline">\(O(n^k)\)</span>. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<h2 id="propriété-de-fermeture-sous-complémentation">Propriété de
fermeture sous complémentation</h2>
<p>Les classes de complexité possèdent des propriétés de fermeture
importantes. Nous démontrons que la classe <span
class="math inline">\(\text{P}\)</span> est fermée sous
complémentation.</p>
<div class="corollary">
<p>Si <span class="math inline">\(L \in \text{P}\)</span>, alors <span
class="math inline">\(\overline{L} \in \text{P}\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(A\)</span> un
algorithme qui reconnaît <span class="math inline">\(L\)</span> en temps
polynomial. Nous construisons un algorithme <span
class="math inline">\(A&#39;\)</span> qui reconnaît <span
class="math inline">\(\overline{L}\)</span> en temps polynomial.</p>
<p>L’algorithme <span class="math inline">\(A&#39;\)</span> fonctionne
comme suit :</p>
<ol>
<li><p>Exécute <span class="math inline">\(A\)</span> sur l’entrée <span
class="math inline">\(w\)</span>.</p></li>
<li><p>Si <span class="math inline">\(A\)</span> accepte, <span
class="math inline">\(A&#39;\)</span> rejette.</p></li>
<li><p>Si <span class="math inline">\(A\)</span> rejette, <span
class="math inline">\(A&#39;\)</span> accepte.</p></li>
</ol>
<p>Puisque <span class="math inline">\(A\)</span> s’exécute en temps
polynomial, <span class="math inline">\(A&#39;\)</span> s’exécute
également en temps polynomial. Donc, <span
class="math inline">\(\overline{L} \in \text{P}\)</span>. ◻</p>
</div>
<h2 id="propriété-de-fermeture-sous-union">Propriété de fermeture sous
union</h2>
<p>Nous démontrons que la classe <span
class="math inline">\(\text{P}\)</span> est fermée sous union.</p>
<div class="corollary">
<p>Si <span class="math inline">\(L_1, L_2 \in \text{P}\)</span>, alors
<span class="math inline">\(L_1 \cup L_2 \in \text{P}\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Soient <span class="math inline">\(A_1\)</span> et
<span class="math inline">\(A_2\)</span> des algorithmes qui
reconnaissent respectivement <span class="math inline">\(L_1\)</span> et
<span class="math inline">\(L_2\)</span> en temps polynomial. Nous
construisons un algorithme <span class="math inline">\(A\)</span> qui
reconnaît <span class="math inline">\(L_1 \cup L_2\)</span> en temps
polynomial.</p>
<p>L’algorithme <span class="math inline">\(A\)</span> fonctionne comme
suit :</p>
<ol>
<li><p>Exécute <span class="math inline">\(A_1\)</span> sur l’entrée
<span class="math inline">\(w\)</span>.</p></li>
<li><p>Si <span class="math inline">\(A_1\)</span> accepte, <span
class="math inline">\(A\)</span> accepte.</p></li>
<li><p>Sinon, exécute <span class="math inline">\(A_2\)</span> sur
l’entrée <span class="math inline">\(w\)</span>.</p></li>
<li><p>Si <span class="math inline">\(A_2\)</span> accepte, <span
class="math inline">\(A\)</span> accepte.</p></li>
<li><p>Sinon, <span class="math inline">\(A\)</span> rejette.</p></li>
</ol>
<p>Puisque <span class="math inline">\(A_1\)</span> et <span
class="math inline">\(A_2\)</span> s’exécutent en temps polynomial,
<span class="math inline">\(A\)</span> s’exécute également en temps
polynomial. Donc, <span class="math inline">\(L_1 \cup L_2 \in
\text{P}\)</span>. ◻</p>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>La complexité des problèmes de théorie des langages est un domaine
riche et fascinant, offrant des outils puissants pour évaluer
l’efficacité des algorithmes de traitement des langages. Les
définitions, théorèmes et propriétés présentés dans cet article
fournissent une base solide pour comprendre les enjeux et les défis de
ce domaine.</p>
<p>Les travaux futurs pourraient explorer des classes de complexité plus
avancées, telles que <span class="math inline">\(\text{NP}\)</span> et
<span class="math inline">\(\text{PSPACE}\)</span>, ainsi que leurs
relations avec les problèmes de théorie des langages. De plus, l’étude
des limites de la complexité et des méthodes pour surmonter ces limites
reste un domaine ouvert et prometteur.</p>
</body>
</html>
{% include "footer.html" %}

