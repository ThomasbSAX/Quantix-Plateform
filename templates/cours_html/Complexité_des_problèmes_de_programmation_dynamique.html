{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de programmation dynamique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de programmation
dynamique</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La programmation dynamique est une méthode algorithmique puissante
qui permet de résoudre des problèmes complexes en les décomposant en
sous-problèmes plus simples. Cette approche, introduite par Richard
Bellman dans les années 1950, est devenue un pilier de l’informatique
théorique et appliquée. L’idée centrale est de stocker les résultats des
sous-problèmes pour éviter de les recalculer, ce qui améliore
considérablement l’efficacité des algorithmes.</p>
<p>Les problèmes de programmation dynamique émergent naturellement dans
des domaines variés tels que l’optimisation, la théorie des graphes, et
même en biologie pour l’alignement de séquences. Ils sont indispensables
lorsque les solutions naïves présentent une complexité exponentielle,
rendant leur résolution directe intraitable pour des instances de taille
réaliste.</p>
<p>Dans cet article, nous explorons la complexité des problèmes de
programmation dynamique. Nous commençons par définir formellement ces
problèmes, puis nous discutons des théorèmes fondamentaux qui
caractérisent leur complexité. Enfin, nous présentons des preuves
détaillées et des corollaires importants.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre la complexité des problèmes de programmation
dynamique, il est essentiel de définir précisément ce que nous entendons
par "problème de programmation dynamique".</p>
<h2 id="problèmes-optimaux">Problèmes Optimaux</h2>
<p>Considérons un problème d’optimisation où nous cherchons à minimiser
ou maximiser une fonction objectif. Supposons que ce problème puisse
être décomposé en sous-problèmes plus petits, et que la solution
optimale du problème global puisse être construite à partir des
solutions optimales de ces sous-problèmes.</p>
<p>Formellement, un problème d’optimisation est dit <em>de programmation
dynamique</em> s’il existe une relation de récurrence qui permet
d’exprimer la solution optimale en fonction des solutions optimales des
sous-problèmes.</p>
<div class="definition">
<p>Soit <span class="math inline">\(\mathcal{P}\)</span> un problème
d’optimisation défini par une fonction objectif <span
class="math inline">\(f: S \rightarrow \mathbb{R}\)</span>, où <span
class="math inline">\(S\)</span> est l’ensemble des solutions possibles.
On dit que <span class="math inline">\(\mathcal{P}\)</span> est un
problème de programmation dynamique s’il existe une relation de
récurrence <span class="math inline">\(f(x) = \min_{y \in Y(x)} \{ g(x,
y) + f(y) \}\)</span>, où <span class="math inline">\(Y(x)\)</span> est
l’ensemble des sous-problèmes de <span class="math inline">\(x\)</span>,
et <span class="math inline">\(g\)</span> est une fonction de coût.</p>
</div>
<h2 id="problèmes-à-structure-optimal">Problèmes à Structure
Optimal</h2>
<p>Un problème est dit avoir une <em>structure optimale</em> si la
solution optimale peut être obtenue en combinant les solutions optimales
des sous-problèmes. Cette propriété est cruciale pour l’applicabilité de
la programmation dynamique.</p>
<div class="definition">
<p>Un problème <span class="math inline">\(\mathcal{P}\)</span> a une
structure optimale si, pour toute instance <span
class="math inline">\(x\)</span>, il existe un ensemble de
sous-instances <span class="math inline">\(\{ y_1, y_2, \ldots, y_k
\}\)</span> telles que la solution optimale pour <span
class="math inline">\(x\)</span> peut être exprimée comme une
combinaison des solutions optimales pour <span
class="math inline">\(y_1, y_2, \ldots, y_k\)</span>.</p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<h2 id="théorème-de-bellman">Théorème de Bellman</h2>
<p>Le théorème fondamental de la programmation dynamique, dû à Richard
Bellman, établit les conditions sous lesquelles un problème peut être
résolu par programmation dynamique.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(\mathcal{P}\)</span> un problème
d’optimisation défini par une fonction objectif <span
class="math inline">\(f: S \rightarrow \mathbb{R}\)</span>. Si <span
class="math inline">\(\mathcal{P}\)</span> satisfait les deux conditions
suivantes:</p>
<ol>
<li><p>(Décomposition) Il existe une relation de récurrence <span
class="math inline">\(f(x) = \min_{y \in Y(x)} \{ g(x, y) + f(y)
\}\)</span>.</p></li>
<li><p>(Structure Optimale) La solution optimale pour <span
class="math inline">\(x\)</span> peut être obtenue en combinant les
solutions optimales des sous-problèmes <span class="math inline">\(y \in
Y(x)\)</span>.</p></li>
</ol>
<p>Alors <span class="math inline">\(\mathcal{P}\)</span> peut être
résolu par programmation dynamique.</p>
</div>
<h2 id="théorème-de-complexité">Théorème de Complexité</h2>
<p>Le théorème suivant caractérise la complexité des problèmes de
programmation dynamique en termes du nombre de sous-problèmes à
résoudre.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(\mathcal{P}\)</span> un problème de
programmation dynamique défini par une relation de récurrence <span
class="math inline">\(f(x) = \min_{y \in Y(x)} \{ g(x, y) + f(y)
\}\)</span>. Si le nombre de sous-problèmes <span
class="math inline">\(|Y(x)|\)</span> est borné par une constante <span
class="math inline">\(c\)</span>, alors la complexité temporelle de
l’algorithme de programmation dynamique est <span
class="math inline">\(O(n)\)</span>, où <span
class="math inline">\(n\)</span> est la taille de l’instance.</p>
</div>
<h1 id="preuves">Preuves</h1>
<h2 id="preuve-du-théorème-de-bellman">Preuve du Théorème de
Bellman</h2>
<p>Pour prouver le théorème de Bellman, nous devons montrer que les deux
conditions sont nécessaires et suffisantes pour que le problème puisse
être résolu par programmation dynamique.</p>
<div class="proof">
<p><em>Proof.</em> Supposons que <span
class="math inline">\(\mathcal{P}\)</span> satisfait les deux conditions
du théorème. Nous devons montrer qu’il existe un algorithme de
programmation dynamique qui résout <span
class="math inline">\(\mathcal{P}\)</span>.</p>
<p>1. **Décomposition**: La relation de récurrence <span
class="math inline">\(f(x) = \min_{y \in Y(x)} \{ g(x, y) + f(y)
\}\)</span> permet de décomposer le problème en sous-problèmes plus
petits. Nous pouvons résoudre ces sous-problèmes de manière
récursive.</p>
<p>2. **Structure Optimale**: La propriété de structure optimale
garantit que la solution optimale pour <span
class="math inline">\(x\)</span> peut être obtenue en combinant les
solutions optimales des sous-problèmes. Cela permet de construire la
solution globale à partir des solutions des sous-problèmes.</p>
<p>En combinant ces deux propriétés, nous pouvons construire un
algorithme de programmation dynamique qui résout <span
class="math inline">\(\mathcal{P}\)</span> en temps polynomial. ◻</p>
</div>
<h2 id="preuve-du-théorème-de-complexité">Preuve du Théorème de
Complexité</h2>
<p>Pour prouver le théorème de complexité, nous devons analyser la
complexité temporelle de l’algorithme de programmation dynamique.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(\mathcal{P}\)</span>
un problème de programmation dynamique défini par une relation de
récurrence <span class="math inline">\(f(x) = \min_{y \in Y(x)} \{ g(x,
y) + f(y) \}\)</span>. Supposons que le nombre de sous-problèmes <span
class="math inline">\(|Y(x)|\)</span> est borné par une constante <span
class="math inline">\(c\)</span>.</p>
<p>1. **Complexité Temporelle**: Pour chaque sous-problème <span
class="math inline">\(y \in Y(x)\)</span>, nous devons calculer <span
class="math inline">\(g(x, y) + f(y)\)</span>. Le nombre total
d’opérations est donc borné par <span class="math inline">\(c \cdot
n\)</span>, où <span class="math inline">\(n\)</span> est la taille de
l’instance.</p>
<p>2. **Mémoïsation**: En utilisant la mémoïsation, nous pouvons stocker
les résultats des sous-problèmes déjà résolus, ce qui évite de les
recalculer. Cela réduit la complexité temporelle à <span
class="math inline">\(O(n)\)</span>.</p>
<p>Ainsi, la complexité temporelle de l’algorithme de programmation
dynamique est <span class="math inline">\(O(n)\)</span>. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<h2 id="propriété-de-sous-structure-optimale">Propriété de
Sous-structure Optimale</h2>
<p>La propriété de sous-structure optimale est une condition nécessaire
pour l’applicabilité de la programmation dynamique.</p>
<div class="property">
<p>Un problème <span class="math inline">\(\mathcal{P}\)</span> a une
sous-structure optimale si la solution optimale pour une instance <span
class="math inline">\(x\)</span> peut être obtenue en combinant les
solutions optimales des sous-instances de <span
class="math inline">\(x\)</span>.</p>
</div>
<h2 id="corollaire-de-complexité-polynomiale">Corollaire de Complexité
Polynomiale</h2>
<p>Le corollaire suivant montre que les problèmes de programmation
dynamique peuvent être résolus en temps polynomial sous certaines
conditions.</p>
<div class="corollary">
<p>Soit <span class="math inline">\(\mathcal{P}\)</span> un problème de
programmation dynamique défini par une relation de récurrence <span
class="math inline">\(f(x) = \min_{y \in Y(x)} \{ g(x, y) + f(y)
\}\)</span>. Si le nombre de sous-problèmes <span
class="math inline">\(|Y(x)|\)</span> est borné par une constante <span
class="math inline">\(c\)</span>, alors <span
class="math inline">\(\mathcal{P}\)</span> peut être résolu en temps
polynomial.</p>
</div>
<div class="proof">
<p><em>Proof.</em> La preuve suit directement du théorème de complexité.
Si le nombre de sous-problèmes est borné par une constante, alors
l’algorithme de programmation dynamique a une complexité temporelle
<span class="math inline">\(O(n)\)</span>, qui est polynomiale en la
taille de l’instance. ◻</p>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>Dans cet article, nous avons exploré la complexité des problèmes de
programmation dynamique. Nous avons défini formellement ces problèmes,
présenté les théorèmes fondamentaux qui caractérisent leur complexité,
et fourni des preuves détaillées. Les propriétés et corollaires discutés
montrent que la programmation dynamique est une méthode puissante pour
résoudre des problèmes complexes de manière efficace.</p>
</body>
</html>
{% include "footer.html" %}

