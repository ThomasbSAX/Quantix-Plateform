{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de backtracking</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de backtracking</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>Le backtracking est une technique algorithmique fondamentale en
informatique théorique, particulièrement utilisée pour résoudre des
problèmes de recherche exhaustive. Son origine remonte aux années 1960,
avec les travaux pionniers de Donald Knuth et Nicolaas G. de Bruijn sur
les algorithmes de recherche d’arbres et de graphes. Le backtracking
émerge comme une réponse élégante à des problèmes où la solution
nécessite l’exploration systématique de toutes les possibilités, souvent
dans un espace de recherche exponentiel.</p>
<p>Pourquoi cette notion est-elle indispensable ? Parce qu’elle permet
de modéliser et résoudre des problèmes complexes tels que les puzzles
(comme le problème des n-dames), la satisfaction de contraintes, ou
encore l’optimisation combinatoire. Le backtracking est indispensable
dans des cadres où les solutions exactes sont nécessaires, et où les
approches heuristiques ou probabilistes ne suffisent pas.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre la complexité des problèmes de backtracking,
commençons par définir ce qu’est un problème de backtracking. Imaginez
que vous cherchiez à résoudre un puzzle en essayant toutes les
configurations possibles, mais en abandonnant les branches de l’arbre de
recherche dès qu’elles ne mènent pas à une solution. C’est précisément
ce que fait le backtracking.</p>
<div class="definition">
<p>Un problème de backtracking est un problème de décision ou
d’optimisation qui peut être résolu en explorant systématiquement toutes
les configurations possibles, en abandonnant les branches de l’arbre de
recherche qui ne mènent pas à une solution.</p>
<p>Formellement, soit <span class="math inline">\(\mathcal{P}\)</span>
un problème de décision. On dit que <span
class="math inline">\(\mathcal{P}\)</span> est un problème de
backtracking s’il existe une fonction <span class="math inline">\(f: D
\rightarrow \{0,1\}\)</span> telle que : <span
class="math display">\[\forall x \in D, \exists y \text{ tel que }
f(x,y) = 1 \Leftrightarrow x \text{ est une solution de }
\mathcal{P}.\]</span></p>
</div>
<p>Une autre manière de formuler cette définition est la suivante : un
problème de backtracking admet une représentation sous forme d’arbre où
chaque nœud représente une configuration partielle, et les feuilles
représentent les solutions potentielles.</p>
<h1 id="théorèmes">Théorèmes</h1>
<p>Un théorème fondamental concernant la complexité des problèmes de
backtracking est le théorème de l’arbre de recherche. Ce théorème
établit une relation entre la taille de l’arbre de recherche et le
nombre maximal de configurations à explorer.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(\mathcal{P}\)</span> un problème de
backtracking avec un arbre de recherche de hauteur <span
class="math inline">\(h\)</span> et de largeur maximale <span
class="math inline">\(w\)</span>. Le nombre maximal de configurations à
explorer est donné par : <span class="math display">\[\sum_{i=0}^{h}
w^i.\]</span></p>
</div>
<div class="proof">
<p><em>Proof.</em> La preuve de ce théorème repose sur le principe du
backtracking lui-même. À chaque niveau <span
class="math inline">\(i\)</span> de l’arbre, il y a au plus <span
class="math inline">\(w\)</span> configurations possibles. En explorant
systématiquement toutes les branches, le nombre total de configurations
à explorer est la somme des configurations à chaque niveau.</p>
<p>Plus formellement, soit <span class="math inline">\(T\)</span>
l’arbre de recherche. Pour chaque niveau <span
class="math inline">\(i\)</span>, le nombre maximal de nœuds est <span
class="math inline">\(w^i\)</span>. En sommant sur tous les niveaux, on
obtient : <span class="math display">\[\sum_{i=0}^{h}
w^i.\]</span> ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<p>Pour illustrer la complexité des problèmes de backtracking,
considérons le problème des n-dames. Ce problème consiste à placer <span
class="math inline">\(n\)</span> dames sur un échiquier <span
class="math inline">\(n \times n\)</span> de telle sorte qu’aucune dame
ne soit attaquée par une autre.</p>
<div class="theorem">
<p>Le problème des n-dames a une complexité exponentielle en <span
class="math inline">\(n\)</span>, c’est-à-dire <span
class="math inline">\(O(n^n)\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Pour prouver ce théorème, nous allons montrer que le
nombre maximal de configurations à explorer est exponentiel en <span
class="math inline">\(n\)</span>.</p>
<p>1. **Modélisation du problème** : Le problème des n-dames peut être
modélisé comme un arbre de recherche où chaque niveau représente une
colonne, et chaque nœud représente une ligne possible pour placer une
dame dans cette colonne.</p>
<p>2. **Hauteur de l’arbre** : L’arbre a une hauteur <span
class="math inline">\(h = n\)</span>, car il y a <span
class="math inline">\(n\)</span> colonnes.</p>
<p>3. **Largeur de l’arbre** : À chaque niveau, il y a au plus <span
class="math inline">\(n\)</span> configurations possibles (une pour
chaque ligne).</p>
<p>4. **Nombre total de configurations** : En appliquant le théorème de
l’arbre de recherche, le nombre maximal de configurations à explorer est
: <span class="math display">\[\sum_{i=0}^{n} n^i = O(n^n).\]</span></p>
<p>Ainsi, la complexité du problème des n-dames est exponentielle en
<span class="math inline">\(n\)</span>. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Les problèmes de backtracking possèdent plusieurs propriétés
intéressantes, que nous allons énumérer et prouver.</p>
<ol>
<li><p>**Propriété de l’optimalité** : Le backtracking explore toutes
les configurations possibles, ce qui garantit qu’il trouve une solution
si elle existe.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(\mathcal{P}\)</span>
un problème de backtracking et <span class="math inline">\(T\)</span>
son arbre de recherche. Si une solution existe, elle doit apparaître
comme une feuille de <span class="math inline">\(T\)</span>. Le
backtracking explore systématiquement toutes les feuilles, donc il
trouvera nécessairement une solution si elle existe. ◻</p>
</div></li>
<li><p>**Propriété de la complexité exponentielle** : La plupart des
problèmes de backtracking ont une complexité exponentielle.</p>
<div class="proof">
<p><em>Proof.</em> Considérons un problème de backtracking avec un arbre
de recherche de hauteur <span class="math inline">\(h\)</span> et de
largeur maximale <span class="math inline">\(w\)</span>. Le nombre
maximal de configurations à explorer est <span
class="math inline">\(\sum_{i=0}^{h} w^i\)</span>, qui est exponentiel
en <span class="math inline">\(h\)</span> si <span
class="math inline">\(w\)</span> est constant. ◻</p>
</div></li>
<li><p>**Propriété de la pruning** : Le backtracking peut être optimisé
en utilisant des techniques de pruning pour éliminer les branches
inutiles.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(\mathcal{P}\)</span>
un problème de backtracking et <span class="math inline">\(T\)</span>
son arbre de recherche. Si une configuration partielle ne peut pas mener
à une solution, la branche correspondante peut être éliminée. Cela
réduit le nombre de configurations à explorer. ◻</p>
</div></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>Le backtracking est une technique algorithmique puissante pour
résoudre des problèmes de recherche exhaustive. Sa complexité
exponentielle en fait un outil précieux pour modéliser et résoudre des
problèmes complexes, mais aussi un défi pour l’optimisation. Les
propriétés et théorèmes présentés dans cet article montrent la richesse
et la profondeur de cette notion, qui continue de fasciner les
chercheurs en informatique théorique.</p>
</body>
</html>
{% include "footer.html" %}

