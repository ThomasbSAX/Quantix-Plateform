{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de programmation quadratique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de programmation
quadratique</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La programmation quadratique (PQ) émerge comme une généralisation
naturelle de la programmation linéaire, où les contraintes et l’objectif
sont des fonctions quadratiques. Cette notion trouve ses racines dans
les travaux fondateurs de Kuhn et Tucker (1951) sur l’optimisation non
linéaire, mais c’est avec l’avènement des ordinateurs que son importance
a été pleinement révélée.</p>
<p>L’intérêt pour la PQ est motivé par son ubiquité dans les
applications pratiques, allant de l’ingénierie financière à la
conception de réseaux. Cependant, contrairement à la programmation
linéaire, la PQ présente des défis computationnels majeurs. En effet,
l’ajout de termes quadratiques introduit une non-linéarité qui peut
rendre le problème NP-difficile, même dans des cas apparemment
simples.</p>
<p>Dans ce chapitre, nous explorons la complexité computationnelle de la
PQ, en mettant l’accent sur les conditions sous lesquelles ces problèmes
deviennent intractables. Nous commencerons par définir formellement la
PQ, puis nous analyserons ses propriétés et ses implications en termes
de complexité.</p>
<h1 id="définitions">Définitions</h1>
<p>Avant d’aborder la complexité, il est essentiel de définir
précisément ce que nous entendons par programmation quadratique.
Considérons un problème d’optimisation où l’objectif est de minimiser
une fonction quadratique sous des contraintes linéaires.</p>
<p>Supposons que nous cherchions à minimiser une fonction <span
class="math inline">\(f: \mathbb{R}^n \rightarrow \mathbb{R}\)</span>
définie par : <span class="math display">\[f(x) = \frac{1}{2}x^T Q x +
c^T x\]</span> où <span class="math inline">\(Q\)</span> est une matrice
symétrique <span class="math inline">\(n \times n\)</span>, et <span
class="math inline">\(c\)</span> est un vecteur <span
class="math inline">\(n\)</span>-dimensionnel. Les contraintes sont
linéaires et peuvent être écrites sous la forme : <span
class="math display">\[Ax \leq b\]</span> où <span
class="math inline">\(A\)</span> est une matrice <span
class="math inline">\(m \times n\)</span> et <span
class="math inline">\(b\)</span> est un vecteur <span
class="math inline">\(m\)</span>-dimensionnel.</p>
<p>Nous cherchons donc à résoudre le problème suivant : <span
class="math display">\[\min_{x} \left\{ \frac{1}{2}x^T Q x + c^T x
\right\}\]</span> <span class="math display">\[\text{s.t.} \quad Ax \leq
b\]</span></p>
<p>Ce problème est appelé <em>programmation quadratique</em> (PQ). Il
est important de noter que si <span class="math inline">\(Q\)</span> est
positive semi-définie, le problème est convexe et peut être résolu
efficacement. Cependant, si <span class="math inline">\(Q\)</span> n’est
pas positive semi-définie, le problème peut avoir des minima locaux et
devenir NP-difficile.</p>
<h1 id="théorèmes">Théorèmes</h1>
<p>Pour comprendre la complexité de la PQ, nous devons examiner les
conditions sous lesquelles le problème devient intractable. Un résultat
fondamental dans ce domaine est le théorème suivant, dû à Pardalos et
Vavasis (1991) :</p>
<div class="theorem">
<p>Soit <span class="math inline">\(Q\)</span> une matrice symétrique.
Le problème de minimisation quadratique sous contraintes linéaires est
NP-difficile si et seulement si <span class="math inline">\(Q\)</span>
n’est pas positive semi-définie.</p>
</div>
<p>Pour démontrer ce théorème, nous devons d’abord comprendre pourquoi
la positivité semi-définie est cruciale. Si <span
class="math inline">\(Q\)</span> est positive semi-définie, la fonction
objectif est convexe, et le problème peut être résolu en temps
polynomial. Cependant, si <span class="math inline">\(Q\)</span> n’est
pas positive semi-définie, la fonction objectif peut avoir des minima
locaux, rendant le problème NP-difficile.</p>
<p>La démonstration de ce théorème repose sur une réduction polynomiale
à partir du problème de satisfaction booléenne (SAT), un problème
classique NP-complet. En effet, il est possible de montrer que le
problème de minimisation quadratique avec des contraintes linéaires peut
encoder un problème SAT, ce qui implique que le premier est au moins
aussi difficile que le second.</p>
<h1 id="preuves">Preuves</h1>
<p>Pour illustrer la démonstration du théorème de Pardalos-Vavasis,
considérons un problème SAT donné. Nous allons montrer comment l’encoder
en un problème de PQ.</p>
<p>Soit <span class="math inline">\(\phi\)</span> une formule booléenne
en forme normale conjonctive (CNF) avec <span
class="math inline">\(n\)</span> variables et <span
class="math inline">\(m\)</span> clauses. Nous voulons déterminer si
<span class="math inline">\(\phi\)</span> est satisfiable.</p>
<p>Pour chaque variable <span class="math inline">\(x_i\)</span>, nous
introduisons une variable réelle <span
class="math inline">\(y_i\)</span> telle que : <span
class="math display">\[y_i = 1 \text{ si } x_i \text{ est vrai}\]</span>
<span class="math display">\[y_i = -1 \text{ si } x_i \text{ est
faux}\]</span></p>
<p>Pour chaque clause <span class="math inline">\(C_j\)</span> de <span
class="math inline">\(\phi\)</span>, nous introduisons une contrainte
quadratique : <span class="math display">\[(y_{i_1} + y_{i_2} + \dots +
y_{i_k})^2 = 0\]</span> où <span class="math inline">\(x_{i_1}, x_{i_2},
\dots, x_{i_k}\)</span> sont les variables apparaissant dans <span
class="math inline">\(C_j\)</span>.</p>
<p>Le problème de minimisation quadratique correspondant est alors :
<span class="math display">\[\min_{y} \left\{ \sum_{j=1}^m (y_{i_1} +
y_{i_2} + \dots + y_{i_k})^2 \right\}\]</span> <span
class="math display">\[\text{s.t.} \quad y_i = 1 \text{ ou } y_i =
-1\]</span></p>
<p>Il est facile de voir que ce problème a une solution optimale nulle
si et seulement si <span class="math inline">\(\phi\)</span> est
satisfiable. En effet, si <span class="math inline">\(\phi\)</span> est
satisfiable, il existe une affectation des variables <span
class="math inline">\(x_i\)</span> qui rend chaque clause vraie, ce qui
implique que chaque terme quadratique est nul. Réciproquement, si le
problème de minimisation a une solution optimale nulle, cela signifie
que chaque clause est satisfaite par l’affectation correspondante des
variables <span class="math inline">\(y_i\)</span>.</p>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Nous allons maintenant énumérer quelques propriétés importantes de la
PQ, ainsi que leurs démonstrations.</p>
<ol>
<li><p>Si <span class="math inline">\(Q\)</span> est positive
semi-définie, le problème de PQ peut être résolu en temps
polynomial.</p>
<div class="proof">
<p><em>Proof.</em> Si <span class="math inline">\(Q\)</span> est
positive semi-définie, la fonction objectif est convexe. Les problèmes
d’optimisation convexe sous contraintes linéaires peuvent être résolus
efficacement en utilisant des méthodes telles que l’algorithme du
simplexe ou les méthodes de points intérieurs. Ces algorithmes ont une
complexité polynomiale en fonction du nombre de variables et de
contraintes. ◻</p>
</div></li>
<li><p>Si <span class="math inline">\(Q\)</span> n’est pas positive
semi-définie, le problème de PQ est NP-difficile.</p>
<div class="proof">
<p><em>Proof.</em> Cela découle directement du théorème de
Pardalos-Vavasis. Si <span class="math inline">\(Q\)</span> n’est pas
positive semi-définie, le problème peut encoder un problème SAT, qui est
NP-complet. Par conséquent, le problème de PQ est au moins aussi
difficile que SAT, et donc NP-difficile. ◻</p>
</div></li>
<li><p>Le problème de PQ peut être reformulé comme un problème
d’optimisation linéaire sous contraintes quadratiques.</p>
<div class="proof">
<p><em>Proof.</em> Considérons le problème de PQ : <span
class="math display">\[\min_{x} \left\{ \frac{1}{2}x^T Q x + c^T x
\right\}\]</span> <span class="math display">\[\text{s.t.} \quad Ax \leq
b\]</span></p>
<p>Nous pouvons introduire une nouvelle variable <span
class="math inline">\(z = Q^{1/2}x\)</span>, où <span
class="math inline">\(Q^{1/2}\)</span> est la matrice racine carrée de
<span class="math inline">\(Q\)</span>. Le problème devient alors :
<span class="math display">\[\min_{z} \left\{ \frac{1}{2}z^T z + c^T
Q^{-1/2} z \right\}\]</span> <span class="math display">\[\text{s.t.}
\quad A Q^{-1/2} z \leq b\]</span></p>
<p>Ce problème est équivalent au problème de PQ original, mais il est
formulé comme un problème d’optimisation linéaire sous contraintes
quadratiques. ◻</p>
</div></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>Dans ce chapitre, nous avons exploré la complexité des problèmes de
programmation quadratique. Nous avons vu que la positivité semi-définie
de la matrice <span class="math inline">\(Q\)</span> est une condition
cruciale pour la tractabilité du problème. Lorsque <span
class="math inline">\(Q\)</span> n’est pas positive semi-définie, le
problème devient NP-difficile, ce qui limite les méthodes efficaces pour
le résoudre.</p>
<p>Cependant, la PQ reste un outil puissant dans de nombreuses
applications pratiques. Les méthodes d’optimisation convexe, telles que
les algorithmes du simplexe et les méthodes de points intérieurs,
peuvent être utilisées efficacement lorsque <span
class="math inline">\(Q\)</span> est positive semi-définie. Pour les cas
où <span class="math inline">\(Q\)</span> n’est pas positive
semi-définie, des approches heuristiques et des méthodes d’approximation
peuvent être envisagées pour obtenir des solutions pratiques.</p>
<p>En conclusion, la compréhension de la complexité de la PQ est
essentielle pour développer des algorithmes efficaces et pour appliquer
cette méthode d’optimisation à des problèmes réels.</p>
</body>
</html>
{% include "footer.html" %}

