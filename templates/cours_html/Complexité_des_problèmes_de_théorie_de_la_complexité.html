{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de théorie de la complexité</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de théorie de la
complexité</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La théorie de la complexité computationnelle est une branche des
mathématiques et de l’informatique théorique qui étudie les ressources
nécessaires pour résoudre des problèmes algorithmiques. Elle émerge dans
les années 1960 et 1970 avec les travaux de Stephen Cook, Leonid Levin
et Richard Karp, qui posent les bases des classes de complexité P et NP.
Cette théorie est indispensable pour comprendre les limites
fondamentales des algorithmes et pour classer les problèmes en fonction
de leur difficulté.</p>
<p>L’objectif principal est de déterminer si un problème peut être
résolu efficacement, c’est-à-dire en temps polynomial, ou s’il nécessite
des ressources exponentielles. La théorie de la complexité permet
également d’étudier les relations entre différents problèmes et de
déterminer si des problèmes apparemment distincts sont en réalité
équivalents du point de vue computationnel.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre la complexité des problèmes, il est essentiel de
définir les notions fondamentales telles que les classes de complexité
et les réductions.</p>
<h2 id="classes-de-complexité">Classes de Complexité</h2>
<p>Considérons un problème décisionnel, c’est-à-dire un problème pour
lequel la réponse est soit "oui", soit "non". Nous cherchons à
déterminer si ce problème peut être résolu efficacement. Intuitivement,
une classe de complexité regroupe tous les problèmes qui peuvent être
résolus en utilisant une certaine quantité de ressources.</p>
<div class="definition">
<p>La classe P est l’ensemble des problèmes décisionnels qui peuvent
être résolus par une machine de Turing déterministe en temps polynomial.
Formellement, un problème <span class="math inline">\(L\)</span>
appartient à P si et seulement s’il existe une machine de Turing
déterministe <span class="math inline">\(M\)</span>, un polynôme <span
class="math inline">\(p\)</span>, et une fonction de codage <span
class="math inline">\(\phi\)</span> tels que pour toute entrée <span
class="math inline">\(x\)</span>, <span
class="math display">\[M(\phi(x)) \text{ s&#39;arrête en temps } \leq
p(|x|) \text{ et accepte si et seulement si } x \in L.\]</span></p>
</div>
<div class="definition">
<p>La classe NP est l’ensemble des problèmes décisionnels pour lesquels
une solution proposée peut être vérifiée par une machine de Turing
déterministe en temps polynomial. Formellement, un problème <span
class="math inline">\(L\)</span> appartient à NP si et seulement s’il
existe une machine de Turing déterministe <span
class="math inline">\(M\)</span>, un polynôme <span
class="math inline">\(p\)</span>, et une fonction de codage <span
class="math inline">\(\phi\)</span> tels que pour toute entrée <span
class="math inline">\(x\)</span>, <span class="math display">\[\exists
y, |y| \leq p(|x|) \text{ tel que } M(\phi(x, y)) \text{ s&#39;arrête en
temps } \leq p(|x|) \text{ et accepte si et seulement si } x \in
L.\]</span></p>
</div>
<h2 id="réductions">Réductions</h2>
<p>Les réductions permettent de comparer la difficulté des problèmes.
Intuitivement, un problème <span class="math inline">\(A\)</span> se
réduit à un problème <span class="math inline">\(B\)</span> si toute
instance de <span class="math inline">\(A\)</span> peut être transformée
en une instance de <span class="math inline">\(B\)</span> de telle sorte
que la solution de <span class="math inline">\(B\)</span> donne la
solution de <span class="math inline">\(A\)</span>.</p>
<div class="definition">
<p>Soient <span class="math inline">\(A\)</span> et <span
class="math inline">\(B\)</span> deux problèmes décisionnels. On dit que
<span class="math inline">\(A\)</span> se réduit polynomialement à <span
class="math inline">\(B\)</span>, noté <span class="math inline">\(A
\leq_p B\)</span>, s’il existe une fonction calculable en temps
polynomial <span class="math inline">\(f\)</span> telle que pour toute
entrée <span class="math inline">\(x\)</span>, <span
class="math display">\[x \in A \iff f(x) \in B.\]</span></p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<h2 id="théorème-de-cook-levin">Théorème de Cook-Levin</h2>
<p>Le théorème de Cook-Levin est un résultat fondamental en théorie de
la complexité. Il établit que le problème de satisfaction booléenne
(SAT) est NP-complet.</p>
<div class="theorem">
<p>Le problème SAT est NP-complet. Cela signifie que tout problème dans
NP peut être réduit polynomialement à SAT.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Pour démontrer ce théorème, nous devons montrer que
SAT est dans NP et que tout problème dans NP peut être réduit
polynomialement à SAT.</p>
<p>1. **SAT est dans NP** : Étant donné une formule booléenne <span
class="math inline">\(\phi\)</span> et une affectation de variables
<span class="math inline">\(y\)</span>, nous pouvons vérifier en temps
polynomial si <span class="math inline">\(y\)</span> satisfait <span
class="math inline">\(\phi\)</span>.</p>
<p>2. **Réduction polynomiale** : Soit <span
class="math inline">\(L\)</span> un problème dans NP. Par définition, il
existe une machine de Turing non déterministe <span
class="math inline">\(M\)</span> et un polynôme <span
class="math inline">\(p\)</span> tels que pour toute entrée <span
class="math inline">\(x\)</span>, il existe un mot <span
class="math inline">\(y\)</span> de longueur au plus <span
class="math inline">\(p(|x|)\)</span> tel que <span
class="math inline">\(M(x, y)\)</span> accepte. Nous pouvons construire
une formule booléenne <span class="math inline">\(\phi_x\)</span> qui
est satisfiable si et seulement si <span class="math inline">\(M(x,
y)\)</span> accepte pour un certain <span
class="math inline">\(y\)</span>. ◻</p>
</div>
<h2 id="théorème-de-lhierarchie">Théorème de l’hierarchie</h2>
<p>Le théorème de l’hierarchie établit une relation entre les classes de
complexité en fonction du temps de calcul.</p>
<div class="theorem">
<p>Si <span class="math inline">\(t(n)\)</span> est une fonction
croissante telle que pour tout <span class="math inline">\(n\)</span>,
<span class="math inline">\(t(n) \geq n\)</span> et <span
class="math inline">\(t(n+1) = O(t(n))\)</span>, alors la classe de
problèmes qui peuvent être résolus en temps <span
class="math inline">\(O(t(n))\)</span> est strictement incluse dans la
classe de problèmes qui peuvent être résolus en temps <span
class="math inline">\(O(t(n) \log t(n))\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> La preuve de ce théorème repose sur des techniques de
diagonalisation. Nous supposons par l’absurde que les deux classes sont
égales et construisons un problème qui peut être résolu en temps <span
class="math inline">\(O(t(n))\)</span> mais pas en temps <span
class="math inline">\(O(t(n) \log t(n))\)</span>, ce qui contredit notre
hypothèse. ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<h2 id="preuve-de-la-np-complétude-de-sat">Preuve de la NP-complétude de
SAT</h2>
<p>Pour démontrer que SAT est NP-complet, nous avons besoin de montrer
deux choses : que SAT est dans NP et que tout problème dans NP peut être
réduit polynomialement à SAT.</p>
<p>1. **SAT est dans NP** : Étant donné une formule booléenne <span
class="math inline">\(\phi\)</span> et une affectation de variables
<span class="math inline">\(y\)</span>, nous pouvons vérifier en temps
polynomial si <span class="math inline">\(y\)</span> satisfait <span
class="math inline">\(\phi\)</span>. Cela se fait en évaluant chaque
clause de <span class="math inline">\(\phi\)</span> avec l’affectation
<span class="math inline">\(y\)</span>.</p>
<p>2. **Réduction polynomiale** : Soit <span
class="math inline">\(L\)</span> un problème dans NP. Par définition, il
existe une machine de Turing non déterministe <span
class="math inline">\(M\)</span> et un polynôme <span
class="math inline">\(p\)</span> tels que pour toute entrée <span
class="math inline">\(x\)</span>, il existe un mot <span
class="math inline">\(y\)</span> de longueur au plus <span
class="math inline">\(p(|x|)\)</span> tel que <span
class="math inline">\(M(x, y)\)</span> accepte. Nous pouvons construire
une formule booléenne <span class="math inline">\(\phi_x\)</span> qui
est satisfiable si et seulement si <span class="math inline">\(M(x,
y)\)</span> accepte pour un certain <span
class="math inline">\(y\)</span>. Cette construction peut être faite en
temps polynomial.</p>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<h2 id="propriétés-des-classes-de-complexité">Propriétés des Classes de
Complexité</h2>
<ol>
<li><p>Si <span class="math inline">\(A \leq_p B\)</span> et <span
class="math inline">\(B \in P\)</span>, alors <span
class="math inline">\(A \in P\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> Puisque <span class="math inline">\(B \in P\)</span>,
il existe une machine de Turing déterministe <span
class="math inline">\(M\)</span> qui résout <span
class="math inline">\(B\)</span> en temps polynomial. Comme <span
class="math inline">\(A \leq_p B\)</span>, il existe une réduction
polynomiale <span class="math inline">\(f\)</span> telle que <span
class="math inline">\(x \in A \iff f(x) \in B\)</span>. Nous pouvons
donc résoudre <span class="math inline">\(A\)</span> en appliquant <span
class="math inline">\(f\)</span> à <span
class="math inline">\(x\)</span> et en utilisant <span
class="math inline">\(M\)</span> pour résoudre <span
class="math inline">\(B\)</span>. ◻</p>
</div></li>
<li><p>Si <span class="math inline">\(A\)</span> est NP-complet et <span
class="math inline">\(A \in P\)</span>, alors <span
class="math inline">\(P = NP\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> Puisque <span class="math inline">\(A\)</span> est
NP-complet, tout problème dans NP peut être réduit polynomialement à
<span class="math inline">\(A\)</span>. Si <span class="math inline">\(A
\in P\)</span>, alors tous les problèmes dans NP peuvent être résolus en
temps polynomial, ce qui implique que <span class="math inline">\(P =
NP\)</span>. ◻</p>
</div></li>
<li><p>Si <span class="math inline">\(A \leq_p B\)</span> et <span
class="math inline">\(B\)</span> est NP-difficile, alors <span
class="math inline">\(A\)</span> est NP-difficile.</p>
<div class="proof">
<p><em>Proof.</em> Puisque <span class="math inline">\(B\)</span> est
NP-difficile, tout problème dans NP peut être réduit polynomialement à
<span class="math inline">\(B\)</span>. Comme <span
class="math inline">\(A \leq_p B\)</span>, tout problème dans NP peut
être réduit polynomialement à <span class="math inline">\(A\)</span> via
<span class="math inline">\(B\)</span>, ce qui implique que <span
class="math inline">\(A\)</span> est NP-difficile. ◻</p>
</div></li>
</ol>
<h2 id="corollaires-du-théorème-de-cook-levin">Corollaires du Théorème
de Cook-Levin</h2>
<ol>
<li><p>Tout problème NP-complet est NP-difficile.</p>
<div class="proof">
<p><em>Proof.</em> Par définition, un problème NP-complet est à la fois
dans NP et NP-difficile. Donc, tout problème NP-complet est
NP-difficile. ◻</p>
</div></li>
<li><p>Si un problème dans P est NP-difficile, alors <span
class="math inline">\(P = NP\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> Si un problème dans P est NP-difficile, alors tous
les problèmes dans NP peuvent être résolus en temps polynomial, ce qui
implique que <span class="math inline">\(P = NP\)</span>. ◻</p>
</div></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>La théorie de la complexité computationnelle est un domaine riche et
fascinant qui permet de comprendre les limites fondamentales des
algorithmes. Les classes de complexité, telles que P et NP, ainsi que
les notions de réductions et de NP-complétude sont des outils essentiels
pour classer et étudier les problèmes algorithmiques. Les théorèmes de
Cook-Levin et de l’hierarchie sont des résultats fondamentaux qui ont
profondément influencé le développement de ce domaine. Les preuves
détaillées et les propriétés des classes de complexité offrent une
compréhension approfondie des relations entre différents problèmes et
des ressources nécessaires pour les résoudre.</p>
</body>
</html>
{% include "footer.html" %}

