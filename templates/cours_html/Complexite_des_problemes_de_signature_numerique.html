{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de signature numérique</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de signature numérique</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La cryptographie, en tant que discipline mathématique et
informatique, a toujours été au cœur des préoccupations de sécurité dans
les communications numériques. Parmi ses nombreux aspects, la signature
numérique occupe une place prépondérante. Elle permet d’assurer
l’authenticité, l’intégrité et la non-répudiation des messages échangés
dans un environnement potentiellement hostile.</p>
<p>L’origine historique de la signature numérique remonte aux travaux
pionniers de Whitfield Diffie et Martin Hellman en 1976, qui ont
introduit le concept de cryptographie à clé publique. Ce paradigme a
ouvert la voie à des schémas de signature numérique, où une paire de
clés (publique et privée) est utilisée pour signer et vérifier des
messages. Les premiers schémas, comme celui de Rivest, Shamir et Adleman
(RSA), ont rapidement été adoptés et standardisés.</p>
<p>La notion de complexité des problèmes de signature numérique émerge
naturellement dans ce contexte. Elle vise à comprendre et quantifier la
difficulté intrinsèque des problèmes sous-jacents aux schémas de
signature. Cette compréhension est indispensable pour évaluer la
robustesse des systèmes cryptographiques et pour guider le développement
de nouveaux schémas plus sécurisés.</p>
<p>En effet, la sécurité d’un schéma de signature repose sur l’hypothèse
que certains problèmes mathématiques sous-jacents sont difficiles à
résoudre. Par exemple, la sécurité du schéma RSA repose sur la
difficulté présumée de factoriser de grands nombres entiers. Cependant,
avec l’avènement des ordinateurs quantiques, cette hypothèse pourrait
être remise en question. Il est donc crucial d’étudier la complexité de
ces problèmes pour anticiper les menaces futures et développer des
contre-mesures appropriées.</p>
<h1 id="définitions">Définitions</h1>
<p>Avant de plonger dans les détails techniques, il est essentiel de
comprendre ce que nous cherchons à définir. Nous voulons capturer l’idée
de difficulté algorithmique, c’est-à-dire la quantité de ressources
(temps, mémoire) nécessaire pour résoudre un problème donné. En
cryptographie, nous nous intéressons particulièrement aux problèmes qui
sont faciles à vérifier mais difficiles à résoudre.</p>
<p>Nous commençons par définir formellement la notion de problème de
décision. Un problème de décision est un ensemble de paires <span
class="math inline">\((x, b)\)</span> où <span
class="math inline">\(x\)</span> est une instance du problème et <span
class="math inline">\(b \in \{0, 1\}\)</span> est le résultat. Le
problème consiste à déterminer si une instance donnée appartient au
langage associé.</p>
<div class="definition">
<p>Soit <span class="math inline">\(L \subseteq \{0, 1\}^*\)</span> un
langage. Le problème de décision associé à <span
class="math inline">\(L\)</span> est défini comme suit : <span
class="math display">\[\text{Problème de décision pour } L : \text{Étant
donné } x \in \{0, 1\}^*, \text{ déterminer si } x \in L.\]</span></p>
</div>
<p>Nous pouvons également définir la notion de problème de recherche,
qui est plus générale et inclut les problèmes où l’on cherche à trouver
une solution plutôt qu’à répondre par oui ou non.</p>
<div class="definition">
<p>Soit <span class="math inline">\(R \subseteq \{0, 1\}^* \times \{0,
1\}^*\)</span> une relation. Le problème de recherche associé à <span
class="math inline">\(R\)</span> est défini comme suit : <span
class="math display">\[\text{Problème de recherche pour } R :
\text{Étant donné } x \in \{0, 1\}^*, \text{ trouver } y \in \{0, 1\}^*
\text{ tel que } (x, y) \in R.\]</span></p>
</div>
<p>En cryptographie, nous nous intéressons souvent à des problèmes
spécifiques qui sont utilisés comme fondements pour la sécurité des
schémas. Par exemple, le problème du logarithme discret est un problème
de recherche central en cryptographie à clé publique.</p>
<div class="definition">
<p>Soit <span class="math inline">\(G\)</span> un groupe cyclique
d’ordre <span class="math inline">\(n\)</span>, généré par <span
class="math inline">\(g\)</span>. Le problème du logarithme discret
(DLP) est défini comme suit : <span class="math display">\[\text{DLP} :
\text{Étant donné } (G, g, h), \text{ trouver } x \in \mathbb{Z}_n
\text{ tel que } h = g^x.\]</span></p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<p>Nous allons maintenant explorer quelques théorèmes fondamentaux liés
à la complexité des problèmes de signature numérique. Ces théorèmes nous
aideront à comprendre les relations entre différents problèmes et à
évaluer leur difficulté relative.</p>
<p>Le premier théorème que nous présentons est le théorème de réduction
polynomiale. Ce théorème est central en théorie de la complexité et
permet de relier la difficulté de différents problèmes.</p>
<div class="theorem">
<p>Soient <span class="math inline">\(A\)</span> et <span
class="math inline">\(B\)</span> deux problèmes de décision. On dit que
<span class="math inline">\(A\)</span> se réduit polynomialement à <span
class="math inline">\(B\)</span>, noté <span class="math inline">\(A
\leq_p B\)</span>, s’il existe une fonction calculable en temps
polynomial <span class="math inline">\(f\)</span> telle que pour toute
instance <span class="math inline">\(x\)</span> de <span
class="math inline">\(A\)</span>, on a : <span class="math display">\[x
\in A \iff f(x) \in B.\]</span></p>
</div>
<p>Ce théorème nous permet de montrer que si un problème est difficile,
alors tous les problèmes auxquels il se réduit polynomialement sont
également difficiles. Par exemple, si nous pouvons montrer que le
problème du logarithme discret se réduit polynomialement à un autre
problème, alors la difficulté de ce dernier problème est au moins aussi
grande que celle du DLP.</p>
<p>Un autre théorème important est le théorème de Cook-Levin, qui
établit la NP-complétude du problème de satisfaction booléenne
(SAT).</p>
<div class="theorem">
<p>Le problème de satisfaction booléenne (SAT) est NP-complet. Cela
signifie que :</p>
<ul>
<li><p>SAT est dans NP.</p></li>
<li><p>Tout problème dans NP se réduit polynomialement à SAT.</p></li>
</ul>
</div>
<p>Ce théorème est fondamental car il montre que tous les problèmes dans
la classe NP sont au moins aussi difficiles que SAT. En cryptographie,
nous utilisons souvent des problèmes qui sont conjecturés être
difficiles, mais nous ne savons pas toujours s’ils sont NP-complets.</p>
<h1 id="preuves">Preuves</h1>
<p>Nous allons maintenant fournir des preuves détaillées pour les
théorèmes présentés. Ces preuves sont essentielles pour comprendre la
validité des résultats et pour apprécier leur portée.</p>
<div class="proof">
<p><em>Preuve du théorème de réduction polynomiale.</em> Soient <span
class="math inline">\(A\)</span> et <span
class="math inline">\(B\)</span> deux problèmes de décision, et
supposons qu’il existe une fonction calculable en temps polynomial <span
class="math inline">\(f\)</span> telle que pour toute instance <span
class="math inline">\(x\)</span> de <span
class="math inline">\(A\)</span>, on a : <span class="math display">\[x
\in A \iff f(x) \in B.\]</span> Nous devons montrer que si <span
class="math inline">\(B\)</span> est difficile (par exemple, ne peut pas
être résolu en temps polynomial), alors <span
class="math inline">\(A\)</span> est également difficile.</p>
<p>Supposons par l’absurde qu’il existe un algorithme en temps
polynomial <span class="math inline">\(M\)</span> qui résout <span
class="math inline">\(A\)</span>. Nous pouvons alors construire un
algorithme pour résoudre <span class="math inline">\(B\)</span> en
utilisant <span class="math inline">\(M\)</span> et <span
class="math inline">\(f\)</span>. L’algorithme consiste à appliquer
<span class="math inline">\(f\)</span> à l’instance <span
class="math inline">\(x\)</span> de <span
class="math inline">\(B\)</span>, puis à exécuter <span
class="math inline">\(M\)</span> sur le résultat. Si <span
class="math inline">\(M\)</span> accepte, alors nous acceptons ; sinon,
nous rejetons.</p>
<p>Puisque <span class="math inline">\(f\)</span> et <span
class="math inline">\(M\)</span> sont tous deux calculables en temps
polynomial, l’algorithme résultant est également en temps polynomial.
Cela contredit l’hypothèse que <span class="math inline">\(B\)</span>
est difficile. Par conséquent, si <span class="math inline">\(B\)</span>
est difficile, alors <span class="math inline">\(A\)</span> est
également difficile. ◻</p>
</div>
<div class="proof">
<p><em>Preuve du théorème de Cook-Levin.</em> Nous allons montrer que
SAT est dans NP et que tout problème dans NP se réduit polynomialement à
SAT.</p>
<h4 id="preuve-que-sat-est-dans-np">Preuve que SAT est dans NP</h4>
<p>Soit <span class="math inline">\(\phi\)</span> une formule booléenne.
Si <span class="math inline">\(\phi\)</span> est satisfaisable, alors il
existe une affectation des variables qui rend <span
class="math inline">\(\phi\)</span> vraie. Cette affectation peut être
utilisée comme certificat pour montrer que <span
class="math inline">\(\phi \in SAT\)</span>. Le vérificateur peut
simplement évaluer <span class="math inline">\(\phi\)</span> avec
l’affectation donnée et accepter si le résultat est vrai.</p>
<p>Le vérificateur peut être implémenté en temps polynomial, car
l’évaluation d’une formule booléenne est une opération linéaire en la
taille de la formule.</p>
<h4
id="preuve-que-tout-problème-dans-np-se-réduit-polynomialement-à-sat">Preuve
que tout problème dans NP se réduit polynomialement à SAT</h4>
<p>Soit <span class="math inline">\(L\)</span> un langage dans NP. Par
définition, il existe une relation <span
class="math inline">\(R_L\)</span> et un polynôme <span
class="math inline">\(p\)</span> tels que pour toute instance <span
class="math inline">\(x \in L\)</span>, il existe un certificat <span
class="math inline">\(y\)</span> de taille au plus <span
class="math inline">\(p(|x|)\)</span> tel que <span
class="math inline">\((x, y) \in R_L\)</span>.</p>
<p>Nous pouvons construire une formule booléenne <span
class="math inline">\(\phi_{x,y}\)</span> qui est vraie si et seulement
si <span class="math inline">\((x, y) \in R_L\)</span>. Cette formule
peut être construite de manière à encoder les conditions de <span
class="math inline">\(R_L\)</span> en termes de variables
booléennes.</p>
<p>Ensuite, nous pouvons construire une formule <span
class="math inline">\(\phi_x\)</span> qui est vraie si et seulement s’il
existe un <span class="math inline">\(y\)</span> de taille au plus <span
class="math inline">\(p(|x|)\)</span> tel que <span
class="math inline">\((x, y) \in R_L\)</span>. Cette formule peut être
construite en utilisant des opérateurs booléens pour itérer sur toutes
les possibilités de <span class="math inline">\(y\)</span>.</p>
<p>Enfin, nous pouvons montrer que <span class="math inline">\(x \in
L\)</span> si et seulement si <span
class="math inline">\(\phi_x\)</span> est satisfaisable. Cela montre que
<span class="math inline">\(L\)</span> se réduit polynomialement à
SAT. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Nous allons maintenant présenter quelques propriétés et corollaires
importants liés à la complexité des problèmes de signature
numérique.</p>
<div class="corollary">
<p>Si un problème NP-complet peut être résolu en temps polynomial, alors
P = NP.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Supposons qu’un problème NP-complet <span
class="math inline">\(A\)</span> peut être résolu en temps polynomial.
Puisque tout problème dans NP se réduit polynomialement à <span
class="math inline">\(A\)</span>, nous pouvons résoudre tout problème
dans NP en temps polynomial. Cela implique que P = NP. ◻</p>
</div>
<div class="property">
<p>Si <span class="math inline">\(A \leq_p B\)</span> et <span
class="math inline">\(B \leq_p C\)</span>, alors <span
class="math inline">\(A \leq_p C\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Puisque <span class="math inline">\(A \leq_p
B\)</span>, il existe une fonction calculable en temps polynomial <span
class="math inline">\(f\)</span> telle que pour toute instance <span
class="math inline">\(x\)</span> de <span
class="math inline">\(A\)</span>, on a : <span class="math display">\[x
\in A \iff f(x) \in B.\]</span> De même, puisque <span
class="math inline">\(B \leq_p C\)</span>, il existe une fonction
calculable en temps polynomial <span class="math inline">\(g\)</span>
telle que pour toute instance <span class="math inline">\(y\)</span> de
<span class="math inline">\(B\)</span>, on a : <span
class="math display">\[y \in B \iff g(y) \in C.\]</span> Nous pouvons
alors construire une fonction <span class="math inline">\(h\)</span>
définie par <span class="math inline">\(h(x) = g(f(x))\)</span>. Puisque
<span class="math inline">\(f\)</span> et <span
class="math inline">\(g\)</span> sont calculables en temps polynomial,
<span class="math inline">\(h\)</span> est également calculable en temps
polynomial. De plus, pour toute instance <span
class="math inline">\(x\)</span> de <span
class="math inline">\(A\)</span>, on a : <span class="math display">\[x
\in A \iff f(x) \in B \iff g(f(x)) \in C.\]</span> Cela montre que <span
class="math inline">\(A \leq_p C\)</span>. ◻</p>
</div>
<div class="property">
<p>Si <span class="math inline">\(A \leq_p B\)</span> et <span
class="math inline">\(B\)</span> est dans P, alors <span
class="math inline">\(A\)</span> est dans P.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Puisque <span class="math inline">\(B\)</span> est
dans P, il existe un algorithme en temps polynomial <span
class="math inline">\(M\)</span> qui résout <span
class="math inline">\(B\)</span>. Puisque <span class="math inline">\(A
\leq_p B\)</span>, il existe une fonction calculable en temps polynomial
<span class="math inline">\(f\)</span> telle que pour toute instance
<span class="math inline">\(x\)</span> de <span
class="math inline">\(A\)</span>, on a : <span class="math display">\[x
\in A \iff f(x) \in B.\]</span> Nous pouvons alors construire un
algorithme pour résoudre <span class="math inline">\(A\)</span> en
utilisant <span class="math inline">\(M\)</span> et <span
class="math inline">\(f\)</span>. L’algorithme consiste à appliquer
<span class="math inline">\(f\)</span> à l’instance <span
class="math inline">\(x\)</span> de <span
class="math inline">\(A\)</span>, puis à exécuter <span
class="math inline">\(M\)</span> sur le résultat. Si <span
class="math inline">\(M\)</span> accepte, alors nous acceptons ; sinon,
nous rejetons.</p>
<p>Puisque <span class="math inline">\(f\)</span> et <span
class="math inline">\(M\)</span> sont tous deux calculables en temps
polynomial, l’algorithme résultant est également en temps polynomial.
Cela montre que <span class="math inline">\(A\)</span> est dans P. ◻</p>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>Dans cet article, nous avons exploré la complexité des problèmes de
signature numérique. Nous avons présenté les définitions fondamentales,
les théorèmes clés et leurs preuves détaillées. Nous avons également
discuté des propriétés et corollaires importants.</p>
<p>La compréhension de la complexité des problèmes de signature
numérique est cruciale pour le développement de systèmes
cryptographiques robustes. En étudiant la difficulté des problèmes
sous-jacents, nous pouvons évaluer la sécurité des schémas de signature
et anticiper les menaces futures. Les résultats présentés dans cet
article fournissent une base solide pour de futures recherches dans ce
domaine.</p>
</body>
</html>
{% include "footer.html" %}

