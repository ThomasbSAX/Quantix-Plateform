{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de calcul distribué</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de calcul distribué</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>Le calcul distribué est un domaine de l’informatique qui étudie les
systèmes composés de plusieurs entités indépendantes capables de
communiquer entre elles pour résoudre des problèmes complexes. L’origine
historique du calcul distribué remonte aux années 1960 avec les travaux
de J.C.R. Licklider sur l’interconnexion des ordinateurs et ceux de Paul
Baran sur les réseaux décentralisés. Ce domaine a connu un essor
considérable avec l’avènement d’Internet et des technologies de cloud
computing.</p>
<p>Le calcul distribué émerge comme une nécessité face à la complexité
croissante des problèmes à résoudre. En effet, certains problèmes sont
trop volumineux ou trop complexes pour être traités par un seul
ordinateur. Le calcul distribué permet de répartir la charge de travail
entre plusieurs machines, ce qui améliore l’efficacité et la robustesse
des solutions. De plus, il offre une meilleure tolérance aux pannes, car
la défaillance d’une machine n’entraîne pas nécessairement l’échec du
système entier.</p>
<p>Dans ce chapitre, nous nous intéressons à la complexité des problèmes
de calcul distribué. La complexité mesure la difficulté d’un problème en
termes de ressources nécessaires pour le résoudre, telles que le temps
de calcul et la mémoire. Comprendre la complexité des problèmes
distribués est indispensable pour concevoir des algorithmes efficaces et
optimiser les performances des systèmes distribués.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour étudier la complexité des problèmes de calcul distribué,
commençons par définir quelques notions fondamentales.</p>
<h2 id="problème-distribué">Problème Distribué</h2>
<p>Un problème distribué est un problème dont la résolution nécessite la
coopération de plusieurs entités indépendantes, appelées nœuds ou
processeurs. Chaque nœud dispose de ses propres ressources et peut
communiquer avec les autres nœuds via un réseau.</p>
<p>Formellement, un problème distribué <span
class="math inline">\(\mathcal{P}\)</span> peut être défini comme un
quadruplet <span class="math inline">\((I, O, \mathcal{A},
\mathcal{C})\)</span>, où :</p>
<ul>
<li><p><span class="math inline">\(I\)</span> est l’ensemble des
instances du problème,</p></li>
<li><p><span class="math inline">\(O\)</span> est l’ensemble des
solutions possibles,</p></li>
<li><p><span class="math inline">\(\mathcal{A}\)</span> est l’ensemble
des algorithmes distribués capables de résoudre le problème,</p></li>
<li><p><span class="math inline">\(\mathcal{C}\)</span> est une fonction
de complexité qui associe à chaque algorithme <span
class="math inline">\(A \in \mathcal{A}\)</span> et à chaque instance
<span class="math inline">\(i \in I\)</span> une valeur représentant la
complexité de l’algorithme pour résoudre l’instance.</p></li>
</ul>
<p>En termes quantifiés, nous pouvons écrire : <span
class="math display">\[\forall A \in \mathcal{A}, \forall i \in I,
\exists c \in \mathbb{R}^+, \mathcal{C}(A, i) = c\]</span></p>
<h2 id="complexité-distribuée">Complexité Distribuée</h2>
<p>La complexité distribuée d’un problème mesure la difficulté de
résoudre ce problème dans un environnement distribué. Elle peut être
définie en termes de temps, d’espace ou de communication.</p>
<p>La complexité temporelle distribuée mesure le temps nécessaire pour
résoudre un problème dans un système distribué. Elle peut être exprimée
en nombre d’étapes de communication ou en temps réel.</p>
<p>Formellement, la complexité temporelle distribuée <span
class="math inline">\(\mathcal{T}\)</span> d’un algorithme <span
class="math inline">\(A\)</span> pour une instance <span
class="math inline">\(i\)</span> est définie par : <span
class="math display">\[\mathcal{T}(A, i) = \max_{n \in N} T_n(A,
i)\]</span> où <span class="math inline">\(N\)</span> est l’ensemble des
nœuds du système et <span class="math inline">\(T_n(A, i)\)</span> est
le temps nécessaire au nœud <span class="math inline">\(n\)</span> pour
terminer l’exécution de l’algorithme <span
class="math inline">\(A\)</span> sur l’instance <span
class="math inline">\(i\)</span>.</p>
<p>La complexité spatiale distribuée mesure la quantité de mémoire
nécessaire pour résoudre un problème dans un système distribué. Elle
peut être exprimée en termes de mémoire locale ou globale.</p>
<p>Formellement, la complexité spatiale distribuée <span
class="math inline">\(\mathcal{S}\)</span> d’un algorithme <span
class="math inline">\(A\)</span> pour une instance <span
class="math inline">\(i\)</span> est définie par : <span
class="math display">\[\mathcal{S}(A, i) = \max_{n \in N} S_n(A,
i)\]</span> où <span class="math inline">\(S_n(A, i)\)</span> est la
quantité de mémoire utilisée par le nœud <span
class="math inline">\(n\)</span> pour exécuter l’algorithme <span
class="math inline">\(A\)</span> sur l’instance <span
class="math inline">\(i\)</span>.</p>
<p>La complexité de communication distribuée mesure la quantité
d’informations échangées entre les nœuds pour résoudre un problème. Elle
peut être exprimée en nombre de messages ou en bits transmis.</p>
<p>Formellement, la complexité de communication distribuée <span
class="math inline">\(\mathcal{C}\)</span> d’un algorithme <span
class="math inline">\(A\)</span> pour une instance <span
class="math inline">\(i\)</span> est définie par : <span
class="math display">\[\mathcal{C}(A, i) = \sum_{(n, m) \in E}
C_{n,m}(A, i)\]</span> où <span class="math inline">\(E\)</span> est
l’ensemble des paires de nœuds connectés et <span
class="math inline">\(C_{n,m}(A, i)\)</span> est la quantité
d’informations échangées entre les nœuds <span
class="math inline">\(n\)</span> et <span
class="math inline">\(m\)</span> pour exécuter l’algorithme <span
class="math inline">\(A\)</span> sur l’instance <span
class="math inline">\(i\)</span>.</p>
<h1 id="théorèmes">Théorèmes</h1>
<p>Dans cette section, nous présentons quelques théorèmes importants
concernant la complexité des problèmes de calcul distribué.</p>
<h2 id="théorème-de-lower-bound">Théorème de Lower Bound</h2>
<p>Le théorème de lower bound établit une borne inférieure sur la
complexité d’un problème distribué. Il permet de déterminer la
complexité minimale nécessaire pour résoudre un problème, indépendamment
de l’algorithme utilisé.</p>
<p>Formellement, le théorème de lower bound peut être énoncé comme suit
:</p>
<div class="theorem">
<p>Soit <span class="math inline">\(\mathcal{P}\)</span> un problème
distribué et <span class="math inline">\(\mathcal{C}\)</span> une
fonction de complexité. Si pour tout algorithme <span
class="math inline">\(A \in \mathcal{A}\)</span>, il existe une instance
<span class="math inline">\(i \in I\)</span> telle que <span
class="math inline">\(\mathcal{C}(A, i) \geq c\)</span>, alors la
complexité minimale de <span class="math inline">\(\mathcal{P}\)</span>
est au moins <span class="math inline">\(c\)</span>.</p>
</div>
<p>En termes quantifiés, nous pouvons écrire : <span
class="math display">\[\forall A \in \mathcal{A}, \exists i \in I,
\mathcal{C}(A, i) \geq c \implies \min_{A \in \mathcal{A}, i \in I}
\mathcal{C}(A, i) \geq c\]</span></p>
<h2 id="théorème-de-upper-bound">Théorème de Upper Bound</h2>
<p>Le théorème de upper bound établit une borne supérieure sur la
complexité d’un problème distribué. Il permet de déterminer la
complexité maximale nécessaire pour résoudre un problème, en utilisant
un algorithme spécifique.</p>
<p>Formellement, le théorème de upper bound peut être énoncé comme suit
:</p>
<div class="theorem">
<p>Soit <span class="math inline">\(\mathcal{P}\)</span> un problème
distribué, <span class="math inline">\(A \in \mathcal{A}\)</span> un
algorithme et <span class="math inline">\(\mathcal{C}\)</span> une
fonction de complexité. Si pour toute instance <span
class="math inline">\(i \in I\)</span>, <span
class="math inline">\(\mathcal{C}(A, i) \leq c\)</span>, alors la
complexité maximale de <span class="math inline">\(\mathcal{P}\)</span>
en utilisant l’algorithme <span class="math inline">\(A\)</span> est au
plus <span class="math inline">\(c\)</span>.</p>
</div>
<p>En termes quantifiés, nous pouvons écrire : <span
class="math display">\[\forall i \in I, \mathcal{C}(A, i) \leq c
\implies \max_{i \in I} \mathcal{C}(A, i) \leq c\]</span></p>
<h1 id="preuves">Preuves</h1>
<p>Dans cette section, nous fournissons des preuves détaillées pour les
théorèmes présentés dans la section précédente.</p>
<h2 id="preuve-du-théorème-de-lower-bound">Preuve du Théorème de Lower
Bound</h2>
<p>Pour prouver le théorème de lower bound, nous devons montrer que pour
tout algorithme <span class="math inline">\(A \in \mathcal{A}\)</span>,
il existe une instance <span class="math inline">\(i \in I\)</span>
telle que <span class="math inline">\(\mathcal{C}(A, i) \geq
c\)</span>.</p>
<p>Supposons par l’absurde qu’il existe un algorithme <span
class="math inline">\(A \in \mathcal{A}\)</span> tel que pour toute
instance <span class="math inline">\(i \in I\)</span>, <span
class="math inline">\(\mathcal{C}(A, i) &lt; c\)</span>. Cela contredit
l’hypothèse du théorème selon laquelle pour tout algorithme <span
class="math inline">\(A \in \mathcal{A}\)</span>, il existe une instance
<span class="math inline">\(i \in I\)</span> telle que <span
class="math inline">\(\mathcal{C}(A, i) \geq c\)</span>. Par conséquent,
notre supposition est fausse et le théorème de lower bound est
prouvé.</p>
<p>En termes quantifiés, nous pouvons écrire : <span
class="math display">\[\exists A \in \mathcal{A}, \forall i \in I,
\mathcal{C}(A, i) &lt; c \implies \exists A \in \mathcal{A}, \exists i
\in I, \mathcal{C}(A, i) \geq c\]</span></p>
<h2 id="preuve-du-théorème-de-upper-bound">Preuve du Théorème de Upper
Bound</h2>
<p>Pour prouver le théorème de upper bound, nous devons montrer que pour
tout algorithme <span class="math inline">\(A \in \mathcal{A}\)</span>
et toute instance <span class="math inline">\(i \in I\)</span>, <span
class="math inline">\(\mathcal{C}(A, i) \leq c\)</span>.</p>
<p>Supposons que pour un algorithme <span class="math inline">\(A \in
\mathcal{A}\)</span> et une instance <span class="math inline">\(i \in
I\)</span>, <span class="math inline">\(\mathcal{C}(A, i) &gt;
c\)</span>. Cela contredit l’hypothèse du théorème selon laquelle pour
toute instance <span class="math inline">\(i \in I\)</span>, <span
class="math inline">\(\mathcal{C}(A, i) \leq c\)</span>. Par conséquent,
notre supposition est fausse et le théorème de upper bound est
prouvé.</p>
<p>En termes quantifiés, nous pouvons écrire : <span
class="math display">\[\exists A \in \mathcal{A}, \exists i \in I,
\mathcal{C}(A, i) &gt; c \implies \forall A \in \mathcal{A}, \forall i
\in I, \mathcal{C}(A, i) \leq c\]</span></p>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Dans cette section, nous présentons quelques propriétés et
corollaires liés à la complexité des problèmes de calcul distribué.</p>
<h2 id="propriété-de-composition">Propriété de Composition</h2>
<p>La propriété de composition établit que la complexité d’un problème
distribué composé de plusieurs sous-problèmes est au moins égale à la
somme des complexités des sous-problèmes.</p>
<p>Formellement, la propriété de composition peut être énoncée comme
suit :</p>
<div class="proposition">
<p>Soit <span class="math inline">\(\mathcal{P}_1, \mathcal{P}_2,
\ldots, \mathcal{P}_k\)</span> des problèmes distribués et <span
class="math inline">\(\mathcal{C}\)</span> une fonction de complexité.
Si pour chaque <span class="math inline">\(i \in \{1, 2, \ldots,
k\}\)</span>, la complexité minimale de <span
class="math inline">\(\mathcal{P}_i\)</span> est <span
class="math inline">\(c_i\)</span>, alors la complexité minimale du
problème composé <span class="math inline">\(\mathcal{P} = \mathcal{P}_1
\cup \mathcal{P}_2 \cup \ldots \cup \mathcal{P}_k\)</span> est au moins
<span class="math inline">\(\sum_{i=1}^k c_i\)</span>.</p>
</div>
<p>En termes quantifiés, nous pouvons écrire : <span
class="math display">\[\forall i \in \{1, 2, \ldots, k\}, \min_{A \in
\mathcal{A}_i, j \in I_i} \mathcal{C}(A, j) = c_i \implies \min_{A \in
\mathcal{A}, i \in I} \mathcal{C}(A, i) \geq \sum_{i=1}^k
c_i\]</span></p>
<h2 id="corollaire-de-la-propriété-de-composition">Corollaire de la
Propriété de Composition</h2>
<p>Le corollaire de la propriété de composition établit que la
complexité d’un problème distribué composé de plusieurs sous-problèmes
est au plus égale à la somme des complexités des sous-problèmes.</p>
<p>Formellement, le corollaire de la propriété de composition peut être
énoncé comme suit :</p>
<div class="corollary">
<p>Soit <span class="math inline">\(\mathcal{P}_1, \mathcal{P}_2,
\ldots, \mathcal{P}_k\)</span> des problèmes distribués et <span
class="math inline">\(\mathcal{C}\)</span> une fonction de complexité.
Si pour chaque <span class="math inline">\(i \in \{1, 2, \ldots,
k\}\)</span>, la complexité maximale de <span
class="math inline">\(\mathcal{P}_i\)</span> est <span
class="math inline">\(c_i\)</span>, alors la complexité maximale du
problème composé <span class="math inline">\(\mathcal{P} = \mathcal{P}_1
\cup \mathcal{P}_2 \cup \ldots \cup \mathcal{P}_k\)</span> est au plus
<span class="math inline">\(\sum_{i=1}^k c_i\)</span>.</p>
</div>
<p>En termes quantifiés, nous pouvons écrire : <span
class="math display">\[\forall i \in \{1, 2, \ldots, k\}, \max_{A \in
\mathcal{A}_i, j \in I_i} \mathcal{C}(A, j) = c_i \implies \max_{A \in
\mathcal{A}, i \in I} \mathcal{C}(A, i) \leq \sum_{i=1}^k
c_i\]</span></p>
<h1 id="conclusion">Conclusion</h1>
<p>Dans ce chapitre, nous avons présenté les notions fondamentales de la
complexité des problèmes de calcul distribué. Nous avons défini les
problèmes distribués et les différentes fonctions de complexité
associées. Nous avons également présenté quelques théorèmes importants,
tels que le théorème de lower bound et le théorème de upper bound, ainsi
que leurs preuves détaillées. Enfin, nous avons discuté quelques
propriétés et corollaires liés à la complexité des problèmes
distribués.</p>
<p>La compréhension de la complexité des problèmes de calcul distribué
est essentielle pour concevoir des algorithmes efficaces et optimiser
les performances des systèmes distribués. Les résultats présentés dans
ce chapitre fournissent une base solide pour l’étude approfondie de la
complexité des problèmes distribués et ouvrent la voie à de nouvelles
recherches dans ce domaine passionnant.</p>
</body>
</html>
{% include "footer.html" %}

