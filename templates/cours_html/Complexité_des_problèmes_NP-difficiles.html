{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes NP-difficiles</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title"><strong>Complexité des problèmes
NP-difficiles</strong></h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>L’étude de la complexité des problèmes NP-difficiles est un domaine
central en informatique théorique, à l’intersection de la théorie des
algorithmes et de la logique mathématique. L’origine historique de cette
notion remonte aux années 1970, avec les travaux pionniers de Stephen
Cook et Leonid Levin, qui ont introduit la classe NP et le concept de
réduction polynomial. Ces idées ont révolutionné notre compréhension des
limites fondamentales du calcul.</p>
<p>Les problèmes NP-difficiles sont ceux pour lesquels toute solution
proposée peut être vérifiée rapidement, mais dont la recherche d’une
solution optimale semble extrêmement coûteuse en termes de ressources
computationnelles. Cette dualité entre vérification rapide et recherche
lente soulève des questions profondes sur la nature même de l’efficacité
algorithmique. Les problèmes NP-difficiles sont indispensables dans des
domaines variés, tels que l’optimisation combinatoire, la cryptographie
et l’intelligence artificielle.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre ce qu’est un problème NP-difficile, commençons par
nous demander ce que signifie "vérifier rapidement une solution".
Intuitivement, cela implique qu’il existe un algorithme qui, étant donné
une solution candidate, peut confirmer ou infirmer sa validité en un
temps polynomial. Ensuite, nous cherchons à capturer l’idée que ces
problèmes sont au moins aussi difficiles que les plus difficiles
problèmes dans NP.</p>
<div class="definition">
<p>Soit <span class="math inline">\(\mathcal{P} = (I, S, V)\)</span> un
problème de décision, où <span class="math inline">\(I\)</span> est
l’ensemble des instances, <span class="math inline">\(S\)</span>
l’ensemble des solutions et <span class="math inline">\(V \subseteq I
\times S\)</span> la relation de validité. On dit que <span
class="math inline">\(\mathcal{P}\)</span> est dans NP si et seulement
si il existe un algorithme <span class="math inline">\(A\)</span> et une
constante <span class="math inline">\(c &gt; 0\)</span> tels que : <span
class="math display">\[\forall (x, y) \in V, A(x, y) \text{ s&#39;arrête
en temps } O(|x|^c)\]</span> et <span class="math display">\[\forall x
\in I, y \in S, A(x, y) = 1 \iff (x, y) \in V.\]</span></p>
</div>
<div class="definition">
<p>Un problème <span class="math inline">\(\mathcal{P}\)</span> est
NP-difficile si et seulement si pour tout problème <span
class="math inline">\(\mathcal{Q} \in \text{NP}\)</span>, il existe une
réduction polynomial <span class="math inline">\(R\)</span> telle que :
<span class="math display">\[\forall x \in I_{\mathcal{Q}},
\mathcal{P}(R(x)) = \mathcal{Q}(x),\]</span> où <span
class="math inline">\(I_{\mathcal{Q}}\)</span> est l’ensemble des
instances de <span class="math inline">\(\mathcal{Q}\)</span>.</p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<p>Un des résultats les plus célèbres concernant les problèmes
NP-difficiles est le théorème de Cook-Levin, qui établit que le problème
de la satisfaction booléenne (SAT) est NP-complet.</p>
<div class="theorem">
<p>Le problème SAT est NP-difficile.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Pour démontrer ce théorème, nous devons montrer que
tout problème dans NP peut être réduit polynomialement à SAT. Soit <span
class="math inline">\(\mathcal{P} = (I, S, V)\)</span> un problème dans
NP. Par définition, il existe une machine de Turing non déterministe
<span class="math inline">\(M\)</span> qui décide <span
class="math inline">\(\mathcal{P}\)</span> en temps polynomial. Nous
construisons une formule booléenne <span
class="math inline">\(\phi\)</span> telle que <span
class="math inline">\(M\)</span> accepte l’instance <span
class="math inline">\(x\)</span> si et seulement si <span
class="math inline">\(\phi\)</span> est satisfaisable.</p>
<p>La construction de <span class="math inline">\(\phi\)</span> se fait
en plusieurs étapes :</p>
<ol>
<li><p>Codons l’état de la machine <span
class="math inline">\(M\)</span> à chaque étape de son
exécution.</p></li>
<li><p>Exprimons les transitions entre états comme des contraintes
booléennes.</p></li>
<li><p>Assurons que la machine accepte l’instance <span
class="math inline">\(x\)</span> en ajoutant des clauses
correspondantes.</p></li>
</ol>
<p>La formule résultante <span class="math inline">\(\phi\)</span> est
satisfiable si et seulement si <span class="math inline">\(M\)</span>
accepte <span class="math inline">\(x\)</span>. Puisque cette
construction peut être effectuée en temps polynomial, nous avons bien
une réduction polynomial de <span
class="math inline">\(\mathcal{P}\)</span> à SAT. ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<p>Considérons maintenant la preuve détaillée de l’argument utilisé dans
le théorème de Cook-Levin. Nous devons montrer que pour toute machine de
Turing non déterministe <span class="math inline">\(M\)</span> qui
décide un problème <span class="math inline">\(\mathcal{P} \in
\text{NP}\)</span>, il existe une formule booléenne <span
class="math inline">\(\phi\)</span> telle que <span
class="math inline">\(M\)</span> accepte l’instance <span
class="math inline">\(x\)</span> si et seulement si <span
class="math inline">\(\phi\)</span> est satisfaisable.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(M\)</span> une
machine de Turing non déterministe qui décide <span
class="math inline">\(\mathcal{P}\)</span> en temps polynomial.
Supposons que <span class="math inline">\(M\)</span> s’arrête après au
plus <span class="math inline">\(T(n)\)</span> étapes sur une instance
de taille <span class="math inline">\(n\)</span>. Nous construisons une
formule booléenne <span class="math inline">\(\phi\)</span> dont les
variables représentent les configurations possibles de <span
class="math inline">\(M\)</span> à chaque étape.</p>
<p>Pour chaque étape <span class="math inline">\(t \leq T(n)\)</span>,
nous introduisons des variables pour représenter l’état du ruban, la
position de la tête de lecture/écriture et l’état interne de <span
class="math inline">\(M\)</span>. Les contraintes booléennes sont
ajoutées pour :</p>
<ul>
<li><p>Assurer que la configuration à l’étape <span
class="math inline">\(t+1\)</span> est une conséquence des choix non
déterministes et des transitions de <span
class="math inline">\(M\)</span> à l’étape <span
class="math inline">\(t\)</span>.</p></li>
<li><p>Garantir que la machine commence dans une configuration initiale
correcte.</p></li>
<li><p>Imposer que la machine accepte l’instance <span
class="math inline">\(x\)</span> en atteignant un état
d’acceptation.</p></li>
</ul>
<p>La formule <span class="math inline">\(\phi\)</span> est la
conjonction de toutes ces contraintes. Par construction, <span
class="math inline">\(\phi\)</span> est satisfiable si et seulement si
il existe un chemin d’exécution de <span
class="math inline">\(M\)</span> qui accepte <span
class="math inline">\(x\)</span>. Puisque la taille de <span
class="math inline">\(\phi\)</span> est polynomiale en la taille de
<span class="math inline">\(x\)</span>, cette réduction est bien
polynomial. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Les problèmes NP-difficiles possèdent plusieurs propriétés
intéressantes, que nous énumérons et démontrons ci-dessous.</p>
<ol>
<li><p>Tout problème NP-difficile est dans NP.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(\mathcal{P}\)</span>
un problème NP-difficile. Par définition, tout problème <span
class="math inline">\(\mathcal{Q} \in \text{NP}\)</span> peut être
réduit polynomialement à <span
class="math inline">\(\mathcal{P}\)</span>. En particulier, <span
class="math inline">\(\mathcal{P}\)</span> lui-même peut être réduit à
<span class="math inline">\(\mathcal{P}\)</span>, ce qui implique que
<span class="math inline">\(\mathcal{P} \in \text{NP}\)</span>. ◻</p>
</div></li>
<li><p>Si un problème NP-difficile est dans P, alors P = NP.</p>
<div class="proof">
<p><em>Proof.</em> Supposons qu’il existe un problème NP-difficile <span
class="math inline">\(\mathcal{P}\)</span> qui est dans P. Puisque tout
problème <span class="math inline">\(\mathcal{Q} \in \text{NP}\)</span>
peut être réduit polynomialement à <span
class="math inline">\(\mathcal{P}\)</span>, et que <span
class="math inline">\(\mathcal{P}\)</span> peut être résolu en temps
polynomial, il s’ensuit que <span
class="math inline">\(\mathcal{Q}\)</span> peut également être résolu en
temps polynomial. Donc, P = NP. ◻</p>
</div></li>
<li><p>La composition de réductions polynomiales est une réduction
polynomiale.</p>
<div class="proof">
<p><em>Proof.</em> Soient <span class="math inline">\(\mathcal{P},
\mathcal{Q}, \mathcal{R}\)</span> des problèmes tels que <span
class="math inline">\(\mathcal{P} \leq_P \mathcal{Q}\)</span> et <span
class="math inline">\(\mathcal{Q} \leq_P \mathcal{R}\)</span>. Cela
signifie qu’il existe des réductions polynomiales <span
class="math inline">\(f\)</span> et <span
class="math inline">\(g\)</span> telles que <span
class="math inline">\(\mathcal{P}(x) = \mathcal{Q}(f(x))\)</span> et
<span class="math inline">\(\mathcal{Q}(y) = \mathcal{R}(g(y))\)</span>.
La composition <span class="math inline">\(h(x) = g(f(x))\)</span> est
également une réduction polynomiale, car la composition de deux
fonctions polynomiales est polynomiale. ◻</p>
</div></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>L’étude de la complexité des problèmes NP-difficiles a profondément
influencé notre compréhension des limites du calcul. Les résultats
présentés ici, en particulier le théorème de Cook-Levin et ses
conséquences, montrent que les problèmes NP-difficiles jouent un rôle
central dans la théorie de la complexité computationnelle. Les
propriétés et corollaires discutés soulignent l’importance de ces
problèmes dans la hiérarchie des classes de complexité et ouvrent des
perspectives pour de futures recherches en algorithmes et en
optimisation.</p>
</body>
</html>
{% include "footer.html" %}

