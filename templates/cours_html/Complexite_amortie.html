{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité Amortie : Analyse des Algorithmes en Temps Moyen</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité Amortie : Analyse des Algorithmes en Temps
Moyen</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>L’analyse de la complexité amortie émerge comme une réponse élégante
à l’insuffisance des analyses de complexité classiques, qui se
concentrent souvent sur le pire cas. Historiquement, cette notion a pris
son essor avec les travaux de Donald Knuth dans les années 1970,
cherchant à comprendre le comportement moyen des algorithmes au-delà de
simples moyennes arithmétiques. La complexité amortie permet d’étudier
le coût moyen d’une séquence d’opérations, en lissant les variations
extrêmes. Elle est indispensable dans des contextes où des opérations
coûteuses sont rarement utilisées, mais dont l’impact doit être compris
sur le long terme. Par exemple, la gestion dynamique de mémoire ou les
structures de données réutilisables bénéficient grandement de cette
analyse pour optimiser leurs performances.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour introduire la complexité amortie, considérons une séquence
d’opérations sur une structure de données. Nous cherchons à comprendre
le coût moyen par opération, en tenant compte des variations possibles.
Imaginez une structure où certaines opérations sont coûteuses mais
rares, tandis que d’autres sont fréquentes et peu coûteuses. La
complexité amortie nous permet de capturer cette dynamique.</p>
<div class="definition">
<p>Soit <span class="math inline">\(S\)</span> une séquence d’opérations
<span class="math inline">\(O_1, O_2, \ldots, O_n\)</span> sur une
structure de données. Le coût amorti par opération est défini comme le
rapport entre le coût total des opérations et le nombre d’opérations
effectuées.</p>
<p>Formellement, si <span class="math inline">\(C_i\)</span> est le coût
de l’opération <span class="math inline">\(O_i\)</span>, alors la
complexité amortie <span class="math inline">\(T(n)\)</span> est donnée
par : <span class="math display">\[T(n) = \frac{1}{n} \sum_{i=1}^{n}
C_i\]</span></p>
<p>En termes quantifiés, pour tout <span class="math inline">\(n \in
\mathbb{N}^*\)</span>, il existe une constante <span
class="math inline">\(c\)</span> telle que : <span
class="math display">\[\forall n \geq 1, \quad T(n) \leq c\]</span></p>
<p>Une autre formulation utilise les inégalités : pour tout <span
class="math inline">\(n\)</span>, le coût total <span
class="math inline">\(C(n) = \sum_{i=1}^{n} C_i\)</span> satisfait :
<span class="math display">\[C(n) = O(f(n))\]</span> où <span
class="math inline">\(f(n)\)</span> est une fonction de complexité.</p>
</div>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<p>Un des théorèmes fondamentaux en complexité amortie est le
<strong>Théorème de l’Inégalité des Moyennes</strong>, qui relie le coût
amorti à la complexité maximale.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(S\)</span> une séquence d’opérations
avec des coûts <span class="math inline">\(C_1, C_2, \ldots,
C_n\)</span>. Si le coût total <span class="math inline">\(C(n) =
\sum_{i=1}^{n} C_i\)</span> satisfait : <span
class="math display">\[C(n) = O(f(n))\]</span> alors la complexité
amortie <span class="math inline">\(T(n)\)</span> est bornée par : <span
class="math display">\[T(n) = O\left(\frac{f(n)}{n}\right)\]</span></p>
<p>Pour le démontrer, nous utilisons la méthode de l’invariant
potentiel. Soit <span class="math inline">\(\Phi\)</span> un potentiel
initial, et <span class="math inline">\(\Phi_i\)</span> le potentiel
après l’opération <span class="math inline">\(O_i\)</span>. Le coût
amorti <span class="math inline">\(\hat{C}_i\)</span> de l’opération
<span class="math inline">\(O_i\)</span> est donné par : <span
class="math display">\[\hat{C}_i = C_i + \Phi_i -
\Phi_{i-1}\]</span></p>
<p>En sommant sur toutes les opérations, nous obtenons : <span
class="math display">\[\sum_{i=1}^{n} \hat{C}_i = C(n) + \Phi_n -
\Phi_0\]</span></p>
<p>En utilisant l’hypothèse <span class="math inline">\(C(n) =
O(f(n))\)</span>, nous déduisons que : <span
class="math display">\[\sum_{i=1}^{n} \hat{C}_i = O(f(n))\]</span></p>
<p>En divisant par <span class="math inline">\(n\)</span>, nous obtenons
: <span class="math display">\[T(n) =
O\left(\frac{f(n)}{n}\right)\]</span></p>
<p>Ce théorème est crucial pour comprendre comment les coûts extrêmes
peuvent être amortis sur une séquence d’opérations.</p>
</div>
<h1 class="unnumbered" id="preuves">Preuves</h1>
<p>Pour illustrer l’application du théorème, considérons un exemple
classique : la structure de données <strong>Tableau
Dynamique</strong>.</p>
<div class="proof">
<p><em>Proof.</em> Soit un tableau dynamique qui double sa taille
lorsqu’il est plein. Le coût d’une insertion est <span
class="math inline">\(O(1)\)</span> la plupart du temps, mais devient
<span class="math inline">\(O(n)\)</span> lorsque le tableau doit être
réalloué.</p>
<p>Le coût total pour <span class="math inline">\(n\)</span> insertions
est : <span class="math display">\[C(n) = O(n)\]</span></p>
<p>En appliquant le théorème de l’inégalité des moyennes, nous obtenons
: <span class="math display">\[T(n) = O\left(\frac{n}{n}\right) =
O(1)\]</span></p>
<p>Ainsi, la complexité amortie d’une insertion dans un tableau
dynamique est <span class="math inline">\(O(1)\)</span>. Cette preuve
montre comment des opérations coûteuses mais rares peuvent être amorties
sur une séquence d’opérations. ◻</p>
</div>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<p>Plusieurs propriétés découlent du théorème de l’inégalité des
moyennes. En voici quelques-unes :</p>
<ol>
<li><p>Si le coût total <span class="math inline">\(C(n)\)</span> est
linéaire en <span class="math inline">\(n\)</span>, alors la complexité
amortie est constante.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(C(n) =
O(n)\)</span>. En appliquant le théorème, nous avons : <span
class="math display">\[T(n) = O\left(\frac{n}{n}\right) =
O(1)\]</span> ◻</p>
</div></li>
<li><p>Si le coût total <span class="math inline">\(C(n)\)</span> est
quadratique en <span class="math inline">\(n\)</span>, alors la
complexité amortie est linéaire.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(C(n) =
O(n^2)\)</span>. En appliquant le théorème, nous avons : <span
class="math display">\[T(n) = O\left(\frac{n^2}{n}\right) =
O(n)\]</span> ◻</p>
</div></li>
<li><p>La complexité amortie peut être utilisée pour analyser des
structures de données complexes, comme les arbres binaires de recherche
avec rotations.</p>
<div class="proof">
<p><em>Proof.</em> Soit un arbre binaire de recherche où les rotations
sont utilisées pour maintenir l’équilibre. Le coût d’une insertion ou
suppression peut être <span class="math inline">\(O(\log n)\)</span>
dans le pire cas, mais en utilisant la complexité amortie, on peut
montrer que le coût moyen est également <span
class="math inline">\(O(\log n)\)</span>.</p>
<p>En utilisant la méthode de l’invariant potentiel, nous définissons un
potentiel basé sur la hauteur de l’arbre. Le coût amorti de chaque
opération est alors borné par <span class="math inline">\(O(\log
n)\)</span>. ◻</p>
</div></li>
</ol>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>La complexité amortie offre une perspective puissante pour analyser
les algorithmes, en tenant compte des variations de coût sur des
séquences d’opérations. Elle permet de comprendre le comportement moyen
des structures de données et des algorithmes, en lissant les pics de
coût. Les théorèmes et propriétés présentés dans cet article montrent
comment cette analyse peut être appliquée pour optimiser les
performances des algorithmes.</p>
</body>
</html>
{% include "footer.html" %}

