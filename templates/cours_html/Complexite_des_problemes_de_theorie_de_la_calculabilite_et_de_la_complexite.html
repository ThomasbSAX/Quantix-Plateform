{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de théorie de la calculabilité et de la complexité</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de théorie de la
calculabilité et de la complexité</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La théorie de la calculabilité et de la complexité est un domaine
fondamental en informatique théorique, qui trouve ses racines dans les
travaux pionniers de Turing, Church et Gödel au début du XXe siècle. Ces
travaux ont posé les bases de ce que nous comprenons aujourd’hui comme
étant calculable et complexe.</p>
<p>L’émergence de ces notions a été motivée par des questions profondes
sur les limites de la computation. Par exemple, le problème de l’arrêt
de Turing pose la question de savoir si un programme donné s’arrêtera ou
continuera à exécuter indéfiniment. Ce problème est non décidable, ce
qui signifie qu’il n’existe pas d’algorithme universel capable de le
résoudre pour tous les cas possibles.</p>
<p>La théorie de la complexité, quant à elle, cherche à comprendre la
quantité de ressources nécessaires pour résoudre un problème donné. Ces
ressources peuvent être le temps, l’espace mémoire, ou d’autres mesures
de complexité. La classification des problèmes en classes de complexité,
telles que P, NP, et d’autres, permet de mieux comprendre les relations
entre différents problèmes et de déterminer quels problèmes sont faciles
ou difficiles à résoudre.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre la complexité des problèmes, il est essentiel de
définir rigoureusement les notions de calculabilité et de
complexité.</p>
<h2 id="calculabilité">Calculabilité</h2>
<p>Considérons un problème donné. Nous voulons savoir si ce problème
peut être résolu par une machine de Turing. Une machine de Turing est un
modèle abstrait de calcul qui peut manipuler des symboles sur une bande
infinie. Si nous pouvons construire une machine de Turing qui résout le
problème en un nombre fini d’étapes, alors le problème est
calculable.</p>
<div class="definition">
<p>Un ensemble <span class="math inline">\(L\)</span> est dit calculable
s’il existe une machine de Turing <span class="math inline">\(M\)</span>
telle que pour tout <span class="math inline">\(x\)</span>, <span
class="math inline">\(M\)</span> accepte <span
class="math inline">\(x\)</span> si et seulement si <span
class="math inline">\(x \in L\)</span>. <span
class="math display">\[\exists M \text{ machine de Turing } \forall x
\left( M(x) = 1 \iff x \in L \right)\]</span></p>
</div>
<h2 id="complexité-de-temps">Complexité de Temps</h2>
<p>La complexité de temps d’un problème est une mesure du nombre
d’étapes nécessaires pour résoudre le problème sur une machine de
Turing. Nous voulons quantifier le temps nécessaire en fonction de la
taille de l’entrée.</p>
<div class="definition">
<p>Soit <span class="math inline">\(M\)</span> une machine de Turing. La
fonction de temps de <span class="math inline">\(M\)</span>, notée <span
class="math inline">\(T_M(n)\)</span>, est définie comme le nombre
maximal d’étapes que <span class="math inline">\(M\)</span> prend pour
accepter une entrée de taille <span class="math inline">\(n\)</span>.
<span class="math display">\[T_M(n) = \max \{ t \mid M \text{ accepte }
x \text{ en } t \text{ étapes et } |x| = n \}\]</span></p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<h2 id="théorème-de-larret-de-turing">Théorème de l’Arret de Turing</h2>
<p>Le théorème de l’arrêt de Turing est un résultat fondamental en
théorie de la calculabilité. Il montre que le problème de l’arrêt n’est
pas calculable.</p>
<div class="theorem">
<p>Il n’existe pas de machine de Turing <span
class="math inline">\(M\)</span> qui, pour toute paire <span
class="math inline">\((P, x)\)</span> où <span
class="math inline">\(P\)</span> est un programme et <span
class="math inline">\(x\)</span> une entrée, décide si <span
class="math inline">\(P\)</span> s’arrête sur <span
class="math inline">\(x\)</span>. <span class="math display">\[\nexists
M \text{ machine de Turing } \forall P, x \left( M(P, x) = 1 \iff P(x)
\text{ s&#39;arrête} \right)\]</span></p>
</div>
<h2 id="démonstration-du-théorème-de-larret-de-turing">Démonstration du
Théorème de l’Arret de Turing</h2>
<p>La démonstration du théorème de l’arrêt de Turing utilise une preuve
par contradiction. Supposons qu’il existe une machine de Turing <span
class="math inline">\(M\)</span> qui décide du problème de l’arrêt. Nous
pouvons alors construire une nouvelle machine <span
class="math inline">\(M&#39;\)</span> qui, pour un programme donné <span
class="math inline">\(P\)</span>, fait exactement l’inverse de ce que
<span class="math inline">\(M\)</span> fait.</p>
<div class="proof">
<p><em>Proof.</em> Supposons qu’il existe une machine de Turing <span
class="math inline">\(M\)</span> qui décide du problème de l’arrêt.
Construisons une nouvelle machine <span
class="math inline">\(M&#39;\)</span> telle que : <span
class="math display">\[M&#39;(P, x) = 1 - M(P, x)\]</span> Si <span
class="math inline">\(M\)</span> accepte <span class="math inline">\((P,
x)\)</span>, alors <span class="math inline">\(M&#39;\)</span> rejette
<span class="math inline">\((P, x)\)</span>, et vice versa. Considérons
maintenant l’exécution de <span class="math inline">\(M&#39;\)</span>
sur <span class="math inline">\((M&#39;, M&#39;)\)</span>. Si <span
class="math inline">\(M&#39;(M&#39;, M&#39;)\)</span> accepte, alors
<span class="math inline">\(M(M&#39;, M&#39;)\)</span> rejette, ce qui
signifie que <span class="math inline">\(M&#39;(M&#39;, M&#39;)\)</span>
s’arrête. Mais si <span class="math inline">\(M&#39;(M&#39;,
M&#39;)\)</span> rejette, alors <span class="math inline">\(M(M&#39;,
M&#39;)\)</span> accepte, ce qui signifie que <span
class="math inline">\(M&#39;(M&#39;, M&#39;)\)</span> s’arrête
également. Dans les deux cas, nous avons une contradiction. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<h2 id="propriété-de-fermeture-sous-composition">Propriété de Fermeture
sous Composition</h2>
<p>Les classes de complexité ont des propriétés de fermeture
importantes. Par exemple, la classe P est fermée sous composition.</p>
<div class="proposition">
<p>Si <span class="math inline">\(f\)</span> et <span
class="math inline">\(g\)</span> sont des fonctions calculables en temps
polynomial, alors la composition <span class="math inline">\(f \circ
g\)</span> est également calculable en temps polynomial. <span
class="math display">\[\forall f, g \text{ calculables en temps
polynomial } \left( (f \circ g) \text{ est calculable en temps
polynomial} \right)\]</span></p>
</div>
<h2
id="démonstration-de-la-propriété-de-fermeture-sous-composition">Démonstration
de la Propriété de Fermeture sous Composition</h2>
<p>La démonstration de cette propriété repose sur le fait que la
composition de deux fonctions polynomiales est également une fonction
polynomiale.</p>
<div class="proof">
<p><em>Proof.</em> Soient <span class="math inline">\(f\)</span> et
<span class="math inline">\(g\)</span> des fonctions calculables en
temps polynomial. Supposons que <span class="math inline">\(f\)</span>
soit calculable en temps <span class="math inline">\(O(n^a)\)</span> et
<span class="math inline">\(g\)</span> en temps <span
class="math inline">\(O(n^b)\)</span>. La composition <span
class="math inline">\(f \circ g\)</span> est calculable en temps <span
class="math inline">\(O((n^b)^a) = O(n^{ab})\)</span>, qui est également
un temps polynomial. ◻</p>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>La théorie de la calculabilité et de la complexité est un domaine
riche et fascinant, qui continue d’évoluer avec les avancées en
informatique théorique. Les notions de calculabilité et de complexité
nous permettent de mieux comprendre les limites de la computation et de
classer les problèmes en fonction de leur difficulté. Les théorèmes
fondamentaux, tels que le théorème de l’arrêt de Turing, nous donnent
des insights profonds sur la nature de la computation.</p>
</body>
</html>
{% include "footer.html" %}

