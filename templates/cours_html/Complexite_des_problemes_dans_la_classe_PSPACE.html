{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes dans la classe PSPACE</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes dans la classe PSPACE</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>L’étude de la complexité des problèmes dans la classe PSPACE
constitue un pilier fondamental en théorie de la calculabilité et de la
complexité. Historiquement, l’émergence de cette classe est intimement
liée à la compréhension des limites des machines de Turing et des
problèmes décisionnels. La classe PSPACE, qui englobe tous les problèmes
résolubles par une machine de Turing déterministte en espace polynomial,
offre un cadre théorique indispensable pour appréhender des problèmes
dont la résolution requiert une quantité d’espace mémoire
proportionnelle à un polynôme de la taille de l’entrée.</p>
<p>Cette notion est cruciale dans plusieurs domaines, notamment en
informatique théorique, en algorithmique et même en intelligence
artificielle. Elle permet de classer les problèmes selon leur difficulté
intrinsèque, fournissant ainsi des outils pour évaluer la faisabilité
pratique de leur résolution. Les problèmes dans PSPACE incluent des
questions complexes telles que le problème du satisfiabilité booléenne
(SAT) avec une contrainte supplémentaire sur l’espace mémoire utilisé,
ou encore des jeux de stratégie comme le jeu d’échecs.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour comprendre la classe PSPACE, il est essentiel de saisir
préalablement les concepts d’espace mémoire et de temps de calcul.
Considérons une machine de Turing qui manipule des entrées binaires de
taille <span class="math inline">\(n\)</span>. L’espace mémoire utilisé
par cette machine est le nombre total de cellules de bande qu’elle
accède au cours de son exécution. La classe PSPACE est définie comme
l’ensemble des problèmes décisionnels pour lesquels il existe une
machine de Turing déterministte qui, pour toute entrée <span
class="math inline">\(x\)</span>, décide si <span
class="math inline">\(x\)</span> appartient au langage en utilisant un
espace polynomial en la taille de <span
class="math inline">\(x\)</span>.</p>
<p>Formellement, nous avons :</p>
<div class="definition">
<p>Soit <span class="math inline">\(L\)</span> un langage. On dit que
<span class="math inline">\(L\)</span> est dans la classe PSPACE s’il
existe une machine de Turing déterministte <span
class="math inline">\(M\)</span> et un polynôme <span
class="math inline">\(p\)</span> tels que pour toute entrée <span
class="math inline">\(x\)</span>, <span class="math display">\[M \text{
accepte } x \text{ en utilisant au plus } p(|x|) \text{ cellules de
bande.}\]</span></p>
</div>
<p>Une autre manière de formuler cette définition est la suivante :</p>
<div class="definition">
<p>La classe PSPACE est définie par <span
class="math display">\[\text{PSPACE} = \bigcup_{k \geq 0}
\text{DSPACE}(n^k),\]</span> où <span
class="math inline">\(\text{DSPACE}(f(n))\)</span> désigne l’ensemble
des langages acceptés par une machine de Turing déterministte en espace
<span class="math inline">\(O(f(n))\)</span>.</p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<p>Un des théorèmes fondamentaux concernant la classe PSPACE est le
théorème de Savitch, qui établit une relation entre les classes PSPACE
et NPSPACE. Avant d’énoncer ce théorème, il est utile de comprendre que
NPSPACE désigne la classe des langages acceptés par une machine de
Turing non déterministte en espace polynomial.</p>
<div class="theorem">
<p>Pour tout langage <span class="math inline">\(L\)</span> dans
NPSPACE, il existe un polynôme <span class="math inline">\(p\)</span>
tel que <span class="math inline">\(L\)</span> est dans DSPACE<span
class="math inline">\((p(n))\)</span>. En d’autres termes, <span
class="math display">\[\text{NPSPACE} \subseteq
\text{PSPACE}.\]</span></p>
</div>
<p>Pour démontrer ce théorème, nous utilisons une technique de
simulation d’une machine non déterministte par une machine
déterministte. L’idée est de remplacer les choix non déterministes par
des appels récursifs à une procédure qui explore toutes les
possibilités. La complexité en espace de cette simulation est
polynomiale.</p>
<h1 id="preuves">Preuves</h1>
<p>La preuve du théorème de Savitch repose sur une construction
explicite d’une machine de Turing déterministte qui simule une machine
non déterministte. Soit <span class="math inline">\(M\)</span> une
machine de Turing non déterministte qui accepte un langage <span
class="math inline">\(L\)</span> en espace polynomial. Nous construisons
une machine de Turing déterministte <span
class="math inline">\(M&#39;\)</span> qui simule <span
class="math inline">\(M\)</span> en utilisant un espace polynomial.</p>
<p>La machine <span class="math inline">\(M&#39;\)</span> utilise une
procédure récursive <span class="math inline">\(\text{Accept}(i, j,
k)\)</span> qui vérifie si la machine <span
class="math inline">\(M\)</span> accepte à partir de l’état <span
class="math inline">\(k\)</span> en utilisant les cellules de bande
entre <span class="math inline">\(i\)</span> et <span
class="math inline">\(j\)</span>. La complexité en espace de cette
procédure est polynomiale, car elle fait appel à des sous-procédures
récursives avec des paramètres réduits.</p>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Plusieurs propriétés importantes découlent du théorème de Savitch.
Nous en listons quelques-unes :</p>
<ol>
<li><p>La classe PSPACE est fermée sous complémentation. Cela signifie
que si un langage <span class="math inline">\(L\)</span> est dans
PSPACE, alors son complément <span
class="math inline">\(\overline{L}\)</span> est également dans
PSPACE.</p></li>
<li><p>La classe PSPACE contient la classe NP. En effet, tout problème
dans NP peut être résolu par une machine de Turing non déterministte en
temps polynomial, et donc en espace polynomial.</p></li>
<li><p>La classe PSPACE est fermée sous union, intersection et produit.
Cela signifie que l’union, l’intersection et le produit de deux langages
dans PSPACE sont également dans PSPACE.</p></li>
</ol>
<p>Pour démontrer la propriété (i), nous utilisons le fait que la classe
PSPACE est fermée sous complémentation. En effet, si <span
class="math inline">\(L\)</span> est accepté par une machine de Turing
déterministte en espace polynomial, alors son complément peut être
accepté par la même machine en inversant la décision.</p>
<p>Pour démontrer la propriété (ii), nous utilisons le fait que tout
problème dans NP peut être résolu par une machine de Turing non
déterministte en temps polynomial. Comme le temps polynomial implique
l’espace polynomial, nous avons <span class="math inline">\(\text{NP}
\subseteq \text{PSPACE}\)</span>.</p>
<p>Pour démontrer la propriété (iii), nous utilisons le fait que les
opérations d’union, d’intersection et de produit peuvent être effectuées
en espace polynomial. Par exemple, l’union de deux langages <span
class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span> peut être acceptée par une machine de
Turing qui simule successivement les machines pour <span
class="math inline">\(L_1\)</span> et <span
class="math inline">\(L_2\)</span>.</p>
</body>
</html>
{% include "footer.html" %}

