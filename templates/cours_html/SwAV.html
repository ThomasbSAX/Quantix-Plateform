{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>SwAV: Un cadre d’apprentissage auto-supervisé pour la représentation visuelle</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">SwAV: Un cadre d’apprentissage auto-supervisé pour la
représentation visuelle</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>L’apprentissage auto-supervisé a émergé comme une approche
prometteuse pour l’apprentissage de représentations visuelles sans
nécessiter d’annotations coûteuses. Parmi les différentes méthodes
proposées, SwAV (Swapping Assignments between Views) se distingue par
son efficacité et sa simplicité. Ce cadre repose sur l’idée d’apprendre
des représentations en résolvant une tâche de prédiction de similitude
entre différentes vues d’une même image.</p>
<p>L’origine de SwAV remonte aux travaux sur l’apprentissage contrastif,
où des paires d’images sont utilisées pour apprendre des représentations
similaires. Cependant, SwAV introduit une innovation clé en utilisant
plusieurs vues d’une même image et en apprenant à prédire des
assignements entre ces vues. Cette approche permet de capturer des
informations plus riches et plus robustes que les méthodes contrastives
traditionnelles.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Avant de plonger dans les détails de SwAV, il est essentiel de
définir quelques concepts clés.</p>
<h2 class="unnumbered" id="vues-dune-image">Vues d’une image</h2>
<p>Considérons une image <span class="math inline">\(I\)</span>. Une vue
de cette image est une transformation aléatoire appliquée à <span
class="math inline">\(I\)</span>, notée <span
class="math inline">\(t(I)\)</span>, où <span
class="math inline">\(t\)</span> est une transformation composée de
rotations, recadrages, et autres opérations. L’objectif est d’apprendre
des représentations qui sont invariantes à ces transformations.</p>
<h2 class="unnumbered" id="assignements-entre-vues">Assignements entre
vues</h2>
<p>Étant donné un ensemble de <span class="math inline">\(N\)</span>
images, nous générons <span class="math inline">\(K\)</span> vues pour
chaque image. Soit <span class="math inline">\(V = \{v_1, v_2, \dots,
v_{NK}\}\)</span> l’ensemble de toutes les vues. Un assignement est une
fonction <span class="math inline">\(A: V \rightarrow C\)</span> qui
associe chaque vue à un code latent <span class="math inline">\(c \in
C\)</span>, où <span class="math inline">\(C\)</span> est un ensemble de
codes latents.</p>
<h2 class="unnumbered" id="fonction-de-perte">Fonction de perte</h2>
<p>La fonction de perte de SwAV est définie comme suit:</p>
<p><span class="math display">\[\mathcal{L} = -\sum_{i=1}^{N} \log
\frac{\exp(z_i / \tau)}{\sum_{j=1}^{NK} \mathbb{1}_{c_j = c_i} \exp(z_j
/ \tau)}\]</span></p>
<p>où <span class="math inline">\(z_i\)</span> est le score de
similitude entre la vue <span class="math inline">\(v_i\)</span> et son
assignement, <span class="math inline">\(\tau\)</span> est un paramètre
de température, et <span class="math inline">\(\mathbb{1}_{c_j =
c_i}\)</span> est un indicateur qui vaut 1 si <span
class="math inline">\(v_j\)</span> a le même code latent que <span
class="math inline">\(v_i\)</span>.</p>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<h2 class="unnumbered" id="théorème-de-convergence">Théorème de
convergence</h2>
<p>Nous présentons ici un théorème clé concernant la convergence de
l’algorithme SwAV.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(\theta\)</span> les paramètres du
modèle et <span class="math inline">\(\mathcal{L}(\theta)\)</span> la
fonction de perte. Si l’algorithme SwAV est exécuté avec un taux
d’apprentissage décroissant, alors <span
class="math inline">\(\mathcal{L}(\theta)\)</span> converge vers un
minimum local.</p>
</div>
<h2 class="unnumbered" id="preuve-du-théorème-de-convergence">Preuve du
théorème de convergence</h2>
<p>La preuve repose sur l’analyse de la fonction de perte et des mises à
jour des paramètres. Nous utilisons le fait que la fonction de perte est
Lipschitz continue et que les mises à jour des paramètres sont
effectuées par descente de gradient.</p>
<div class="proof">
<p><em>Proof.</em> Considérons la fonction de perte <span
class="math inline">\(\mathcal{L}(\theta)\)</span>. Par définition,
cette fonction est Lipschitz continue avec une constante de Lipschitz
<span class="math inline">\(L\)</span>. Les mises à jour des paramètres
sont effectuées par descente de gradient avec un taux d’apprentissage
<span class="math inline">\(\eta_t\)</span> à l’itération <span
class="math inline">\(t\)</span>.</p>
<p><span class="math display">\[\theta_{t+1} = \theta_t - \eta_t \nabla
\mathcal{L}(\theta_t)\]</span></p>
<p>Si le taux d’apprentissage <span
class="math inline">\(\eta_t\)</span> décroît suffisamment rapidement,
alors la suite <span class="math inline">\(\theta_t\)</span> converge
vers un point fixe. En particulier, si <span
class="math inline">\(\eta_t = \frac{1}{L(t+1)}\)</span>, alors la suite
converge vers un minimum local de <span
class="math inline">\(\mathcal{L}(\theta)\)</span>.</p>
<p>Pour montrer cela, nous utilisons le théorème de la descente de
gradient stochastique, qui garantit que sous certaines conditions sur le
taux d’apprentissage et la fonction de perte, l’algorithme converge vers
un minimum local. ◻</p>
</div>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
corollaires</h1>
<p>Nous présentons ici quelques propriétés importantes de SwAV.</p>
<h2 class="unnumbered" id="propriété-dinvariance">Propriété
d’invariance</h2>
<div class="proposition">
<p>Soit <span class="math inline">\(v\)</span> une vue d’une image <span
class="math inline">\(I\)</span>. Si <span
class="math inline">\(t\)</span> est une transformation invariante (par
exemple, une rotation), alors la représentation apprise par SwAV pour
<span class="math inline">\(v\)</span> est invariante à <span
class="math inline">\(t\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Cette propriété découle directement de la définition
de SwAV. Puisque les assignements entre vues sont appris en résolvant
une tâche de prédiction de similitude, les représentations apprises
doivent être invariantes aux transformations appliquées aux vues. ◻</p>
</div>
<h2 class="unnumbered" id="corollaire-de-robustesse">Corollaire de
robustesse</h2>
<div class="corollary">
<p>Les représentations apprises par SwAV sont robustes aux variations de
vue, ce qui les rend utiles pour des tâches telles que la reconnaissance
d’objets et la segmentation d’images.</p>
</div>
<div class="proof">
<p><em>Proof.</em> La robustesse aux variations de vue est une
conséquence directe de la propriété d’invariance. Puisque les
représentations sont invariantes aux transformations appliquées aux
vues, elles capturent des caractéristiques plus générales et robustes de
l’image. ◻</p>
</div>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>SwAV est une méthode puissante pour l’apprentissage auto-supervisé de
représentations visuelles. En apprenant des assignements entre vues
d’images, SwAV capture des informations riches et robustes qui sont
utiles pour diverses tâches de vision par ordinateur. Les théorèmes et
propriétés présentés dans cet article montrent que SwAV est à la fois
efficace et théoriquement bien fondé.</p>
</body>
</html>
{% include "footer.html" %}

