{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de branch and bound</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de branch and bound</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>Les problèmes de <em>branch and bound</em> émergent dans le paysage
algorithmique comme une réponse élégante à la complexité des problèmes
d’optimisation combinatoire. Historiquement, cette méthode trouve ses
racines dans les travaux pionniers de Land et Doig en 1960, visant à
résoudre des problèmes d’optimisation linéaire en nombres entiers. La
notion de <em>branch and bound</em> est devenue indispensable dans des
domaines variés, allant de la planification industrielle à
l’informatique théorique.</p>
<p>Pourquoi cette notion émerge-t-elle ? Elle résout le problème
fondamental de la combinatoire exponentielle en décomposant l’espace des
solutions en sous-espaces plus gérables. Le <em>branch and bound</em>
est indispensable dans les cadres où l’énumération exhaustive est
prohibitive, offrant ainsi une approche systématique pour explorer
efficacement l’espace des solutions.</p>
<h1 id="définitions">Définitions</h1>
<p>Nous cherchons à définir ce qu’est un problème de <em>branch and
bound</em>. Imaginons que nous ayons un problème d’optimisation où
l’espace des solutions est vaste et complexe. Nous voulons diviser cet
espace en sous-espaces plus petits, évaluer leur potentiel à contenir
une solution optimale, et éliminer ceux qui ne le peuvent pas. La
méthode de <em>branch and bound</em> est précisément cela.</p>
<p>Formellement, un problème de <em>branch and bound</em> peut être
défini comme suit :</p>
<div class="definition">
<p>Soit <span class="math inline">\(P\)</span> un problème
d’optimisation combinatoire défini sur un ensemble de solutions <span
class="math inline">\(S\)</span>. Un algorithme de <em>branch and
bound</em> pour <span class="math inline">\(P\)</span> est une procédure
qui :</p>
<ol>
<li><p>Divise récursivement l’ensemble <span
class="math inline">\(S\)</span> en sous-ensembles disjoints <span
class="math inline">\(S_1, S_2, \ldots, S_k\)</span>
(branching).</p></li>
<li><p>Évalue une borne inférieure ou supérieure pour chaque
sous-ensemble <span class="math inline">\(S_i\)</span>
(bounding).</p></li>
<li><p>Élague les sous-ensembles <span
class="math inline">\(S_i\)</span> qui ne peuvent pas contenir une
solution optimale (pruning).</p></li>
</ol>
</div>
<p>De manière plus formelle, nous pouvons exprimer cela comme suit :</p>
<p><span class="math display">\[\begin{equation}
\forall s \in S, \exists \{S_i\}_{i=1}^k \text{ tels que } s \in S_i
\text{ pour un certain } i.
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\forall S_i, \exists b_i \text{ tel que } b_i \text{ est une borne
inférieure ou supérieure pour } S_i.
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\forall S_i, \text{ si } b_i \text{ ne peut pas contenir une solution
optimale, alors } S_i \text{ est élagué.}
\end{equation}\]</span></p>
<h1 id="théorèmes">Théorèmes</h1>
<p>Nous cherchons maintenant à établir un théorème fondamental
concernant la complexité des problèmes de <em>branch and bound</em>.
Supposons que nous ayons un problème d’optimisation où l’espace des
solutions est de taille exponentielle. Nous voulons montrer que la
méthode de <em>branch and bound</em> peut réduire cette complexité.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(P\)</span> un problème
d’optimisation combinatoire avec un espace de solutions <span
class="math inline">\(S\)</span> de taille <span
class="math inline">\(|S| = n\)</span>. Si l’algorithme de <em>branch
and bound</em> divise <span class="math inline">\(S\)</span> en
sous-ensembles de taille au plus <span
class="math inline">\(n/2\)</span> à chaque étape, alors la complexité
temporelle de l’algorithme est <span class="math inline">\(O(n \log
n)\)</span>.</p>
</div>
<p>Nous allons maintenant démontrer ce théorème.</p>
<div class="proof">
<p><em>Proof.</em> Considérons un arbre de recherche où chaque nœud
représente un sous-ensemble <span class="math inline">\(S_i\)</span> et
les feuilles représentent les solutions individuelles. À chaque étape,
l’algorithme divise un sous-ensemble en deux parties égales.</p>
<p>La hauteur <span class="math inline">\(h\)</span> de l’arbre est
donnée par : <span class="math display">\[\begin{equation}
h = \log_2 n.
\end{equation}\]</span></p>
<p>Le nombre total de nœuds dans l’arbre est : <span
class="math display">\[\begin{equation}
\sum_{i=0}^h \frac{n}{2^i} = n \sum_{i=0}^h \frac{1}{2^i} = 2n - 1.
\end{equation}\]</span></p>
<p>Chaque nœud nécessite une évaluation de la borne, qui est <span
class="math inline">\(O(1)\)</span>. Par conséquent, la complexité
totale est : <span class="math display">\[\begin{equation}
O(n \log n).
\end{equation}\]</span> ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<p>Nous allons maintenant justifier chaque étape de la preuve du
théorème précédent.</p>
<p>1. **Division de l’espace des solutions** : La division de <span
class="math inline">\(S\)</span> en sous-ensembles de taille au plus
<span class="math inline">\(n/2\)</span> est une hypothèse clé. Cela
garantit que l’arbre de recherche est équilibré, ce qui est essentiel
pour obtenir une complexité logarithmique.</p>
<p>2. **Hauteur de l’arbre** : La hauteur <span
class="math inline">\(h\)</span> de l’arbre est déterminée par le nombre
de divisions nécessaires pour réduire la taille du sous-ensemble à 1.
Cela est donné par <span class="math inline">\(\log_2 n\)</span>.</p>
<p>3. **Nombre total de nœuds** : Le nombre total de nœuds dans un arbre
binaire complet est <span class="math inline">\(2n - 1\)</span>. Cela
inclut tous les nœuds internes et les feuilles.</p>
<p>4. **Complexité de l’évaluation des bornes** : Chaque nœud nécessite
une évaluation de la borne, qui est supposée être <span
class="math inline">\(O(1)\)</span>. Cela peut varier en fonction du
problème spécifique, mais pour simplifier, nous supposons que c’est
constant.</p>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Nous allons maintenant lister quelques propriétés et corollaires
importants concernant la méthode de <em>branch and bound</em>.</p>
<ul>
<li><p>**Propriété de l’élagage** : Si une borne inférieure pour un
sous-ensemble <span class="math inline">\(S_i\)</span> est supérieure à
la meilleure solution connue, alors <span
class="math inline">\(S_i\)</span> peut être élagué.</p>
<div class="proof">
<p><em>Proof.</em> Supposons que <span
class="math inline">\(b_i\)</span> soit une borne inférieure pour <span
class="math inline">\(S_i\)</span> et que la meilleure solution connue
soit <span class="math inline">\(s^*\)</span>. Si <span
class="math inline">\(b_i &gt; s^*\)</span>, alors aucune solution dans
<span class="math inline">\(S_i\)</span> ne peut être meilleure que
<span class="math inline">\(s^*\)</span>. Par conséquent, <span
class="math inline">\(S_i\)</span> peut être élagué. ◻</p>
</div></li>
<li><p>**Propriété de la division optimale** : La division de l’espace
des solutions en sous-ensembles de taille égale minimise la hauteur de
l’arbre de recherche.</p>
<div class="proof">
<p><em>Proof.</em> La hauteur de l’arbre est minimisée lorsque chaque
division réduit la taille du sous-ensemble par un facteur constant. La
division en deux parties égales est optimale car elle minimise la
hauteur de l’arbre. ◻</p>
</div></li>
<li><p>**Corollaire de la complexité** : Si l’algorithme de <em>branch
and bound</em> peut diviser l’espace des solutions en sous-ensembles de
taille au plus <span class="math inline">\(n/k\)</span> à chaque étape,
alors la complexité temporelle est <span class="math inline">\(O(n
\log_k n)\)</span>.</p>
<div class="proof">
<p><em>Proof.</em> En suivant une logique similaire à celle du théorème
précédent, la hauteur de l’arbre devient <span
class="math inline">\(\log_k n\)</span>, et le nombre total de nœuds est
<span class="math inline">\(kn - 1\)</span>. La complexité totale est
donc <span class="math inline">\(O(n \log_k n)\)</span>. ◻</p>
</div></li>
</ul>
<h1 id="conclusion">Conclusion</h1>
<p>Les problèmes de <em>branch and bound</em> offrent une approche
puissante et élégante pour résoudre des problèmes d’optimisation
combinatoire complexes. En divisant l’espace des solutions en
sous-ensembles plus gérables et en évaluant leurs bornes, cette méthode
permet de réduire considérablement la complexité computationnelle. Les
théorèmes et propriétés présentés dans cet article fournissent une base
solide pour comprendre et appliquer la méthode de <em>branch and
bound</em> dans divers domaines.</p>
</body>
</html>
{% include "footer.html" %}

