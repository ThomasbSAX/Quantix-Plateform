{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Le Procédé de Gram-Schmidt</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Le Procédé de Gram-Schmidt</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 class="unnumbered" id="introduction-et-motivations">Introduction et
Motivations</h1>
<p>Le procédé de Gram-Schmidt est un algorithme fondamental en algèbre
linéaire, permettant d’orthogonaliser ou d’orthonormaliser une famille
de vecteurs dans un espace préhilbertien. Cette technique, attribuée aux
mathématiciens Erhard Schmidt et Jørgen Pedersen Gram, est indispensable
dans de nombreux domaines comme l’analyse numérique, la théorie des
approximations, et le traitement du signal. Elle permet de transformer
une base quelconque en une base orthogonale ou orthonormale, facilitant
ainsi les calculs et les démonstrations dans des espaces vectoriels
munis d’un produit scalaire.</p>
<h1 class="unnumbered" id="définitions">Définitions</h1>
<p>Pour comprendre le procédé de Gram-Schmidt, il est essentiel de
définir quelques notions préalables.</p>
<div class="definition">
<p>Un espace vectoriel <span class="math inline">\(E\)</span> sur un
corps <span class="math inline">\(\mathbb{K}\)</span> (généralement
<span class="math inline">\(\mathbb{R}\)</span> ou <span
class="math inline">\(\mathbb{C}\)</span>) est dit préhilbertien s’il
est muni d’une forme sesquilinéaire hermitienne <span
class="math inline">\(\langle \cdot, \cdot \rangle\)</span> définie
positive. Cela signifie que pour tous vecteurs <span
class="math inline">\(u, v, w \in E\)</span> et tout scalaire <span
class="math inline">\(\lambda \in \mathbb{K}\)</span>, on a :</p>
<ul>
<li><p><span class="math inline">\(\langle u, v + w \rangle = \langle u,
v \rangle + \langle u, w \rangle\)</span>,</p></li>
<li><p><span class="math inline">\(\langle u, \lambda v \rangle =
\overline{\lambda} \langle u, v \rangle\)</span>,</p></li>
<li><p><span class="math inline">\(\langle u, v \rangle =
\overline{\langle v, u \rangle}\)</span>,</p></li>
<li><p><span class="math inline">\(\langle u, u \rangle \geq 0\)</span>
et <span class="math inline">\(\langle u, u \rangle = 0 \iff u =
0\)</span>.</p></li>
</ul>
</div>
<div class="definition">
<p>Une famille de vecteurs <span class="math inline">\((e_1, e_2, \dots,
e_n)\)</span> dans un espace préhilbertien <span
class="math inline">\(E\)</span> est dite orthogonale si pour tout <span
class="math inline">\(i \neq j\)</span>, on a : <span
class="math display">\[\langle e_i, e_j \rangle = 0.\]</span></p>
</div>
<div class="definition">
<p>Une famille de vecteurs <span class="math inline">\((e_1, e_2, \dots,
e_n)\)</span> dans un espace préhilbertien <span
class="math inline">\(E\)</span> est dite orthonormale si elle est
orthogonale et si pour tout <span class="math inline">\(i\)</span>, on a
: <span class="math display">\[\langle e_i, e_i \rangle =
1.\]</span></p>
</div>
<h1 class="unnumbered" id="théorèmes">Théorèmes</h1>
<p>Le procédé de Gram-Schmidt repose sur un théorème fondamental qui
permet de construire une base orthogonale à partir d’une famille
génératrice quelconque.</p>
<div class="theorem">
<p>Soit <span class="math inline">\((v_1, v_2, \dots, v_n)\)</span> une
famille de vecteurs linéairement indépendants dans un espace
préhilbertien <span class="math inline">\(E\)</span>. On peut construire
une famille orthogonale <span class="math inline">\((e_1, e_2, \dots,
e_n)\)</span> par la récurrence suivante : <span
class="math display">\[e_1 = v_1,\]</span> et pour <span
class="math inline">\(k \geq 2\)</span>, <span
class="math display">\[e_k = v_k - \sum_{i=1}^{k-1} \frac{\langle v_k,
e_i \rangle}{\langle e_i, e_i \rangle} e_i.\]</span></p>
</div>
<h1 class="unnumbered" id="preuves">Preuves</h1>
<p>Pour démontrer le théorème de Gram-Schmidt, nous procédons par
récurrence.</p>
<div class="proof">
<p><em>Proof.</em> <strong>Initialisation :</strong> Pour <span
class="math inline">\(k = 1\)</span>, on a <span
class="math inline">\(e_1 = v_1\)</span>. La famille <span
class="math inline">\((e_1)\)</span> est triviale et donc
orthogonale.</p>
<p><strong>Hérédité :</strong> Supposons que pour un certain <span
class="math inline">\(k \geq 1\)</span>, la famille <span
class="math inline">\((e_1, e_2, \dots, e_k)\)</span> est orthogonale.
Montrons que <span class="math inline">\((e_1, e_2, \dots,
e_{k+1})\)</span> est également orthogonale.</p>
<p>Pour tout <span class="math inline">\(i \leq k\)</span>, on a : <span
class="math display">\[\langle e_{k+1}, e_i \rangle = \left\langle
v_{k+1} - \sum_{j=1}^k \frac{\langle v_{k+1}, e_j \rangle}{\langle e_j,
e_j \rangle} e_j, e_i \right\rangle.\]</span> En utilisant la linéarité
du produit scalaire, on obtient : <span class="math display">\[\langle
e_{k+1}, e_i \rangle = \langle v_{k+1}, e_i \rangle - \frac{\langle
v_{k+1}, e_i \rangle}{\langle e_i, e_i \rangle} \langle e_i, e_i \rangle
= 0.\]</span> Ainsi, <span class="math inline">\((e_1, e_2, \dots,
e_{k+1})\)</span> est orthogonale.</p>
<p>Par récurrence, la famille <span class="math inline">\((e_1, e_2,
\dots, e_n)\)</span> est orthogonale. ◻</p>
</div>
<h1 class="unnumbered" id="propriétés-et-corollaires">Propriétés et
Corollaires</h1>
<p>Le procédé de Gram-Schmidt possède plusieurs propriétés
intéressantes.</p>
<div class="corollary">
<p>Pour obtenir une famille orthonormale à partir de <span
class="math inline">\((e_1, e_2, \dots, e_n)\)</span>, il suffit de
normaliser chaque vecteur <span class="math inline">\(e_i\)</span> en
définissant : <span class="math display">\[u_i =
\frac{e_i}{\|e_i\|},\]</span> où <span class="math inline">\(\|e_i\| =
\sqrt{\langle e_i, e_i \rangle}\)</span> est la norme de <span
class="math inline">\(e_i\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Pour tout <span class="math inline">\(i\)</span>, on
a : <span class="math display">\[\langle u_i, u_i \rangle =
\frac{\langle e_i, e_i \rangle}{\|e_i\|^2} = 1.\]</span> De plus, pour
<span class="math inline">\(i \neq j\)</span>, on a : <span
class="math display">\[\langle u_i, u_j \rangle = \frac{\langle e_i, e_j
\rangle}{\|e_i\| \|e_j\|} = 0.\]</span> Ainsi, <span
class="math inline">\((u_1, u_2, \dots, u_n)\)</span> est
orthonormale. ◻</p>
</div>
<div class="corollary">
<p>Le procédé de Gram-Schmidt classique peut être instable numériquement
en présence de vecteurs quasi-colinéaires. Une version modifiée, appelée
Gram-Schmidt modifié, consiste à projeter les vecteurs <span
class="math inline">\(v_k\)</span> sur l’espace engendré par les
vecteurs orthogonaux déjà construits, ce qui améliore la stabilité
numérique.</p>
</div>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>Le procédé de Gram-Schmidt est un outil puissant et élégant en
algèbre linéaire, permettant de transformer une base quelconque en une
base orthogonale ou orthonormale. Ses applications sont nombreuses et
variées, allant de la résolution de systèmes d’équations linéaires à
l’analyse des données. La compréhension approfondie de cet algorithme
est essentielle pour tout étudiant ou chercheur en mathématiques
appliquées.</p>
</body>
</html>
{% include "footer.html" %}

