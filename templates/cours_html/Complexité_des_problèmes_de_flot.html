{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de flot : Une analyse approfondie</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de flot : Une analyse
approfondie</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>Les problèmes de flot constituent un pilier fondamental en théorie
des graphes et en optimisation combinatoire. Leur origine remonte aux
travaux pionniers de Ford et Fulkerson dans les années 1950, qui ont
jeté les bases de l’analyse des réseaux de flux. Ces problèmes émergent
naturellement dans divers contextes pratiques, tels que la gestion des
ressources, la planification de réseaux de transport, et l’optimisation
des chaînes d’approvisionnement. Leur étude est indispensable pour
comprendre les limites computationnelles et algorithmiques des problèmes
de flux, ainsi que pour développer des méthodes efficaces pour les
résoudre.</p>
<h1 id="définitions">Définitions</h1>
<p>Avant de plonger dans l’analyse de la complexité, il est crucial de
définir rigoureusement les concepts de base. Considérons un graphe
orienté <span class="math inline">\(G = (V, E)\)</span> avec une
capacité <span class="math inline">\(c : E \rightarrow
\mathbb{R}^+\)</span>. Un flot dans ce graphe est une fonction <span
class="math inline">\(f : E \rightarrow \mathbb{R}^+\)</span> qui
respecte les contraintes de capacité et de conservation du flot.</p>
<div class="definition">
<p>Soit <span class="math inline">\(G = (V, E)\)</span> un graphe
orienté avec une capacité <span class="math inline">\(c : E \rightarrow
\mathbb{R}^+\)</span>. Un flot est une fonction <span
class="math inline">\(f : E \rightarrow \mathbb{R}^+\)</span> telle que
:</p>
<ul>
<li><p><span class="math inline">\(0 \leq f(e) \leq c(e)\)</span> pour
tout <span class="math inline">\(e \in E\)</span> (contrainte de
capacité),</p></li>
<li><p><span class="math inline">\(\sum_{e \in \delta^+(v)} f(e) =
\sum_{e \in \delta^-(v)} f(e)\)</span> pour tout <span
class="math inline">\(v \in V \setminus \{s, t\}\)</span> (conservation
du flot),</p></li>
</ul>
<p>où <span class="math inline">\(s\)</span> et <span
class="math inline">\(t\)</span> sont respectivement la source et le
puits, et <span class="math inline">\(\delta^+(v)\)</span> (resp. <span
class="math inline">\(\delta^-(v)\)</span>) désigne l’ensemble des
arêtes sortantes (resp. entrantes) de <span
class="math inline">\(v\)</span>.</p>
</div>
<div class="definition">
<p>Un flot <span class="math inline">\(f\)</span> est dit maximal si
pour tout autre flot <span class="math inline">\(f&#39;\)</span>, on a
<span class="math inline">\(|f| \geq |f&#39;|\)</span>, où <span
class="math inline">\(|f| = \sum_{e \in \delta^+(s)} f(e) - \sum_{e \in
\delta^-(s)} f(e)\)</span> représente la valeur du flot.</p>
</div>
<h1 id="théorèmes">Théorèmes</h1>
<p>Le théorème fondamental des flots maximaux et coupes minimales est un
résultat central en théorie des graphes. Il établit une relation
profonde entre les flots maximaux et les coupes minimales dans un réseau
de flux.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(G = (V, E)\)</span> un graphe
orienté avec une capacité <span class="math inline">\(c : E \rightarrow
\mathbb{R}^+\)</span>, une source <span class="math inline">\(s\)</span>
et un puits <span class="math inline">\(t\)</span>. Alors, la valeur
d’un flot maximal de <span class="math inline">\(s\)</span> à <span
class="math inline">\(t\)</span> est égale à la capacité d’une coupe
minimale séparant <span class="math inline">\(s\)</span> et <span
class="math inline">\(t\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> La preuve de ce théorème repose sur l’algorithme du
chemin d’augmentation de Ford-Fulkerson. Supposons que <span
class="math inline">\(f\)</span> soit un flot maximal et <span
class="math inline">\(S\)</span> une coupe minimale. Nous devons montrer
que <span class="math inline">\(|f| = c(S, \overline{S})\)</span>, où
<span class="math inline">\(c(S, \overline{S})\)</span> est la capacité
de la coupe <span class="math inline">\((S, \overline{S})\)</span>.</p>
<p>1. **Initialisation** : Commencez avec un flot nul <span
class="math inline">\(f(e) = 0\)</span> pour tout <span
class="math inline">\(e \in E\)</span>.</p>
<p>2. **Chemin d’augmentation** : Trouvez un chemin <span
class="math inline">\(P\)</span> de <span
class="math inline">\(s\)</span> à <span
class="math inline">\(t\)</span> dans le graphe résiduel <span
class="math inline">\(G_f\)</span>, où chaque arête <span
class="math inline">\(e\)</span> a une capacité résiduelle <span
class="math inline">\(c_f(e) = c(e) - f(e)\)</span>.</p>
<p>3. **Augmentation du flot** : Augmentez le flot le long du chemin
<span class="math inline">\(P\)</span> par la quantité minimale des
capacités résiduelles des arêtes dans <span
class="math inline">\(P\)</span>.</p>
<p>4. **Terminaison** : Répétez les étapes 2 et 3 jusqu’à ce qu’il n’y
ait plus de chemin d’augmentation. À ce stade, <span
class="math inline">\(f\)</span> est un flot maximal.</p>
<p>Pour montrer que <span class="math inline">\(|f| = c(S,
\overline{S})\)</span>, nous utilisons le fait que pour toute coupe
<span class="math inline">\((S, \overline{S})\)</span>, on a <span
class="math inline">\(|f| \leq c(S, \overline{S})\)</span>. Puisque
<span class="math inline">\(f\)</span> est maximal, il existe une coupe
<span class="math inline">\((S, \overline{S})\)</span> telle que <span
class="math inline">\(|f| = c(S, \overline{S})\)</span>. ◻</p>
</div>
<h1 id="preuves">Preuves</h1>
<p>La preuve du théorème des flots maximaux et coupes minimales est
basée sur l’algorithme de Ford-Fulkerson. Voici une justification
détaillée de chaque étape :</p>
<p>1. **Initialisation** : Le flot initial est nul, ce qui signifie que
<span class="math inline">\(f(e) = 0\)</span> pour tout <span
class="math inline">\(e \in E\)</span>. La valeur du flot initial est
<span class="math inline">\(|f| = 0\)</span>.</p>
<p>2. **Chemin d’augmentation** : Le graphe résiduel <span
class="math inline">\(G_f\)</span> est construit en inversant les arêtes
où le flot est positif. Un chemin d’augmentation <span
class="math inline">\(P\)</span> dans <span
class="math inline">\(G_f\)</span> permet d’augmenter le flot de <span
class="math inline">\(s\)</span> à <span
class="math inline">\(t\)</span>.</p>
<p>3. **Augmentation du flot** : Pour chaque arête <span
class="math inline">\(e\)</span> dans le chemin <span
class="math inline">\(P\)</span>, on augmente le flot par la quantité
minimale des capacités résiduelles. Cela garantit que les contraintes de
capacité sont respectées.</p>
<p>4. **Terminaison** : L’algorithme se termine lorsque le graphe
résiduel ne contient plus de chemin de <span
class="math inline">\(s\)</span> à <span
class="math inline">\(t\)</span>. À ce point, le flot <span
class="math inline">\(f\)</span> est maximal.</p>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Plusieurs propriétés importantes découlent du théorème des flots
maximaux et coupes minimales. En voici quelques-unes :</p>
<ol>
<li><p>**Propriété de dualité** : La valeur d’un flot maximal est égale
à la capacité d’une coupe minimale. Cela établit une relation de dualité
entre les flots et les coupes.</p></li>
<li><p>**Algorithme de Ford-Fulkerson** : L’algorithme de Ford-Fulkerson
permet de trouver un flot maximal en temps polynomial sous certaines
conditions. Il repose sur la recherche de chemins d’augmentation dans le
graphe résiduel.</p></li>
<li><p>**Théorème de Max-Flow Min-Cut** : Ce théorème est une
généralisation du théorème des flots maximaux et coupes minimales. Il
s’applique à des graphes plus généraux et fournit des bornes sur la
valeur du flot maximal.</p></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>Les problèmes de flot sont d’une importance capitale en théorie des
graphes et en optimisation combinatoire. Leur étude permet de comprendre
les limites computationnelles et algorithmiques des problèmes de flux,
ainsi que de développer des méthodes efficaces pour les résoudre. Le
théorème des flots maximaux et coupes minimales est un résultat
fondamental qui établit une relation profonde entre les flots et les
coupes dans un réseau de flux. Les algorithmes basés sur ce théorème,
tels que l’algorithme de Ford-Fulkerson, sont essentiels pour résoudre
ces problèmes de manière efficace.</p>
</body>
</html>
{% include "footer.html" %}

