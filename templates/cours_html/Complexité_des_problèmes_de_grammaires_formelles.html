{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de grammaires formelles</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de grammaires formelles</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>Les grammaires formelles constituent un pilier fondamental en
informatique théorique, particulièrement dans le domaine de la théorie
des langages et de l’analyse syntaxique. Leur étude remonte aux travaux
pionniers de Noam Chomsky dans les années 1950, qui a introduit une
hiérarchie de grammaires classées par leur pouvoir expressif. Ces
grammaires permettent de décrire la structure syntaxique des langages
formels, un aspect crucial pour la compilation, l’analyse de programmes
et même la linguistique computationnelle.</p>
<p>L’étude de la complexité des problèmes liés aux grammaires formelles
est indispensable pour comprendre les limites et les capacités des
différents types de grammaires. Par exemple, les grammaires régulières
sont simples à analyser et trouvent des applications dans les automates
finis, tandis que les grammaires contextuelles libres sont plus
complexes mais essentielles pour la compilation de langages de
programmation. La complexité des problèmes de grammaires formelles
permet de déterminer les ressources nécessaires pour résoudre des
questions telles que l’appartenance d’une chaîne à un langage ou la
reconnaissance de structures syntaxiques.</p>
<h1 id="définitions">Définitions</h1>
<p>Avant d’aborder la complexité, il est essentiel de définir les
concepts fondamentaux liés aux grammaires formelles. Une grammaire
formelle est un quadruplet <span class="math inline">\(G = (V, \Sigma,
R, S)\)</span>, où :</p>
<ul>
<li><p><span class="math inline">\(V\)</span> est un ensemble fini de
symboles non terminaux,</p></li>
<li><p><span class="math inline">\(\Sigma\)</span> est un ensemble fini
de symboles terminaux disjoint de <span
class="math inline">\(V\)</span>,</p></li>
<li><p><span class="math inline">\(R\)</span> est un ensemble fini de
règles de production,</p></li>
<li><p><span class="math inline">\(S \in V\)</span> est le symbole
initial.</p></li>
</ul>
<p>Nous cherchons à décrire les langages formels engendrés par ces
grammaires. Un langage <span class="math inline">\(L\)</span> est dit
reconnaissable par une grammaire <span class="math inline">\(G\)</span>
si chaque chaîne de <span class="math inline">\(L\)</span> peut être
dérivée à partir du symbole initial <span
class="math inline">\(S\)</span> en appliquant les règles de
production.</p>
<p>Formellement, pour une grammaire <span class="math inline">\(G = (V,
\Sigma, R, S)\)</span>, le langage engendré <span
class="math inline">\(L(G)\)</span> est défini par : <span
class="math display">\[L(G) = \{ w \in \Sigma^* \mid S
\stackrel{*}{\Rightarrow} w \}\]</span> où <span
class="math inline">\(\stackrel{*}{\Rightarrow}\)</span> signifie que
<span class="math inline">\(w\)</span> peut être dérivé de <span
class="math inline">\(S\)</span> en appliquant une séquence finie de
règles de production.</p>
<h1 id="théorèmes">Théorèmes</h1>
<p>Un des théorèmes fondamentaux concernant les grammaires formelles est
le théorème de Chomsky-Schützenberger, qui établit une correspondance
entre les types de grammaires et les classes de complexité. Ce théorème
est crucial pour comprendre la hiérarchie des grammaires et leurs
implications en termes de complexité.</p>
<div class="theorem">
<p>Pour toute grammaire formelle <span class="math inline">\(G\)</span>,
le langage <span class="math inline">\(L(G)\)</span> appartient à une
classe de complexité déterminée par le type de grammaire. Plus
précisément :</p>
<ul>
<li><p>Les langages réguliers sont reconnaissables en temps linéaire par
des automates finis.</p></li>
<li><p>Les langages hors-contexte sont reconnaissables en temps
polynomial par des automates à pile.</p></li>
<li><p>Les langages contextuels sont reconnaissables en temps
exponentiel par des automates linéairement bornés.</p></li>
</ul>
</div>
<p>La démonstration de ce théorème repose sur des résultats de théorie
des automates et de complexité computationnelle. Par exemple, pour les
langages réguliers, l’algorithme de Glushkov permet de construire un
automate fini à partir d’une expression régulière en temps linéaire.</p>
<h1 id="preuves">Preuves</h1>
<p>Pour illustrer la complexité des problèmes de grammaires formelles,
considérons le problème de l’appartenance d’une chaîne à un langage
engendré par une grammaire hors-contexte. Ce problème est connu pour
être dans la classe de complexité P.</p>
<div class="proof">
<p><em>Proof.</em> Soit <span class="math inline">\(G = (V, \Sigma, R,
S)\)</span> une grammaire hors-contexte et <span class="math inline">\(w
\in \Sigma^*\)</span> une chaîne. Nous voulons déterminer si <span
class="math inline">\(w \in L(G)\)</span>.</p>
<p>1. **Construction de l’arbre de dérivation** : Nous commençons par
construire un arbre de dérivation pour <span
class="math inline">\(w\)</span>. Chaque nœud de l’arbre est étiqueté
par un symbole non terminal ou une chaîne de symboles terminaux. La
racine est étiquetée par <span class="math inline">\(S\)</span>, et les
feuilles sont étiquetées par les symboles de <span
class="math inline">\(w\)</span>.</p>
<p>2. **Vérification des règles de production** : Pour chaque nœud
interne, nous vérifions s’il existe une règle de production <span
class="math inline">\(A \rightarrow \alpha\)</span> dans <span
class="math inline">\(R\)</span> telle que le nœud est étiqueté par
<span class="math inline">\(A\)</span> et ses fils sont étiquetés par
les symboles de <span class="math inline">\(\alpha\)</span>.</p>
<p>3. **Complexité temporelle** : La construction de l’arbre de
dérivation peut être effectuée en temps polynomial par rapport à la
longueur de <span class="math inline">\(w\)</span> et au nombre de
règles de production. Plus précisément, si <span
class="math inline">\(n\)</span> est la longueur de <span
class="math inline">\(w\)</span> et <span
class="math inline">\(m\)</span> le nombre de règles, la complexité est
<span class="math inline">\(O(n^3 \cdot m)\)</span>.</p>
<p>Ainsi, le problème de l’appartenance est dans la classe P. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Plusieurs propriétés importantes découlent du théorème de
Chomsky-Schützenberger et des résultats de complexité associés.</p>
<ol>
<li><p>**Propriété de clôture** : Les langages réguliers sont fermés
sous les opérations de union, concaténation et étoile de Kleene. Cette
propriété est cruciale pour la construction d’automates finis à partir
d’expressions régulières.</p></li>
<li><p>**Propriété de décision** : Le problème de l’appartenance pour
les langages hors-contexte est décidable en temps polynomial. Cela
signifie qu’il existe un algorithme efficace pour déterminer si une
chaîne donnée appartient au langage engendré par une grammaire
hors-contexte.</p></li>
<li><p>**Propriété de hiérarchie** : La hiérarchie des grammaires
formelles est stricte, ce qui signifie que chaque classe de grammaires a
un pouvoir expressif strictement supérieur à la classe inférieure. Par
exemple, il existe des langages hors-contexte qui ne peuvent pas être
engendrés par des grammaires régulières.</p></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>L’étude de la complexité des problèmes de grammaires formelles est
essentielle pour comprendre les limites et les capacités des différents
types de grammaires. Les résultats obtenus permettent de déterminer les
ressources nécessaires pour résoudre des problèmes fondamentaux en
théorie des langages et en informatique théorique. Les grammaires
formelles continuent d’être un domaine actif de recherche, avec des
applications dans la compilation, l’analyse syntaxique et la
linguistique computationnelle.</p>
</body>
</html>
{% include "footer.html" %}

