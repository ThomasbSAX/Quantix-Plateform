{% include "header.html" %}
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

  <!-- CSS du site -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Quantix" />
  <meta name="dcterms.date" content="2026-01-11" />
  <title>Complexité des problèmes de programmation linéaire en nombres entiers</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/cours.css') }}">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexité des problèmes de programmation linéaire en
nombres entiers</h1>
<p class="author">Quantix</p>
<p class="date">2026-01-11</p>
</header>
<h1 id="introduction-et-motivations">Introduction et Motivations</h1>
<p>La programmation linéaire en nombres entiers (PLNE) est un domaine
mathématique qui trouve ses racines dans les travaux de George Dantzig
au milieu du XXe siècle. Ce champ d’étude émerge comme une réponse
naturelle aux limitations des modèles de programmation linéaire
classique, où les variables sont continues. L’introduction de
contraintes d’intégralité permet de modéliser des problèmes concrets où
les solutions doivent être entières, comme l’optimisation de ressources
discrètes ou la planification de projets.</p>
<p>L’importance de la PLNE réside dans sa capacité à résoudre des
problèmes complexes et variés, allant de l’optimisation industrielle à
la logistique, en passant par le design de réseaux. Cependant, cette
puissance vient avec un coût : la complexité computationnelle des
problèmes de PLNE est bien plus élevée que celle des problèmes de
programmation linéaire classique. Comprendre cette complexité est
crucial pour développer des algorithmes efficaces et pour évaluer la
faisabilité des solutions proposées.</p>
<h1 id="définitions">Définitions</h1>
<p>Pour aborder la complexité des problèmes de PLNE, il est essentiel de
comprendre les concepts fondamentaux qui les sous-tendent. Commençons
par définir ce qu’est un problème de programmation linéaire en nombres
entiers.</p>
<p>Supposons que nous ayons un problème d’optimisation où nous cherchons
à maximiser ou minimiser une fonction objective linéaire, sous des
contraintes linéaires. Si de plus nous exigeons que les variables
prennent des valeurs entières, nous obtenons un problème de PLNE.</p>
<div class="definition">
<p>Soit <span class="math inline">\(A \in \mathbb{Z}^{m \times
n}\)</span>, <span class="math inline">\(b \in \mathbb{Z}^m\)</span>, et
<span class="math inline">\(c \in \mathbb{Z}^n\)</span>. Le problème de
programmation linéaire en nombres entiers (PLNE) est défini comme suit :
<span class="math display">\[\begin{aligned}
&amp;\text{minimiser} &amp; &amp; c^T x \\
&amp;\text{sous contraintes} &amp; &amp; A x \leq b, \\
&amp;&amp;&amp; x \in \mathbb{Z}^n.
\end{aligned}\]</span></p>
</div>
<p>Une autre formulation équivalente est : <span
class="math display">\[\begin{aligned}
&amp;\text{minimiser} &amp; &amp; \sum_{j=1}^n c_j x_j \\
&amp;\text{sous contraintes} &amp; &amp; \sum_{j=1}^n a_{ij} x_j \leq
b_i, \quad i = 1, \ldots, m, \\
&amp;&amp;&amp; x_j \in \mathbb{Z}, \quad j = 1, \ldots, n.
\end{aligned}\]</span></p>
<h1 id="théorèmes">Théorèmes</h1>
<p>L’un des théorèmes fondamentaux en PLNE est le théorème de complexité
de Lenstra. Ce théorème établit une borne supérieure sur la complexité
de résolution des problèmes de PLNE en fonction du nombre de
variables.</p>
<div class="theorem">
<p>Soit <span class="math inline">\(A \in \mathbb{Z}^{m \times
n}\)</span>, <span class="math inline">\(b \in \mathbb{Z}^m\)</span>, et
<span class="math inline">\(c \in \mathbb{Z}^n\)</span>. Le problème de
PLNE : <span class="math display">\[\begin{aligned}
&amp;\text{minimiser} &amp; &amp; c^T x \\
&amp;\text{sous contraintes} &amp; &amp; A x \leq b, \\
&amp;&amp;&amp; x \in \mathbb{Z}^n
\end{aligned}\]</span> peut être résolu en temps polynomial si le nombre
de variables <span class="math inline">\(n\)</span> est fixe.</p>
</div>
<p>Une autre formulation du théorème de Lenstra est : <span
class="math display">\[\text{Le problème de PLNE peut être résolu en
temps polynomial si } n \text{ est constant.}\]</span></p>
<h1 id="preuves">Preuves</h1>
<p>La preuve du théorème de Lenstra repose sur plusieurs étapes clés.
Tout d’abord, nous utilisons le fait que les solutions entières sont des
points de réseau dans <span class="math inline">\(\mathbb{R}^n\)</span>.
Ensuite, nous appliquons l’algorithme de l’ellipsoïde pour énumérer les
points du réseau dans un polyèdre borné.</p>
<div class="proof">
<p><em>Proof.</em> 1. Considérons le polyèdre <span
class="math inline">\(P = \{ x \in \mathbb{R}^n \mid A x \leq b
\}\)</span>. Les solutions entières du problème de PLNE sont les points
du réseau <span class="math inline">\(P \cap \mathbb{Z}^n\)</span>.</p>
<p>2. Utilisons l’algorithme de l’ellipsoïde pour énumérer les points du
réseau dans <span class="math inline">\(P\)</span>. Cet algorithme
permet de trouver une solution optimale en temps polynomial si le nombre
de variables <span class="math inline">\(n\)</span> est fixe.</p>
<p>3. En effet, pour chaque variable <span
class="math inline">\(x_j\)</span>, nous pouvons énumérer les valeurs
entières possibles dans un intervalle borné. Le nombre de combinaisons
possibles est alors polynomial en <span
class="math inline">\(n\)</span>.</p>
<p>4. Par conséquent, le problème de PLNE peut être résolu en temps
polynomial si <span class="math inline">\(n\)</span> est constant. ◻</p>
</div>
<h1 id="propriétés-et-corollaires">Propriétés et Corollaires</h1>
<p>Le théorème de Lenstra a plusieurs conséquences importantes. Voici
quelques propriétés et corollaires :</p>
<ol>
<li><p><strong>Propriété de Complexité Polynomiale</strong> : Si le
nombre de variables <span class="math inline">\(n\)</span> est fixe, le
problème de PLNE peut être résolu en temps polynomial.</p>
<div class="proof">
<p><em>Proof.</em> Ceci découle directement du théorème de Lenstra. En
effet, l’algorithme de l’ellipsoïde permet d’énumérer les points du
réseau dans un polyèdre borné en temps polynomial si <span
class="math inline">\(n\)</span> est constant. ◻</p>
</div></li>
<li><p><strong>Propriété de NP-Difficulté</strong> : En général, le
problème de PLNE est NP-difficile. Cela signifie qu’il n’existe pas
d’algorithme polynomial connu pour résoudre le problème de PLNE en
fonction du nombre de variables et des coefficients.</p>
<div class="proof">
<p><em>Proof.</em> La NP-difficulté du problème de PLNE peut être
démontrée en réduisant le problème du sac à dos, qui est un problème
classique NP-difficile, au problème de PLNE. ◻</p>
</div></li>
<li><p><strong>Propriété de Complexité Exponentielle</strong> : En
l’absence de contraintes sur le nombre de variables, la complexité du
problème de PLNE est exponentielle. Cela signifie que le temps de calcul
nécessaire pour résoudre le problème croît exponentiellement avec le
nombre de variables.</p>
<div class="proof">
<p><em>Proof.</em> Cette propriété découle du fait que l’énumération des
points du réseau dans un polyèdre non borné nécessite un temps
exponentiel en fonction du nombre de variables. ◻</p>
</div></li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>La complexité des problèmes de programmation linéaire en nombres
entiers est un sujet fascinant et crucial pour l’optimisation discrète.
Le théorème de Lenstra montre que ces problèmes peuvent être résolus en
temps polynomial si le nombre de variables est fixe, mais ils restent
NP-difficiles en général. Comprendre ces nuances est essentiel pour
développer des algorithmes efficaces et pour évaluer la faisabilité des
solutions proposées.</p>
</body>
</html>
{% include "footer.html" %}

